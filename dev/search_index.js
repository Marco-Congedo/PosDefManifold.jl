var documenterSearchIndex = {"docs":
[{"location":"signalProcessing/#signalProcessing.jl-1","page":"signalProcessing.jl","title":"signalProcessing.jl","text":"","category":"section"},{"location":"signalProcessing/#","page":"signalProcessing.jl","title":"signalProcessing.jl","text":"This unit contains miscellaneous signal processing functions useful in relation to the Riemannian geometry of the manifold of Symmetric Positive Definite (SPD) or Hermitian Positive Definite (HPD) matrices. In Julia those are Hermitian matrices, see typecasting matrices.","category":"page"},{"location":"signalProcessing/#","page":"signalProcessing.jl","title":"signalProcessing.jl","text":"Function Description\nrandChiÂ², randÏ‡Â² Generate a random variable distributed as a chi-squared\nrandEigvals, randÎ» Generate a random vectors of real positive eigenvalues\nrandEigvalsMat, randÎ› Generate a random diagonal matrix of real positive eigenvalues\nrandUnitaryMat, randU Generate a random orthogonal or unitary matrix\nrandPosDefMat, randP Generate one or an array of random positive definite matrices\nregularize! Regularize an array of positive definite matrices\ngram Gram matrix of a matrix\ntrade trace and determinant of a matrix as a 2-tuple","category":"page"},{"location":"signalProcessing/#","page":"signalProcessing.jl","title":"signalProcessing.jl","text":"â‹…","category":"page"},{"location":"signalProcessing/#","page":"signalProcessing.jl","title":"signalProcessing.jl","text":"randChiÂ²\nrandEigvals\nrandEigvalsMat\nrandUnitaryMat\nrandPosDefMat\nregularize!\ngram\ntrade","category":"page"},{"location":"signalProcessing/#PosDefManifold.randChiÂ²","page":"signalProcessing.jl","title":"PosDefManifold.randChiÂ²","text":"randChiÂ²(df::Int)\n\nalias: randÏ‡Â²\n\nGenerate a random variable distributed as a chi-squared with df  degrees of freedom.\n\nIt uses the Wilsonâ€“Hilferty transformation for df>=20 -  see chi-squared distribution.\n\nExamples\n\nusing Plots, PosDefManifold\nchi=[randÏ‡Â²(2) for i=1:10000]\nhistogram(chi) # needs Plots package. Check your plots back-end.\n\n\n\n\n\n","category":"function"},{"location":"signalProcessing/#PosDefManifold.randEigvals","page":"signalProcessing.jl","title":"PosDefManifold.randEigvals","text":"    randEigvals(n::Int;\n    <\n    df::Int=2,\n    eigvalsSNR::Real=10e3 >)\n\nalias: randÎ»\n\nGenerate an n-vector of random real positive eigenvalues.  The eigenvalues are generated as in function randÎ›(randEigvalsMat),  the syntax of which is used.\n\nSee also: randU (randUnitaryMat), randP (randPosDefMat).\n\nExamples\n\nusing Plots, PosDefManifold\nÎ»=sort(randÎ»(10), rev=true)\nÏƒ=sort(randÎ»(10, eigvalsSNR=10), rev=true)\nplot(Î») # needs Plots package. Check your plots back-end.\nplot!(Ïƒ) # needs Plots package. Check your plots back-end.\n\n\n\n\n\n","category":"function"},{"location":"signalProcessing/#PosDefManifold.randEigvalsMat","page":"signalProcessing.jl","title":"PosDefManifold.randEigvalsMat","text":"    (1) randEigvalsMat(n::Int;\n    <\n    df::Int=2,\n    eigvalsSNR::Real=10e3 >)\n\n    (2) randEigvalsMat(n::Int, k::Int;\n    < same keyword arguments as in (1) >)\n\nalias: randÎ›\n\n(1) Generate an nn diagonal matrix of random real positive eigenvalues.  (2) An array 1d (of ğ”»Vector type) of k matrices of the kind in (1)\n\nThe eigenvalues are generated according to model\n\nÎ»_i=Ï‡_df^2+Î·hspace6pttextrmforhspace2pti=1n\n\nwhere\n\nÏ‡_df^2 (signal term) is randomly distributed as a chi-square with df degrees of freedom,\nÎ· is a white noise term, function of <keyword argument> eigvalsSNR, such that\n\ntextrmeigenvalues SNR=mathbbEbig(sum_i=1^nÎ»_ibig)bignÎ·\n\nThe expected sum mathbbEbig(sum_i=1^nÎ»_ibig) here above is the  expected variance of the signal term, i.e., n(df), since the expectation  of a random chi-squared variable is equal to its degrees of freedom.\n\nIf eigvalsSNR=Inf is passed as argument, then Î· is set to zero, i.e.,  no white noise is added. In any case eigvalsSNR must be positive.\n\nNote that with the default value of <keyword argument> df (df=2)  the generating model assumes that the eigenvalues  have exponentially decaying variance, which is often observed on real data.\n\nnote: Nota Bene\nThe <keyword argument> eigvalsSNR expresses the expected eigenvalues SNR (signal-to-noise ratio), not the real one, and is not expressed in decibels, but as the expected SNR variance ratio.\n\nThis function is used by function randP (randPosDefMat) to generate  random positive definite matrices with added white noise in order  to emulate eigenvalues observed in real data and to  improve the conditioning of the generated matrices with respect to inversion.\n\nSee also: randÎ» (randEigvals), randU (randUnitaryMat),  randP (randPosDefMat), randÏ‡Â² (randChiÂ²).\n\nExamples\n\nusing PosDefManifold\n# (1)\nn=3;\nU=randU(n);\nÎ›=randÎ›(n, eigvalsSNR=100)\nP=U*Î›*U' # generate an SPD matrix\nusing LinearAlgebra\nQ=â„(U*Î›*U') # generate an SPD matrix and flag it as 'Hermitian'\n\n# (2) generate an array of 10 matrices of simulated eigenvalues\nDvec=randÎ›(n, 10)\n\n\n\n\n\n","category":"function"},{"location":"signalProcessing/#PosDefManifold.randUnitaryMat","page":"signalProcessing.jl","title":"PosDefManifold.randUnitaryMat","text":"(1) randUnitaryMat(n::Int)\n(2) randUnitaryMat(::Type{Complex{T}}, n::Int)\n\naliases: randOrthMat, randU\n\nGenerate a random nn\n\n(1) orthogonal matrix (real)\n(2) unitary matrix (complex)\n\nThe matrices are generated running the modified (stabilized)  Gram-Schmidt orthogonalization  procedure (mgs) on an nn matrix filled with random Gaussian elements.\n\nSee also: randÎ› (randEigvals), randP (randPosDefMat).\n\nExamples\n\nusing PosDefManifold\nn=3;\nX=randU(n)*sqrt(randÎ›(n))*randU(n)'  # (1) generate a random square real matrix\n\nU=randU(ComplexF64, n);\nV=randU(ComplexF64, n);\nY=U*sqrt(randÎ›(n))*V' # (2) generate a random square complex matrix\n\n\n\n\n\n","category":"function"},{"location":"signalProcessing/#PosDefManifold.randPosDefMat","page":"signalProcessing.jl","title":"PosDefManifold.randPosDefMat","text":"    (1) randPosDefMat(n::Int;\n    <\n    df::Int=2,\n    eigvalsSNR::Real=10e3 >)\n\n    (2) randPosDefMat(::Type{Complex{T}}, n:: Int;\n    < same keyword arguments as in (1) >)\n\n    (3) randPosDefMat(n::Int, k::Int;\n    <\n    df::Int=2,\n    eigvalsSNR::Real=10e3,\n    SNR::Real=100,\n    commuting=false >)\n\n    (4) randPosDefMat(::Type{Complex{T}}, n::Int, k::Int;\n    < same keyword arguments as in (3) >)\n\nalias: randP\n\nGenerate\n\n(1) one random Hermitian positive definite matrix (real) of size nn\n(2) one random Hermitian positive definite matrix (complex) of size nn\n(3) an array 1d (of â„Vector type) of k matrices of the kind in (1)\n(4) an array 1d (of â„Vector type) of k matrices of the kind in (2).\n\nMethods (3) and (4) are multi-threaded. See Threads.\n\nFor (1) and (2) the matrix is generated according to model\n\nUÎ›U^H+Î·I,\n\nwhere U is a random orthogonal (1) or unitary (2) matrix generated by  function randU(randUnitaryMat) and Î›, Î· are a positive definite  diagonal matrix and a non-negative scalar depending on <optional keywords arguments>  df and eigvalsSNR randomly generated calling function  randÎ›(randEigvalsMat).\n\nFor (3) and (4), if the <optional keyword argument> commuting=true is passed,  the k matrices are generated according to model\n\nUÎ›_iU^H+Î·Ihspace8pt, for i=1:k\n\notherwise they are generated accrding to model\n\n(UÎ›_iU^H+Î·I)+Ï†(V_iÎ”_iV_i^H+Î·I)hspace8pt, for i=1:k  Eq.[1]\n\nwhere\n\nU and the V_i are random (3) orthogonal/(4) unitary matrices,\nÎ›_i and Î”_i are positive definite diagonal matrices\nÎ· is a non-negative scalar.\n\nAll variables here above are randomly generated as in (1) and (2)\n\nÏ† is adjusted so as to obtain a desired output SNR (signal-to-noise ratio), which is also an\n\n<optional keywords arguments>, such as\n\nSNR=fracdisplaystylesum_i=1^ktextrmtr(UÎ›_iU^H+Î·I)displaystylesum_i=1^ktextrmtrÏ†(V_iÎ”_iV_i^H+Î·I).\n\nnote: Nota Bene\nThe keyword arguments SNR is not expressed in decibels, but as the expected SNR variance ratio. It must be a positive number.\n\nA slightly different version of this model for generating positive definite  matrices has been proposed in (Congedo et al., 2017b)[ğŸ“];  in the model of Eq. [1]\n\nUÎ›_iU^H is the signal term, where the signal is supposed sharing the same coordinates for all matrices,\nÏ†(V_iÎ”_iV_i^H) is a structured noise term, which is different for all matrices\nÎ·I is a white noise term, with same variance for all matrices.\n\nSee also: the aforementioned paper and randÎ› (randEigvalsMat).\n\nExamples\n\nusing PosDefManifold\nR=randP(10, df=10, eigvalsSNR=1000) # 1 SDP Matrix of size 10x10 #(1)\nH=randP(ComplexF64, 5, eigvalsSNR=10) # 1 Hermitian Matrix of size 5x5 # (2)\nâ„›=randP(10, 1000, eigvalsSNR=100) # 1000 SPD Matrices of size 10x10 # (3)\nusing Plots\nheatmap(Matrix(â„›[1]), yflip=true, c=:bluesreds)\nâ„‹=randP(ComplexF64, 20, 1000) # 1000 Hermitian Matrices of size 20x20 # (4)\n\n\n\n\n\n","category":"function"},{"location":"signalProcessing/#PosDefManifold.regularize!","page":"signalProcessing.jl","title":"PosDefManifold.regularize!","text":"(1) regularize!(P::â„; <SNR=10e3>)\n(2) regularize!(ğ::â„Vector; <SNR=10e3>)\n\nAdd white noise to either\n\n(1) a positive definite matrix P of size nn, or\n(2) a 1d array ğ of k positive definite matrices of size nn, of â„Vector type.\n\nThe added noise improves the matrix conditioning with respect to inversion.  This is used to avoid numerical errors when decomposing these matrices  or when evaluating some functions of their eigevalues such as the log.\n\nA constant value is added to all diagonal elements of (1) P  or (2) af all matrices in ğ,  that is, on output:\n\ntextrm(1)hspace2ptPleftarrow P+Î·I\n\ntextrm(2)hspace2ptğ_ileftarrow ğ_i+Î·I hspace2pttextrmforhspace2pt i=1k\n\nThe amount of added noise Î· is determined by the SNR  <keyword argument>, which by default is 10000. This is  such that\n\ntextrm(1)hspace2ptSNR=fracdisplaystyletextrmtr(P)displaystyletextrmtr(Î·I)\n\ntextrm(2)hspace2ptSNR=fracdisplaystylesum_i=1^ktextrmtr(ğ_i)displaystyle khspace1pttextrmtr(Î·I)\n\nP in (1) must be flagged as Hermitian. See typecasting matrices.\n\nnote: Nota Bene\nThe keyword argument SNR expresses a SNR (signal-to-noise ratio), and is not expressed in decibels,  but as the SNR variance ratio. It must be a positive number. Differently from function randÎ›randEigvalsMat, randÎ»randEigvals and randPrandPosDefMat, the SNR here is not the expected SNR, but the actual SNR.\n\nSee also: randP (randPosDefMat).\n\nExamples\n\n# (1)\nusing LinearAlgebra, Plots, PosDefManifold\nn=3\nU=randU(n)\n# in Q we will write two matrices,\n# the unregularized and regularized matrix side by side\nQ=Matrix{Float64}(undef, n, n*2)\nP=â„(U*Diagonal(randn(n).^2)*U') # generate a real 3x3 positive matrix\nfor i=1:n, j=1:n Q[i, j]=P[i, j] end\nregularize!(P, SNR=5)\nfor i=1:n, j=1:n Q[i, j+n]=P[i, j] end # the regularized matrix is on the right\nheatmap(Matrix(Q), yflip=true, c=:bluesreds)\n\n# (2)\nğ=[â„(U*Diagonal(randn(3).^2)*U') for i=1:5] # 5 real 3x3 positive matrices\nregularize!(ğ, SNR=1000)\n\nRun a test\n\nusing LinearAlgebra\nğ=randP(10, 100, SNR=1000); # 100 real Hermitian matrices\nsignalVar=sum(tr(P) for P in ğ);\nregularize!(ğ, SNR=1000);\nsignalPlusNoiseVar=sum(tr(P) for P in ğ);\noutput_snr=signalVar/(signalPlusNoiseVar-signalVar)\n# output_snr should be approx. equal to 1000\n\n\n\n\n\n","category":"function"},{"location":"signalProcessing/#PosDefManifold.gram","page":"signalProcessing.jl","title":"PosDefManifold.gram","text":"gram(X::Matrix{T}) where T<:RealOrComplex\n\nGiven a generic data matrix X, comprised of real or complex elements,  return the normalized Gram matrix, that is,  the covariance matrix of X  corrected by sample size, but without subtracting the mean.\n\nThe result is flagged as Hermitian.  See typecasting matrices.\n\nnote: Nota Bene\nIf X is wide or square (r<=c) return XX^Hc. If X is tall (r>c)            return X^HXr.\n\nExamples\n\nusing PosDefManifold\nX=randn(5, 150);\nG=gram(X) # => G=X*X'/150\nX=randn(100, 2);\nF=gram(X); # => G=X'*X/100\n\n\n\n\n\n","category":"function"},{"location":"signalProcessing/#PosDefManifold.trade","page":"signalProcessing.jl","title":"PosDefManifold.trade","text":"trade(P::â„{T}) where T<:RealOrComplex\n\nGiven a positive definite matrix P, return as a 2-tuple the  trace and the determinant of P.  This is used to plot positive matrices in two dimensions  (TraDe plots: log(trace/n) vs. log(determinant), see exemple here below).\n\nP must be flagged by julia as Hermitian.   See typecasting matrices.\n\nExamples\n\nusing PosDefManifold\nP=randP(3)\nt, d=trade(P)  # equivalent to (t, d)=trade(P)\n\n# TraDe plot\nusing Plots\nk=100\nn=10\nğ=randP(n, k, SNR=1000); # 100 real Hermitian matrices\nx=Vector{Float64}(undef, k)\ny=Vector{Float64}(undef, k)\nfor i=1:k\n    x[i], y[i] = trade(ğ[i])\nend\nx=log.(x./n)\ny=log.(y)\nplot(x, y, seriestype=:scatter)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#linearAlgebra.jl-1","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"This unit contains linear algebra functions useful in relation to the Riemannian  geometry of the manifold of Symmetric Positive Definite (SPD) or  Hermitian Positive Definite (HPD) matrices. In Julia those are Hermitian matrices, see typecasting matrices.","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"In general they take a matrix as input (some may take other arrays as input) and are divided in eight categories depending on what kind of functions thay are and what they give as output:","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Category Output\n1. Utilities - - -\n2. Matrix normalizations and approximations matrix\n3. Boolean functions of matrices matrix\n4. Scalar functions of matrices scalar\n5. Diagonal functions of matrices diagonal matrix\n6. Unitary functions of matrices orthogonal/unitary matrix\n7. Matrix function of matrices matrix\n8. Spectral decompositions of positive matrices spectral function of input\n9. Decompositions involving triangular matrices triangular matrix","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#Utilities-1","page":"linearAlgebra.jl","title":"Utilities","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\ntypeofMatrix, typeofMat Return the type of the matrix argument\ntypeofVector, typeofVec Return the type of the matrix vector argument\ndim length of the dimensions of matrices and vectors of matrices","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"typeofMatrix\ntypeofVector\ndim","category":"page"},{"location":"linearAlgebra/#PosDefManifold.typeofMatrix","page":"linearAlgebra.jl","title":"PosDefManifold.typeofMatrix","text":"function typeofMatrix(\narray::Union{AnyMatrix, AnyMatrixVector, AnyMatrixVectorâ‚‚})\n\nalias: typeofMat\n\nReturn the type of a matrix, either Hermitian,  Diagonal, LowerTriangular, or Matrix.  Argument array may be a matrix of one of these types, but also one of the following:\n\nâ„Vector, â„Vectorâ‚‚, ğ”»Vector, ğ”»Vectorâ‚‚, ğ•ƒVector, ğ•ƒVectorâ‚‚,  ğ•„Vector, ğ•„Vectorâ‚‚.\n\nThose are Array of Matrices types.  See also aliases for the symbols â„, ğ”», ğ•ƒ and ğ•„.\n\nNote that this function is different from Julia function  typeof,  which returns the concrete type (see example below), thus  cannot be used for typecasting matrices.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nP=randP(3) # generate a 3x3 Hermitian matrix\ntypeofMatrix(P) # returns `Hermitian`\ntypeof(P) # returns `Hermitian{Float64,Array{Float64,2}}`\n# typecast P as a `Matrix` M\nM=Matrix(P)\n# typecast M as a matrix of the same type as P and write the result in A\nA=typeofMatrix(P)(M)\n\nPset=randP(3, 4) # generate a set of 4 3x3 Hermitian matrix\n# Pset is an â„Vector type\ntypeofMatrix(Pset) # again returns `Hermitian`\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.typeofVector","page":"linearAlgebra.jl","title":"PosDefManifold.typeofVector","text":"function typeofVector(\narray::Union{AnyMatrix, AnyMatrixVector, AnyMatrixVectorâ‚‚})\n\nalias: typeofVec\n\nReturn the type of a Vector, either HermitianVector,  DiagonalVector, LowerTriangularVector, or MatrixVector.  The aliases of those are, respectvely, â„Vector, ğ”»Vector, ğ•ƒVector and  ğ•„Vector.  Argument array may be a vector of one of these types, but also one of the  following:\n\nâ„, ğ”», ğ•ƒ and ğ•„, â„Vectorâ‚‚, ğ”»Vectorâ‚‚, ğ•ƒVectorâ‚‚, ğ•„Vectorâ‚‚.\n\nSee aliases for the symbols â„, ğ”», ğ•ƒ and ğ•„.  The last four are Array of Matrices types.\n\nNote that this function is different from Julia function  typeof  only in that it returns the vector type also if array  is not of the â„Vector, ğ”»Vector, ğ•ƒVector or  ğ•„Vector type.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nP=randP(3, 4) # generate 4 3x3 Hermitian matrix\ntypeofMatrix(P) # returns `Array{Hermitian,1}`\ntypeof(P) # also returns `Array{Hermitian,1}`\n\ntypeofMatrix(P[1]) # returns `Array{Hermitian,1}`\ntypeof(P[1]) # returns `Hermitian{Float64,Array{Float64,2}}`\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.dim","page":"linearAlgebra.jl","title":"PosDefManifold.dim","text":"(1) function dim(X::AnyMatrix, [d])\n(2) function dim(vector::AnyMatrixVector, [d])\n(3) function dim(vectorâ‚‚::AnyMatrixVectorâ‚‚, [d])\n\n(1) X is a real or complex Matrix, Diagonal,  LowerTriangular or Hermitian matrix.  Return a 2-tuple containing the dimensions of X,  which is two times the same dimension for all possible types of X  with the exception of the Matrix type, which can be rectangular.  Optionally you can specify a dimension (1 or 2)  to get just the length of that dimension.\n\n(2) vector is an ğ•„Vector, ğ”»Vector, ğ•ƒVector or â„Vector type  (see AnyMatrixVector type).  Return a 3-tuple containing the number of matrices it holds  (dimension 1) and their dimensions (dimension 2 and 3).  Optionally you can specify a dimension (1, 2, or 3)  to get just the length of that dimension.\n\n(3) vectorâ‚‚ is an ğ•„Vectorâ‚‚, ğ”»Vectorâ‚‚, ğ•ƒVectorâ‚‚ or â„Vectorâ‚‚ type  (see AnyMatrixVector type).  Return a 4-tuple containing\n\nthe number of vectors of matrices it holds (dimension 1),\na vector holding the number of matrices in each vector of matrices (dimensions 2),\nthe two dimensions of the matrices (dimension 3 and 4).\n\nOptionally you can specify a dimension (1, 2, 3 or 4)  to get just the length of that dimension.\n\nvector and vectorâ‚‚ are Array of Matrices types.  See also aliases for the symbols â„, ğ”», ğ•ƒ and ğ•„.\n\nnote: Nota Bene\nIf you specify a dimension and this is out of the valid range, the function returns zero.Both the vector(2) and the vectorâ‚‚(3) object are meant to hold matrices living in the same manifold, therefore it is assumed that all matrices they holds are of the same dimension. The dimensions of the matrices are retrived fromthe first matrix in vector(2),\nthe first matrix in the first vector of vectorâ‚‚(3).\n\nThis function replaces Julia size  function, which cannot be used to retrive dimension for matrix vectors.  It is not possible to overload the size function for matrix vectors  since this causes problems to other Julia functions.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\n# (1)\nM=randn(3, 4) # generate a 3x4 `Matrix`\ndim(M) # returns (3, 4)\ndim(M, 1) # returns 3\ndim(M, 2) # returns 4\ndim(M, 3) # out of range: returns 0\n\n# (2)\nPset=randP(3, 4) # generate an â„Vector holding 4 3x3 Hermitian matrices\ndim(Pset) # returns (4, 3, 3)\ndim(Pset, 1) # returns 4\ndim(Pset, 2) # returns 3\ndim(Pset, 3) # returns 3\n\n# (3)\n# Generate a set of 4 random 3x3 SPD matrices\nPset=randP(3, 4)\n# Generate a set of 40 random 4x4 SPD matrices\nQset=randP(3, 40)\nA=â„Vectorâ‚‚([Pset, Qset])\ndim(A) # return (2, [4, 40], 3, 3)\ndim(A, 1) # return 2\ndim(A, 2) # return [4, 40]\ndim(A, 2)[1] # return 4\ndim(A, 3) # return 3\ndim(A, 4) # return 3\ndim(A, 5) # out of range: return 0\n\n# note: to create an â„Vectorâ‚‚ object holding k â„Vector objects use\nsets=â„Vectorâ‚‚(undef, k) # and then fill them\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#Matrix-normalizations-and-approximations-1","page":"linearAlgebra.jl","title":"Matrix normalizations and approximations","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\ndet1 Normalize the determinant\ntr1 Normalize the trace\nnearestPosDef Nearest Symmetric/Hermitian Positive Semi-definite matrix\nnearestOrthogonal nearestOrth Nearest Orthogonal matrix\nnormalizeCol! Normalize one or more columns","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"det1\ntr1\nnearestPosDef\nnearestOrthogonal\nnormalizeCol!","category":"page"},{"location":"linearAlgebra/#PosDefManifold.det1","page":"linearAlgebra.jl","title":"PosDefManifold.det1","text":"function det1(X::AnyMatrix; <tol::Real=0.>)\n\nReturn the argument matrix X normalized so as to have unit determinant.  For square positive definite matrices this is the best approximant  from the set of matrices in the special linear group -  see Bhatia and Jain (2014)ğŸ“.\n\nX can be a real or complex Diagonal, LowerTriangular,  Matrix, or Hermitian matrix. (see AnyMatrix type)\n\nIf the determinant is not greater to tol (which defalts to zero)  a warning is printed and X is returned.\n\nnote: Nota Bene\nThis function is meant for positive definite matrices. Julia may throws an error while computing the determinant if the matrix is defective.\n\nSee Julia det function.\n\nSee also: tr1.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nP=randP(5) # generate a random real positive definite matrix 5x5\nQ=det1(P)\ndet(Q) # must be 1\n# using a tolerance\nQ=det1(P; tol=1e-12)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.tr1","page":"linearAlgebra.jl","title":"PosDefManifold.tr1","text":"tr1(X::AnyMatrix; tol::Real=0.)\n\nReturn the argument matrix X normalized so as to have unit trace.\n\nX can be a real or complex Diagonal, LowerTriangular,  Matrix or Hermitian matrix (see AnyMatrix type).\n\nIf the trace is not greater to tol  (which defalts to zero) a warning is printed and X is returned.\n\nSee: Julia trace function.\n\nSee also: tr, det1.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nP=randP(5) # generate a random real positive definite matrix 5x5\nQ=tr1(P)\ntr(Q)  # must be 1\n# using a tolerance\nQ=tr1(P; tol=1e-12)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.nearestPosDef","page":"linearAlgebra.jl","title":"PosDefManifold.nearestPosDef","text":"nearestPosDef(X::Union{ğ”», ğ•„}; tol::Real=0.)\n\nReturn the nearest symmetric/Hermitian positive semi-definite matrix  of a diagonal or of an arbitary square matrix X according to the  Frobenius norm.  If the eigenvalues of the symmetric part of X are all non-negative,  the result is positive definite and will be flagged as Hermitian,  otherwise it is positive semi-definite and will not be flagged.  The nearest matrix is given by\n\n(Y+H)2\n\nwhere\n\nY=(X+X^H)2\n\nis the symmetric part of X, and H is the symmetric polar factor  of Y. See Higham(1988)ğŸ“ for details and for the way it is computed.\n\nSee also: det1, procrustes.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nX=randn(5, 5) # generate an arbitrary 5x5 matrix\nS=nearestPosDef(X)\n\nP=randP(5) # generate a random real positive definite 5x5 matrix\nS=nearestPosDef(Matrix(P)) # typecasting an Hermitian matrix as a `Matrix`\n# Since P is a positive definite matrix S must be equal to P\nS â‰ˆ P ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.nearestOrthogonal","page":"linearAlgebra.jl","title":"PosDefManifold.nearestOrthogonal","text":"nearestOrthogonal(X::AnyMatrix)\n\nalias: nearestOrth\n\nReturn the nearest orthogonal matrix  of a square Hermitian, LowerTriangular, Diagonal or generic Matrix X  (see AnyMatrix type).  This is given by\n\nUV^T,\n\nwhere\n\ntextrm(SVD)=UÎ›V^T.\n\nIf X is Diagonal, return X.\n\nSee also: nearestPosDef, procrustes.\n\nExamples\n\nusing PosDefManifold\nU=nearestOrth(randn(5, 5))\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.normalizeCol!","page":"linearAlgebra.jl","title":"PosDefManifold.normalizeCol!","text":"(1) normalizeCol!(X::ğ•„{T}, j::Int)\n(2) normalizeCol!(X::ğ•„{T}, j::Int, by::Number)\n(3) normalizeCol!(X::ğ•„{T}, range::UnitRange)\n(4) normalizeCol!(X::ğ•„{T}, range::UnitRange, by::Number)\nfor all above: where T<:RealOrComplex\n\nGiven a Matrix type X comprised of real or complex elements,\n\n(1) normalize the j^th column to unit norm\n(2) divide the elements of the j^th column by number by\n(3) normalize the columns in range to unit norm\n(4) divide the elements of columns in range  by number by.\n\nby is a number of abstract supertype Number.  It should be an integer, real or complex number.  For efficiency, it should be of the same type as the elements of X.\n\nrange is a UnitRange type.\n\nMethods (1) and (3) call the  BLAS.nrm2  routine for computing the norm of concerned columns.  See Threads.\n\nnote: Nota Bene\nJulia does not allow normalizing the columns of Hermitian matrices. If you want to call this function for an Hermitian matrix see typecasting matrices.\n\nSee norm and also randn  for the example below.\n\nSee also: colNorm, colProd.\n\nExamples\n\nusing PosDefManifold\nX=randn(10, 20)\nnormalizeCol!(X, 2)                  # (1) normalize columns 2\nnormalizeCol!(X, 2, 10.0)            # (2) divide columns 2 by 10.0\nnormalizeCol!(X, 2:4)                # (3) normalize columns 2 to 4\nX=randn(ComplexF64, 10, 20)\nnormalizeCol!(X, 3)                  # (1) normalize columns 3\nnormalizeCol!(X, 3:6, (2.0 + 0.5im)) # (4) divide columns 3 to 5 by (2.0 + 0.5im)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#Boolean-functions-of-matrices-1","page":"linearAlgebra.jl","title":"Boolean functions of matrices","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\nispos Check whether a real vector or diagonal matrix are comprised of all positive elements","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"ispos","category":"page"},{"location":"linearAlgebra/#PosDefManifold.ispos","page":"linearAlgebra.jl","title":"PosDefManifold.ispos","text":"    (1) ispos(Î»::Vector{T};\n\t<\n\ttol::Real=0,\n\trev=true,\n\tğŸ””=true,\n\tmsg=\"\">)\n\n    (2) ispos(Î›::ğ”»{T};\n\t< same optional keyword arguments as in (1) > )\n\n\tfor all above: where T<:Real\n\nReturn true if all numbers in (1) real vector Î» or in (2) real Diagonal  matrix Î› are not inferior to tol, otherwise return false. This is used,  for example, in spectral functions to check that all eigenvalues are positive.\n\nnote: Nota Bene\ntol defaults to the square root of Base.eps of the type of Î» (1)  or Î› (2). This corresponds to requiring positivity beyond about half of  the significant digits.\n\nThe following are <optional keyword arguments>:\n\nIf rev=true the (1) elements in Î» or (2) the diagonal elements\n\nin Î› will be chacked in reverse order.  This is done for allowing a very fast check when the elements  are sorted and it is known from where is best to start checking.\n\nIf the result is false:\n\nif =true a bell character will be printed. In most systems this will ring a bell on the computer.\nif string msg is provided, a warning will print msg followed by:\n\n\"at position pos\", where pos is the position where the  first non-positive element has been found.\n\n ## Examples\n using PosDefManifold\n a=[1, 0, 2, 8]\n ispos(a, msg=\"non-positive element found\")\n\n # it will print:\n # â”Œ Warning: non-positive element found at position 2\n # â”” @ [here julie will point to the line of code issuing the warning]\n\n\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#Scalar-functions-of-matrices-1","page":"linearAlgebra.jl","title":"Scalar functions of matrices","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\ncolProd Sum of products of the elements in two columns\nsumOfSqr, ss Sum of squares of all elements or of specified columns\nsumOfSqrDiag, ssd Sum of squares of the diagonal elements\ncolNorm Eucliden norm of a column\nsumOfSqrTril, sst Sum of squares of the lower triangle elements up to a given underdiagonal\ntr Fast trace of the product of two Hermitian matrices\nquadraticForm, qf Fast quadratic form\nfidelity (Quantum) Fidelity of two positive matrices","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"colProd\nsumOfSqr\nsumOfSqrDiag\ncolNorm\nsumOfSqrTril\ntr\nquadraticForm\nfidelity","category":"page"},{"location":"linearAlgebra/#PosDefManifold.colProd","page":"linearAlgebra.jl","title":"PosDefManifold.colProd","text":"(1) colProd(X::Union{ğ•„{T}, â„{T}}, j::Int, l::Int)\n(2) colProd(X::Union{ğ•„{T}, â„{T}}, Y::Union{ğ•„{T}, â„{T}}, j::Int, l::Int)\nfor all above: where T<:RealOrComplex\n\n(1) Given a real or complex Matrix or Hermitian matrix X,  return the dot product of the j^th and l^th columns, defined as,\n\nsum_i=1^r big(x_ij^*x_ilbig)\n\nwhere r is the number of rows of X and ^* denotes complex  conjugate (nothing if the matrix is real).\n\n(2) Given real or complex Matrix or Hermitian matrices X and Y,  return the dot product of the j^th column of X and the l^th column  of Y, defined as,\n\nsum_i=1^r big(x_ij^*y_ilbig)\n\nwhere r is the number of rows of X and of Y and ^* is as above.\n\nnote: Nota Bene\nX and of Y may have a different number of columns, but must have the same number of rows.\n\nArguments j and l must be positive integers in range\n\n(1) j,l in 1:size(X, 2),\n(2) j in 1:size(X, 2), l in 1:size(Y, 2).\n\nSee also: normalizeCol!, colNorm.\n\nExamples\n\nusing PosDefManifold\nX=randn(10, 20)\np=colProd(X, 1, 3)\nY=randn(10, 30)\nq=colProd(X, Y, 2, 25)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.sumOfSqr","page":"linearAlgebra.jl","title":"PosDefManifold.sumOfSqr","text":"(1) sumOfSqr(A::Array)\n(2) sumOfSqr(H::â„{T})\n(3) sumOfSqr(L::ğ•ƒ{T})\n(4) sumOfSqr(D::ğ”»{T})\n(5) sumOfSqr(X::Union{ğ•„{T}, â„{T}}, j::Int)\n(6) sumOfSqr(X::Union{ğ•„{T}, â„{T}}, range::UnitRange)\nfor (1)-(6) above: where T<:RealOrComplex\n\nalias: ss\n\nReturn\n\n(1) the sum of squares of the elements in an array A of any dimensions.\n(2) as in (1), but for an Hermitian matrix H, using only the lower triangular part.\n(3) as in (1), but for a LowerTriangular matrix L.\n(4) as in (1), but for a Diagonal matrix D (sum of squares of diagonal elements).\n(5) the sum of square of the j^th column of a Matrix or Hermitian X.\n(6) the sum of square of the columns of a Matrix or Hermitian X in a given range.\n\nAll methods support real and complex matrices.\n\nOnly method (1) works for arrays of any dimensions.\n\nMethods (1)-(4) return the square of the Frobenius norm.\n\nFor method (5), j is a positive integer in range 1:size(X, 1).\n\nFor method (6), range is a UnitRange type.\n\nSee also: colNorm, sumOfSqrDiag, sumOfSqrTril.\n\nExamples\n\nusing PosDefManifold\nX=randn(10, 20)\nsum2=sumOfSqr(X)        # (1) sum of squares of all elements\nsum2=sumOfSqr(X, 1)     # (2) sum of squares of elements in column 1\nsum2=sumOfSqr(X, 2:4)   # (3) sum of squares of elements in column 2 to 4\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.sumOfSqrDiag","page":"linearAlgebra.jl","title":"PosDefManifold.sumOfSqrDiag","text":"sumOfSqrDiag(X::AnyMatrix)\n\nalias: ssd\n\nSum of squares of the diagonal elements in real or complex Matrix,  Diagonal, Hermitian or LowerTriangular matrix X.  If X is rectangular (which can be only if it is of the Matrix type),  the main diagonal is considered.\n\nSee AnyMatrix type\n\nSee also: sumOfSqr, sumOfSqrTril.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nX=randn(10, 20)\nsumDiag2=sumOfSqrDiag(X) # (1)\nsumDiag2=sumOfSqrDiag(ğ”»(X)) # (2) ğ”»=LinearAlgebra.Diagonal\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.colNorm","page":"linearAlgebra.jl","title":"PosDefManifold.colNorm","text":"colNorm(X::Union{ğ•„{T}, â„{T}}, j::Int) where T<:RealOrComplex\n\nGiven a real or complex Matrix or Hermitian matrix X,  return the Euclidean norm of its j^th column.\n\nThis function calls the  BLAS.nrm2  routine. See Threads.\n\nSee also: normalizeCol!, colProd, sumOfSqr.\n\nExamples\n\nusing PosDefManifold\nX=randn(10, 20)\nnormOfSecondColumn=colNorm(X, 2)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.sumOfSqrTril","page":"linearAlgebra.jl","title":"PosDefManifold.sumOfSqrTril","text":"sumOfSqrTril(X::AnyMatrix, k::Int=0)\n\nalias: sst\n\nGiven a real or complex Matrix, Diagonal, Hermitian or  LowerTriangular matrix X (see AnyMatrix type),  return the sum of squares of the elements  in its lower triangle up to the k^th underdiagonal.\n\nMatrix X may be rectangular.\n\nk must be in range\n\n1-size(X, 1):c-1 for X Matrix, Diagonal or Hermitian,\n1-size(X, 1):0 for X LowerTriangular.\n\nFor X Diagonal the result is\n\n0 if k0,\nthe sum of the squares of the diagonal elements otherwise.\n\nSee julia tril(M, k::Integer) function  for numbering of diagonals.\n\nSee also: sumOfSqr, sumOfSqrDiag.\n\nExamples\n\nusing PosDefManifold\nA=[4. 3.; 2. 5.; 1. 2.]\n#3Ã—2 Array{Float64,2}:\n# 4.0  3.0\n# 2.0  5.0\n# 1.0  2.0\n\ns=sumOfSqrTril(A, -1)\n# 9.0 = 1Â²+2Â²+2Â²\n\ns=sumOfSqrTril(A, 0)\n# 50.0 = 1Â²+2Â²+2Â²+4Â²+5Â²\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#LinearAlgebra.tr","page":"linearAlgebra.jl","title":"LinearAlgebra.tr","text":"(1) tr(P::â„{T}, Q::â„{T})\n(2) tr(P::â„{T}, M::ğ•„{T})\n(3) tr(D::ğ”»{T}, H::Union{â„{T}, ğ•„{T}})\n(4) tr(H::Union{â„{T}, ğ•„{T}}, D::ğ”»{T})\nfor all above: where T<:RealOrComplex\n\nGiven (1) two Hermitian positive definite matrix P and Q,  return the trace of the product PQ.  This is real even if P and Q are complex.\n\nP must always be flagged as Hermitian. See typecasting matrices.\n\nIn (2) Q is a Matrix object,  in which case return\n\na real trace if the product PQ is real or if it has all positive real eigenvalues.\na complex trace if the product PQ is not real and has complex eigenvalues.\n\nMethods (3) and (4) return the trace of the product DH or HD,  where D is a Diagonal matrix and H an Hermitian  or Matrix object. The result is of the same type as the input matrices.\n\nFor all methods all arguments must be of the same type.\n\nMath\n\nLet P and Q be Hermitian matrices, using the properties of the trace  (e.g., the cyclic property and the similarity invariance) you can use this  function to fast compute the trace of several expressions. For example:\n\ntextrmtr(PQ)=textrmtr(P^12QP^12)\n\nand\n\ntextrmtr(PQP)=textrmtr(P^2Q) (see example below).\n\nSee: trace.\n\nSee also: DiagOfProd, tr1.\n\nExamples\n\nusing PosDefManifold\nP=randP(ComplexF64, 5) # generate a random complex positive definite matrix 5x5\nQ=randP(ComplexF64, 5) # generate a random complex positive definite matrix 5x5\ntr(P, Q) â‰ˆ tr(P*Q) ? println(\" â­ \") : println(\" â›” \")\ntr(P, Q) â‰ˆ tr(sqrt(P)*Q*sqrt(P)) ? println(\" â­ \") : println(\" â›” \")\ntr(sqr(P), Q) â‰ˆ tr(P*Q*P) ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.quadraticForm","page":"linearAlgebra.jl","title":"PosDefManifold.quadraticForm","text":"(1) quadraticForm(v::Vector{T}, P::â„{T}) where T<:Real\n(2) quadraticForm(v::Vector{T}, L::ğ•ƒ{T}) where T<:Real\n(3) quadraticForm(v::Vector{T}, X::ğ•„{T}, forceLower::Bool=false) where T<:Real\n(4) quadraticForm(v::Vector{S}, X::Union{ğ•„{S}, â„{S}, ğ•ƒ{S}}) where S<:Complex\n\nalias: qf\n\n(1) Given a real vector v and a real Hermitian matrix P,  compute the quadratic form\n\nv^TPv,\n\nwhere the superscript T denotes transpose.  It uses only the lower triangular part of P.\n\n(2) As in (1), given a real vector v  and a LowerTriangular matrix L.\n\n(3) As in (1), given a real vector v  and a real generic Matrix M, if forceLower=true. If forceLower=false,  the product v^TMv is evaluated instead using the whole matrix M.\n\n(4) Quadratic form v^HPv, where superscript H denotes complex conjugate  and transpose, for a complex vector v and a complex Matrix, LowerTrianglar  or Hermitian matrix.  The whole matrix is used.\n\nMath\n\nFor v and X real and X symmetric, the quadratic form is\n\nsum_i(v_i^2x_ii)+sum_ij(2v_iv_jx_ij).\n\nFor L lower triangular is\n\nsum_i(v_i^2x_ii)+sum_ij(v_iv_jx_ij).\n\nThese formula are used in methods (1), (2) and (3).\n\nExamples\n\nusing PosDefManifold\nP=randP(5) # generate a random real positive definite matrix 5x5\nv=randn(5)\nq1=quadraticForm(v, P) # or q1=qf(v, P)\nq2=v'*P*v\nq1 â‰ˆ q2 ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.fidelity","page":"linearAlgebra.jl","title":"PosDefManifold.fidelity","text":"fidelity(P::â„{T}, Q::â„{T}) where T<:RealOrComplex\n\nGiven two positive definte Hermitian matrices P and Q,  return their fidelity:\n\ntrbig(P^12QP^12big)^12\n\nThis is used in quantum physics and is related to the  Wasserstein metric. See for example Bhatia, Jain and Lim (2019b)ğŸ“.\n\nExamples\n\nusing PosDefManifold\nP=randP(5);\nQ=randP(5);\nf=fidelity(P, Q)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#Diagonal-functions-of-matrices-1","page":"linearAlgebra.jl","title":"Diagonal functions of matrices","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\nfDiag, ğ‘“ğ”» Elemen-wise functions of matrix diagonals\nDiagOfProd, dop Diagonal of the product of two matrices","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"fDiag\nDiagOfProd","category":"page"},{"location":"linearAlgebra/#PosDefManifold.fDiag","page":"linearAlgebra.jl","title":"PosDefManifold.fDiag","text":"fDiag(func::Function, X::AnyMatrix, k::Int=0)\n\nalias: ğ‘“ğ”»\n\nApplies function func element-wise to the elements of the k^th  diagonal of real or complex Diagonal, LowerTriangular, Matrix  or Hermitian matrix X and return a diagonal matrix with these elements.  X must be square in all cases, but for the ğ•„=Matrix type argument,  in which case it may be of dimension râ‹…c, with r â‰  c.\n\nSee julia tril(M, k::Integer) function  for numbering of diagonals.\n\nBt default the main diagonal is considered.\n\nIf X is Diagonal, k is set automatically to zero (main diagonal).\nIf X is LowerTriangular, k cannot be positive.\n\nNote that if X is rectangular the dimension of the result depends  on the size of X and on the chosen diagonal.  For example,\n\nr â‰  c and k=0 (main diagonal), the result will be of dimension min(r,c)â‹…min(r,c),\nX 3â‹…4 and k=-1, the result will be 2â‹…2,\nX 3â‹…4 and k=1, the result will be 3â‹…3, etc.\n\nnote: Nota Bene\nThe function func must support the func. syntax and therefore must be able to apply element-wise to the elements of the chosen diagonal (this includes anonymous functions).\n\nIf the input matrix is complex, the function `func`\nmust be able to support complex arguments.\n\nSee also: DiagOfProd, tr.\n\nExamples\n\nusing PosDefManifold\nP=randP(5) # use P=randP(ComplexF64, 5) for generating an Hermitian matrix\n\n# diagonal matrix with the inverse of the first sub-diagonal of P\nD=fDiag(inv, P, -1)\n\n(Î›, U) = evd(P) # Î› holds the eigenvalues of P, see evd\n\n# diagonal matrix with the log of the eigenvalues\nÎ”=fDiag(log, Î›)\n\n# using an anonymous function for the square of the eigenvalues\nÎ”=fDiag(x->x^2, Î›)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.DiagOfProd","page":"linearAlgebra.jl","title":"PosDefManifold.DiagOfProd","text":"DiagOfProd(P::â„{T}, Q::â„{T}) where T<:RealOrComplex\n\nalias: dop\n\nReturn the Diagonal matrix holding the diagonal of the product PQ  of two Hermitian matrices P and Q. Only the diagoanl part  of the product is computed.\n\nSee also: tr, fDiag.\n\nExamples\n\nusing PosDefManifold, LinearAlgebra\nP, Q=randP(5), randP(5)\nDiagOfProd(P, Q)â‰ˆDiagonal(P*Q) ? println(\"â­ \") : println(\"â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#Unitary-functions-of-matrices-1","page":"linearAlgebra.jl","title":"Unitary functions of matrices","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\nmgs Modified Gram-Schmidt orthogonalization","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"mgs","category":"page"},{"location":"linearAlgebra/#PosDefManifold.mgs","page":"linearAlgebra.jl","title":"PosDefManifold.mgs","text":"mgs(X::ğ•„{T}, numCol::Int=0) where T<:RealOrComplex\n\nModified (stabilized) Gram-Schmidt orthogonalization  of the columns of square or tall matrix X, which can be comprised of real  or complex elements.  The orthogonalized X is returned by the function. X is not changed.\n\nAll columns are orthogonalized by default. If instead argument numCol is provided,  then only the first numCol columns of X are orthogonalized.  In this case only the firt numCol columns will be returned.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nX=randn(10, 10);\nU=mgs(X)        # result is 10â‹…10\nU=mgs(X, 3)     # result is 10â‹…3\nU'*U â‰ˆ I ? println(\" â­ \") : println(\" â›” \")\n# julia undertands also:\nU'U â‰ˆ I ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#Matrix-function-of-matrices-1","page":"linearAlgebra.jl","title":"Matrix function of matrices","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\nfVec General function for multi-threaded computation of means and sums of matrix vectors\ncongruence, cong Compute congruent transformations","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"fVec\ncongruence","category":"page"},{"location":"linearAlgebra/#PosDefManifold.fVec","page":"linearAlgebra.jl","title":"PosDefManifold.fVec","text":"\t(1) fVec(f::Function, ğ::AnyMatrixVector;\n\t<\n\tw::Vector=[],\n\tâœ“w=false,\n\tallocs=[])\n\t>\n\n\t(2) fVec(f::Function, g::Function, ğ::AnyMatrixVector;\n\t< same optional keyword arguments in (1) >)\n\nGiven a 1d array ğ=P_1P_k of k matrices  of the ğ•„Vector type, ğ”»Vector type, ğ•ƒVector type or  â„Vector type and an optional non-negative real weights vector  w=w_1w_k, return expression\n\n(1)hspace6ptf_i=1^k(w_iP_i),\n\nor\n\n(2)hspace6ptf_i=1^k(w_ig(P_i)),\n\nwhere f is either the mean or the sum standard julia functions  and g is whatever matrix function  applying to each matrix P_k, such as exp, log,sqrt`, etc,  and anonymous functions.\n\nThis function is multi-threaded. It works by partitioning the k  operations required by the f function in several groups,  passing each group to a separate thread and combining the result  of the intermediate operations.  This function allows a gain in computational time only when the number of  matrices (1) and/or their size (2) is high. Use mean and sum otherwise.  For the number of threads Julia is instructed to use see Threads.\n\n!!! note \"Nota Bene\"      if k<= the number of threads julia is istructed to use, this  \tfunction will run on a single thread.\n\n Contrarily to Julia `mean` and `sum` function (v 1.1.0) the `fVec` function\n returns a matrix of the same type of the matrices in ``ğ``.\n\n<optional keword argument> allocs allows to pass pre-allocated memory  for holding the intermediate result of each thread.  Argument allocs must be a vector of as many matrices as threads and where  the matrices have the same dimension as the the matrices in ğ  (see the example here below). Using this option is worthwhile only  if the size of the matrices is very high and/or when fVec is to be  called repeatedly on many vector of matrices, where the matrices  have always the same size, so that one allocation works for all calls.\n\nIf <optional keyword argument> âœ“w=true is passed, the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed.  This option is provided to allow calling this function repeatedly without  normalizing the same weights vector each time. By default âœ“w is false.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nPset=randP(4, 1000); # generate 1000 positive definite 4x4 matrices\nmean(Pset) # arithmetic mean calling Julia function\nThreads.nthreads() # check that at least two threads are available\nfVec(mean, Pset) # multi-threaded arithmetic mean\n\ninv(mean(inv, Pset)) # Harmonic mean calling Julia function\ninv(fVec(mean, inv, Pset)) # multi-threaded Harmonic mean\n\nexp(mean(log, Pset)) # log Euclidean mean calling Julia function\nexp(fVec(mean, log, Pset)) # multi-threaded log Euclidean mean\n\n# notice that Julia `exp` function has changed the type of the result\n# to `Symmetric`. To obtain an `Hermitian` output use\nâ„(exp(fVec(mean, log, Pset)))\n\nw=(randn(1000)).^2\nw=w./sum(w)  \t\t# generate normalized random weights\n\n# weighted arithmetic mean calling Julia function\nsum(Pset[i]*w[i] for i=1:length(w))\n# multi-threaded weighted arithmetic mean\nfVec(sum, Pset, w=w)\n\n# weighted harmonic mean calling Julia function\ninv(sum(inv(Pset[i])*w[i] for i=1:length(w)))\n# multi-threaded weighted harmonic mean\ninv(fVec(sum, inv, Pset, w=w))\n\n# pre-allocating memory\nPset=randP(100, 1000); # generate 1000 positive definite 100x100 matrices\nQset=MatrixVector(repeat([Pset[1]], Threads.nthreads()))\nfVec(mean, log, Pset, allocs=Qset)\n\n# How much computing time we save ?\n# (example min time obtained with 4 threads & 4 BLAS threads)\nusing BenchmarkTools\n# standard Julia function\n@benchmark(mean(log, Pset)) \t\t\t\t\t# (5.271 s)\n# fVec\n@benchmark(fVec(mean, log, Pset))\t\t\t\t# (1.540 s)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.congruence","page":"linearAlgebra.jl","title":"PosDefManifold.congruence","text":"(1) congruence(B::AnyMatrix, P::AnyMatrix, matrixType)\n(2) congruence(B::AnyMatrix, ğ::AnyMatrixVector, matrixVectorType)\n(3) congruence(B::AnyMatrix, ğ‘·::AnyMatrixVectorâ‚‚, matrixVectorâ‚‚Type)\n(4) congruence(ğ::AnyMatrixVector, ğ‘·::AnyMatrixVectorâ‚‚, matrixVectorâ‚‚Type)\n\nalias: cong\n\n(1) Return the congruent transformation\n\nBPB^H,\n\nfor B and P any combination of Hermitian, LowerTriangular,  Diagonal or general Matrix type.\n\nThe result is of the matrixType argument, which must be provided and  must be one of these four abstract type (not an instance of them).  See aliases for shortening these type using symbols â„, ğ”», ğ•ƒ and ğ•„.\n\n(2) Return a vector of matrices holding the congruent transformations\n\nBP_kB^H,\n\nfor all k matrices in ğ=P_1P_k, for B and ğ  any combination of matrix type Hermitian, LowerTriangular,  Diagonal or Matrix (B) and vector of matrices type â„Vector, ğ”»Vector,  ğ•ƒVector and ğ•„Vector (ğ). See Array of Matrices types.\n\nThe result is a vector of matrices of the matrixVectorType argument,  which must be provided and must be one of the following abstract types:  â„Vector, ğ”»Vector, ğ•ƒVector or ğ•„Vector  (and not an instance of these types).\n\n(3) Return a vector of vector of matrices holding the  congruent transformations\n\nBP_mkB^H,\n\nfor all m vectors of km vectors of matrices in ğ‘·,  for B and ğ‘· any combination of matrix type Hermitian,  LowerTriangular, Diagonal or Matrix (B) and vector of matrices type  â„Vectorâ‚‚, ğ”»Vectorâ‚‚,  ğ•ƒVectorâ‚‚ and ğ•„Vectorâ‚‚ (ğ‘·). See Array of Matrices types.\n\nThe result is a vector of vector of matrices of the matrixVectorâ‚‚Type  argument, which must be provided and must be one of the following  abstract types: â„Vectorâ‚‚, ğ”»Vectorâ‚‚, ğ•ƒVectorâ‚‚ or ğ•„Vectorâ‚‚  (and not an instance of these types).\n\n(4) Return a vector of vector of matrices holding the  congruent transformations\n\nB_iP_ijB_j^H, for ij1m.\n\nfor ğ holding m matrices and ğ‘· holding m vectors  holding m matrices each.  Note that, differently from method (3), here the vectors of ğ‘·  are all of the same length and this is eaxctly the length of ğ.  ğ and ğ‘· may be any combination of matrix vector type â„Vector,  ğ”»Vector, ğ•ƒVector and ğ•„Vector (ğ) and vector of matrices type  â„Vectorâ‚‚, ğ”»Vectorâ‚‚, ğ•ƒVectorâ‚‚ and ğ•„Vectorâ‚‚ (ğ‘·).  See Array of Matrices types.\n\nNote that this function computes the following algebraic expression:\n\nbeginpmatrix B_1  hspace001cm  0  hspace001cm  ddots  hspace001cm  0  hspace001cm  B_m endpmatrix  beginpmatrix C_11  cdots  C_1m  vdots  ddots  vdots  C_m1  cdots  C_mm endpmatrix  beginpmatrixB_1^T  hspace001cm  0  hspace001cm  ddots  hspace001cm  0  hspace001cm  B_m^Tendpmatrix .\n\nThe result is a vector of vector of matrices of the matrixVectorâ‚‚Type  argument, which must be provided and must be one of the following  abstract types: â„Vectorâ‚‚, ğ”»Vectorâ‚‚, ğ•ƒVectorâ‚‚ or ğ•„Vectorâ‚‚  (and not an instance of these types).\n\nWhen you pass it to this function, make sure to typecast ğ  as an â„Vector, ğ”»Vector, ğ•ƒVector or ğ•„Vector type if it is not  already created as one of these types. See the example here below  and typecasting matrices.\n\nMethod (2), (3) and (4) are multi-threaded. See Threads.\n\nnote: Nota Bene\nTypes â„, ğ”», ğ•ƒ or ğ•„ are actually constructors, thus they may modify the result of the congruence(s). This greatly expand the possibilities of this function , but it is your responsibility to pick the right argument matrixType in (1), matrixVectorType in (2)\n\nand `matrixVectorâ‚‚Type` in (3)-(4).\nFor example, in (1) if ``B`` and ``P`` are `Hermitian`,\ncalling `cong(B, P, ğ”»)` will actually\nreturn the diagonal part of ``B*P*B'`` and calling `cong(B, P, ğ•ƒ)` will\nactually return its lower triangular part. The full congruence can\nbe obtained as an `Hermitian` matrix by `cong(B, P, â„)` and as a generic\nmatrix object by `cong(B, P, ğ•„)`.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\n\n# (1)\nP=randP(3) # generate a 3x3 positive matrix\nM=randn(3, 3)\nC=cong(M, P, â„) # equivalent to C=â„(M*P*M')\n\n# (2)\nPset=randP(4, 100); # generate 100 positive definite 4x4 matrices\nM=randn(4, 4)\nQset=cong(M, Pset, â„Vector) # = [M*Pset_1*M',...,M*Pset_k*M'] as an â„Vector type\n\n# recenter the matrices in Pset to their Fisher mean:\nQset=cong(invsqrt(mean(Fisher, Pset)), Pset, â„Vector)\n\n# as a check, the Fisher mean of Qset is now the identity\nmean(Fisher, Qset)â‰ˆI ? println(\"â­\") : println(\"â›”\")\n\n# (3)\nPset1=randP(4, 10); # generate 10 positive definite 4x4 matrices\nPset2=randP(4, 8);\nPset=â„Vectorâ‚‚([Pset1, Pset2]);\nM=randn(4, 4)\nQset=cong(M, Pset, MatrixVectorâ‚‚)\nQset[1][1]â‰ˆM*Pset[1][1]*M' ? println(\"â­\") : println(\"â›”\")\nQset[1][5]â‰ˆM*Pset[1][5]*M' ? println(\"â­\") : println(\"â›”\")\nQset[2][1]â‰ˆM*Pset[2][1]*M' ? println(\"â­\") : println(\"â›”\")\nQset[2][4]â‰ˆM*Pset[2][4]*M' ? println(\"â­\") : println(\"â›”\")\n\n\n# (4)\nPset1=randP(4, 2); # generate 2 positive definite 4x4 matrices\nPset2=randP(4, 2);\nPset=â„Vectorâ‚‚([Pset1, Pset2]);\nU=ğ•„Vector([randU(4), randU(4)])\nQset=cong(U, Pset, MatrixVectorâ‚‚)\nQset[1][1]â‰ˆU[1]*Pset[1][1]*U[1]' ? println(\"â­\") : println(\"â›”\")\nQset[1][2]â‰ˆU[1]*Pset[1][2]*U[2]' ? println(\"â­\") : println(\"â›”\")\nQset[2][1]â‰ˆU[2]*Pset[2][1]*U[1]' ? println(\"â­\") : println(\"â›”\")\nQset[2][2]â‰ˆU[2]*Pset[2][2]*U[2]' ? println(\"â­\") : println(\"â›”\")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#Spectral-decompositions-of-positive-matrices-1","page":"linearAlgebra.jl","title":"Spectral decompositions of positive matrices","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\nevd Eigenvalue-Eigenvector decomposition of a matrix in UÎ›U=P form\nfrf Full-rank factorization of an Hermitian matrix\ninvfrf Inverse of the full-rank factorization of an Hermitian matrix (whitening)\nspectralFunctions Mother function for creating spectral functions of eigenvalues\npow Power of a positive matrix for any number of exponents in one pass\ninvsqrt Principal square root inverse (whitening) of a positive matrix\nsqr Square of a positive matrix\npowerIterations, powIter Power method for estimating any number of eigenvectors and associated eigenvalues","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"evd\nfrf\ninvfrf\nspectralFunctions\npow\ninvsqrt\nsqr\npowerIterations","category":"page"},{"location":"linearAlgebra/#PosDefManifold.evd","page":"linearAlgebra.jl","title":"PosDefManifold.evd","text":"evd(S::Union{ğ•„{T}, â„{T}}) where T<:RealOrComplex\n\nGiven a positive semi-definite matrix S,  returns a 2-tuple (Î› U), where U is the matrix holding in columns  the eigenvectors and Î› is the matrix holding the eigenvalues on the diagonal.  This is the output of Julia  eigen  function in UÎ›U=S form.\n\nAs for the eigen function, the eigenvalues and associated  eigenvectors are sorted by increasing values of eigenvalues.\n\nS may be real or complex and may be flagged by Julia as Hermitian  (in this case PosDefManifold assumes it is positive definite).\n\nSee typecasting matrices.\n\nSee also: spectralFunctions.\n\nExamples\n\nusing PosDefManifold\nA=randn(3, 3);\nS=A+A';\nÎ›, U=evd(S); # which is equivalent to (Î›, U)=evd(P)\n(U*Î›*U') â‰ˆ S ? println(\" â­ \") : println(\" â›” \")\n# => UÎ›U'=S, UÎ›=SU, Î›U'=U'S\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.frf","page":"linearAlgebra.jl","title":"PosDefManifold.frf","text":"frf(P::â„{T}) where T<:RealOrComplex\n\nFull-rank factorization of Hermitian matrix P. It is given by\n\nF=UD^12,\n\nwhere\n\ntextrmEVD(P)=UDU^H\n\nis the eigenvalue-eigenvector decomposition of P. It verifies\n\nFF^H=P,\n\nthus F^-1 is a whitening matrix.\n\nSee also: invfrf.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nP=randP(3)\nF = frf(P)\nF*F'â‰ˆP ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.invfrf","page":"linearAlgebra.jl","title":"PosDefManifold.invfrf","text":"invfrf(P::â„{T}) where T<:RealOrComplex\n\nInverse of the full-rank factorization of Hermitian matrix P. It is given by\n\nF=D^-12U^H,\n\nwhere\n\ntextrmEVD(P)=UDU^H\n\nis the eigenvalue-eigenvector decomposition of P. It verifies\n\nFPF^H=I,\n\nthus F is a whitening matrix.\n\nSee also: frf.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nP=randP(3)\nF = invfrf(P)\nF*P*F'â‰ˆI ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.spectralFunctions","page":"linearAlgebra.jl","title":"PosDefManifold.spectralFunctions","text":"(1) spectralFunctions(P::â„{T}, func) where T<:RealOrComplex\n(2) spectralFunctions(D::ğ”»{S}, func) where S<:Real\n\n(1) This is the mother function for all spectral functions of eigenvalues implemented  in this library, which are:\n\npow     (power),\nisqrt   (inverse square root).\n\nThe function sqr (square) does not use it, as it can be obtained more  efficiently by simple multiplication.\n\nYou can use this function if you need another spectral function of eigenvalues  besides those and those already implemented in the standard package LinearAlgebra.  In general, you won't call it directly.\n\nfunc is the function that will be applied on the eigenvalues.\n\nP must be flagged as Hermitian. See typecasting matrices.  It must be a positive definite or positive semi-definite matrix,  depending on func.\n\nA special method is provided for real Diagonal matrices (2).\n\nnote: Nota Bene\nThe function func must support the func. syntax and therefore must be able to apply element-wise to the eigenvalues (those include anonymous functions).\n\nMaths\n\nThe definition of spectral functions for a positive definite matrix P  is at it follows:\n\nfbig(Pbig)=Ufbig(Î›big)U^H\n\nwhere U is the matrix holding in columns the eigenvectors of P,  Î› is the matrix holding on diagonal its eigenvalues and f is  a function applying element-wise to the eigenvalues.\n\nSee also: evd.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nn=5\nP=randP(n) # P=randP(ComplexF64, 5) to generate an Hermitian complex matrix\nnoise=0.1;\nQ=spectralFunctions(P, x->x+noise) # add white noise to the eigenvalues\ntr(Q)-tr(P) â‰ˆ noise*n ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.pow","page":"linearAlgebra.jl","title":"PosDefManifold.pow","text":"(1) pow(P::â„{T}, args...) where T<:RealOrComplex\n(2) pow(D::ğ”»{S}, args...) where S<:Real\n\n(1) Given a positive semi-definite Hermitian matrix P, return the power  P^r_1 P^r_2  for any number of exponents r_1 r_2.  It returns a tuple comprising as many elements as arguments passed after P.\n\nP must be flagged as Hermitian. See typecasting matrices.\n\narg1 arg2 are real numbers.\n\nA special method is provided for real Diagonal matrices (2).\n\nSee also: invsqrt.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nP=randP(5);     # use P=randP(ComplexF64, 5) for generating an Hermitian matrix\nQ=pow(P, 0.5);            # =>  QQ=P\nQ, W=pow(P, 0.5, -0.5);\nW*P*W â‰ˆ I ? println(\" â­ \") : println(\" â›” \")\nQ*Q â‰ˆ P ? println(\" â­ \") : println(\" â›” \")\nR, S=pow(P, 0.3, 0.7);\nR*S â‰ˆ P ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.invsqrt","page":"linearAlgebra.jl","title":"PosDefManifold.invsqrt","text":"(1) invsqrt(P{T}::â„) where T<:RealOrComplex\n(2) invsqrt(D{S}::ğ”») where S<:Real\n\nGiven a positive definite Hermitian matrix P,  compute the inverse of the principal  square root P^-12.\n\nP must be flagged as Hermitian. See typecasting matrices.\n\nA special method is provided for real Diagonal matrices (2).\n\nMaths\n\nThe principal square root of a positive definite matrix P is the only  symmetric (if P is real) or Hermitian (if P is complex) square root.  Its inverse P^-12 is also named the whitening or sphering  matrix sinceP^-12PP^-12=I.\n\nSee: typecasting matrices.\n\nSee also: pow.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\nP=randP(ComplexF64, 5);\nQ=invsqrt(P);\nQ*P*Q â‰ˆ I ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.sqr","page":"linearAlgebra.jl","title":"PosDefManifold.sqr","text":"(1) sqr(P::â„{T}) where T<:RealOrComplex\n(2) sqr(X::Union{ğ•„{T}, ğ•ƒ{T}, ğ”»{S}}) where T<:RealOrComplex where S<:Real\n\n(1) Given a positive semi-definite Hermitian matrix P,  compute its square P^2.\n\nP must be flagged as Hermitian. See typecasting matrices.\n\nA method is provided also for generic matrices of the Matrix type,  LowerTriangular matrices and real Diagonal matrices (2). The output  is of the same type as the input.\n\nSee also: pow.\n\nExamples\n\nusing PosDefManifold\nP=randP(5);\nPÂ²=sqr(P);  # =>  PÂ²=PP\nsqrt(PÂ²)â‰ˆ P ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#PosDefManifold.powerIterations","page":"linearAlgebra.jl","title":"PosDefManifold.powerIterations","text":"powerIterations(H::Union{â„{T}, ğ•„{T}}, q::Int;\n<\nevalues=false,\ntol::Real=0,\nmaxiter::Int=300,\nverbose=false>) where T<:RealOrComplex\n\npowerIterations(L::ğ•ƒ{S}, q::Int;\n< same optional keyword arguments in (1)>) where S<:Real\n\nalias: powIter\n\n(1) Compute the q eigenvectors associated to the q largest (real) eigenvalues  of real or complex Hermitian or Matrix H using the  power iterations +  Gram-Schmidt orthogonalization as suggested by Strang.  The eigenvectors are returned with the same type as the elements of H.\n\nH must have real eigenvalues, that is, it must be a symmetric matrix if it is real  or an Hermitian matrix if it is complex.\n\n(2) as in (1), but using only the LowerTriangular view L of a matrix.  This option is available only for real matrices (see below).\n\nThe following are <optional keyword arguments>:\n\n`tol is the tolerance for the convergence of the power method (see below),\n`maxiter is the maximum number of iterations allowed for the power method,\nif `verbose=true, the convergence of all iterations will be printed,\nif evalues=true, return the 4-tuple(Î›, U, iterations, covergence)`,\nif evalues=false return the 3-tuple(U, iterations, covergence)`.\n\nnote: Nota Bene\nDifferently from the evd function, the eigenvectors and eigenvalues are sorted by decreasing order of eigenvalues.If H is Hermitian and real, only its lower triangular part is used for computing the power iterations, like in (2). In this case the BLAS.symm routine is used. Otherwise the BLAS.gemm routine is used. See Threads.tol defaults to 100 times the square root of Base.eps of the type of H. This corresponds to requiring the relative convergence criterion over two successive iterations to vanish for about half the significant digits minus 2.\n\nSee also: mgs.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\n# Generate an Hermitian (complex) matrix\nH=randP(ComplexF64, 10);\n# 3 eigenvectors and eigenvalues\nU, iterations, convergence=powIter(H, 3, verbose=true)\n# all eigenvectors\nÎ›, U, iterations, convergence=powIter(H, size(H, 2), evalues=true, verbose=true);\nU'*U â‰ˆ I && U*Î›*U'â‰ˆH ? println(\" â­ \") : println(\" â›” \")\n\n# passing a `Matrix` object\nÎ›, U, iterations, convergence=powIter(Matrix(H), 3, evalues=true)\n\n# passing a `LowerTriangular` object (must be a real matrix in this case)\nL=ğ•ƒ(randP(10))\nÎ›, U, iterations, convergence=powIter(L, 3, evalues=true)\n\n\n\n\n\n","category":"function"},{"location":"linearAlgebra/#Decompositions-involving-triangular-matrices-1","page":"linearAlgebra.jl","title":"Decompositions involving triangular matrices","text":"","category":"section"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"Function Description\nchoL Lower triangula factor of Cholesky decomposition","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"â‹…","category":"page"},{"location":"linearAlgebra/#","page":"linearAlgebra.jl","title":"linearAlgebra.jl","text":"choL","category":"page"},{"location":"linearAlgebra/#PosDefManifold.choL","page":"linearAlgebra.jl","title":"PosDefManifold.choL","text":"(1) choL(P::â„{T}) where T<:RealOrComplex\n(2) choL(D::ğ”»{S}) where S<:Real\n\n(1) Given a real or complex positive definite Hermitian matrix P,  return the Cholesky lower triangular factor L  such that LL^H=P. To obtain L^H or both L and L^H, use instead  julia function cholesky.\n\nOn output, L is of type LowerTriangular.\n\n(2) For a real Diagonal matrix D, return D^12.\n\nExamples\n\nusing PosDefManifold\nP=randP(5);\nL=choL(P);\nL*L'â‰ˆ P ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#riemannianGeometry.jl-1","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"","category":"section"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"This is the fundamental unit of PosDefManifold. It contains functions for manipulating points in the Riemannian manifold of Symmetric Positive Definite (SPD) or Hermitian Positive Definite (HPD) matrices. In Julia those are Hermitian matrices, see typecasting matrices.","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"The functions are divided in six categories:","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"Category Output\n1. Geodesic equations interpolation, extrapolation, weighted mean of two matrices, ...\n2. Distances length of geodesics\n3. Graphs and Laplacians inter-distance matrices, spectral embedding, eigenmaps, ...\n4. Means mid-points of geodesics, FrÃ©chet means of several points, midrange,...\n5. Tangent Space operations maps from the manifold to the tangent space and viceversa, parallel transport,...\n6. Procrustes problems data matching, transfer learning (domain adaptation), ...","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"â‹…","category":"page"},{"location":"riemannianGeometry/#Geodesic-equations-1","page":"riemannianGeometry.jl","title":"Geodesic equations","text":"","category":"section"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"Function Description\ngeodesic Geodesic equations (weighted mean of two positive definite matrices) for any metric","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"â‹…","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"geodesic","category":"page"},{"location":"riemannianGeometry/#PosDefManifold.geodesic","page":"riemannianGeometry.jl","title":"PosDefManifold.geodesic","text":"(1) geodesic(metric::Metric, P::â„{T}, Q::â„{T}, a::Real) where T<:RealOrComplex\n(2) geodesic(metric::Metric, D::ğ”»{S}, E::ğ”»{S}, a::Real) where S<:Real\n\n(1) Move along the geodesic from point P to point Q  (two positive definite matrices) with arclegth 0=a=1,  using the specified metric, of type Metric::Enumerated type.\n\nFor all metrics,\n\nwith a=0 we stay at P,\nwith a=1 we move up to Q,\nwith a=12 we move to the mid-point of P and Q (mean).\n\nUsing the Fisher metric, argument a can be any real number, for instance:\n\nwith 0a1 we move toward Q (attraction),\nwith a1 we move over and beyond Q (extrapolation),\nwith a0 we move back away from Q (repulsion).\n\nP and Q must be flagged by julia as Hermitian.  See typecasting matrices.\n\nThe Fisher geodesic move is computed by the Cholesky-Schur algorithm  given in Eq. 4.2 by Iannazzo(2016)ğŸ“. If Q=I,  the Fisher geodesic move is simply P^a (no need to call this funtion).\n\nnote: Nota Bene\nFor the logdet zero and Jeffrey metric no closed form expression for the geodesic is available to the best of authors' knowledge, so in this case the geodesic is found as the weighted mean using the mean function. For the Von Neumann not even an expression for the mean is available, so in this case the geodesic is not provided and a warning is printed.\n\n(2) Like in (1), but for two real positive definite diagonal matrices  D and E.\n\nMaths\n\nFor points P, Q and arclength a, letting b=1-a,  the geodesic equations for the supported metrics are:\n\nMetric geodesic equation\nEuclidean bP + aQ\ninvEuclidean big(bP^-1 + aQ^-1big)^-1\nChoEuclidean TT^*, where T=bL_P + aL_Q\nlogEuclidean textexpbig(bhspace2pttextlog(P) + ahspace2pttextlog(Q)big)\nlogCholesky TT^*, where T=S_P+a(S_Q-S_P)+D_Phspace2pttextexpbig(a(textlogD_Q-textlogD_P)big)\nFisher P^12 big(P^-12 Q P^-12big)^a P^12\nlogdet0 uses weighted mean algorithm logdet0Mean\nJeffrey uses weighted mean mean\nVonNeumann N.A.\nWasserstein b^2P+a^2Q +abbig(PQ)^12 +(QP)^12big\n\nlegend: L_X, S_X and D_X    are the Cholesky lower triangle of X, its strictly lower triangular part    and diagonal part, respectively (hence, S_X+D_X=L_X,  L_XL_X^*=X).\n\nSee also: mean.\n\nExamples\n\nusing PosDefManifold\nP=randP(10)\nQ=randP(10)\n# Wasserstein mean\nM=geodesic(Wasserstein, P, Q, 0.5)\n# extrapolate suing the Fisher metric\nE=geodesic(Fisher, P, Q, 2)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#Distances-1","page":"riemannianGeometry.jl","title":"Distances","text":"","category":"section"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"Function Description\ndistanceSqr, distanceÂ² Squared distance between positive definite matrices\ndistance Distance between positive definite matrices","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"â‹…","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"distanceSqr\ndistance","category":"page"},{"location":"riemannianGeometry/#PosDefManifold.distanceSqr","page":"riemannianGeometry.jl","title":"PosDefManifold.distanceSqr","text":"(1) distanceSqr(metric::Metric, P::â„{T}) where T<:RealOrComplex\n(2) distanceSqr(metric::Metric, P::â„{T}, Q::â„{T}) where T<:RealOrComplex\n(3) distanceSqr(metric::Metric, D::ğ”»{S}) where S<:Real\n(4) distanceSqr(metric::Metric, D::ğ”»{S}, E::ğ”»{S}) where S<:Real\n\nalias: distanceÂ²\n\n(1) Return Î´^2(P I), the square of the distance (or divergence) of positive definite  matrix P from the the identity matrix. See distance from the origin.\n\n(2) Return Î´^2(P Q), the square of the distance (or divergence) between two  positive definite matrices P and Q. See distance.\n\nIn both cases the distance function Î´ is induced by the argument metric of type  Metric::Enumerated type.\n\nP in (1) and P, Q in (2) must be flagged by julia as Hermitian.  See typecasting matrices.\n\n(3) and (4) are specialized methods of (1) and (2), respectively,  for real positive definite Diagonal matrices.  See â„Vector type and ğ”»Vector type.\n\nMaths\n\nFor point P the squared distances from the identity  for the supported metrics are:\n\nMetric Squared Distance from the identity\nEuclidean P-I^2\ninvEuclidean P^-1-I^2\nChoEuclidean L_P-I^2\nlogEuclidean textrmlogP^2\nlogCholesky S_P^2+textrmlogD_P^2\nFisher textrmlogP^2\nlogdet0 textrmlogdetfrac12(P+I) - frac12textrmlogdet(P)\nJeffrey frac12textrmtr(P+P^-1)-n\nVonNeumann frac12textrmtr(PtextrmlogP-textrmlogP)\nWasserstein textrmtr(P+I) -2textrmtr(P^12)\n\nFor points P and Q their squared distances for the supported metrics are:\n\nMetric Squared Distance\nEuclidean P-Q^2\ninvEuclidean P^-1-Q^-1^2\nChoEuclidean  L_P - L_Q ^2\nlogEuclidean textrmlogP-textrmlogQ^2\nlogCholesky S_P-S_Q^2+textrmlogD_P-textrmlogD_Q^2\nFisher textrmlog(P^-12QP^-12)^2\nlogdet0 textrmlogdetfrac12(P+Q) - frac12textrmlogdet(PQ)\nJeffrey frac12textrmtr(Q^-1P+P^-1Q)-n\nVonNeumann frac12textrmtr(PtextrmlogP-PtextrmlogQ+QtextrmlogQ-QtextrmlogP)\nWasserstein textrmtr(P+Q) -2textrmtr(P^12QP^12)^12\n\nlegend: L_X, S_X and D_X   are the Cholesky lower triangle of X, its strictly lower triangular part   and diagonal part, respectively (hence, S_X+D_X=L_X,  L_XL_X^*=X).\n\nSee also: distanceSqrMat.\n\nExamples (1)\n\nusing PosDefManifold\nP=randP(10)\nd=distanceSqr(Wasserstein, P)\ne=distanceSqr(Fisher, P)\nmetric=Metric(Int(logdet0)) # or metric=logdet0\ns=string(metric) # check what is the current metric\nf=distanceÂ²(metric, P) #using the alias distanceÂ²\n\nExamples (2)\n\nusing PosDefManifold\nP=randP(10)\nQ=randP(10)\nd=distanceSqr(logEuclidean, P, Q)\ne=distanceÂ²(Jeffrey, P, Q)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.distance","page":"riemannianGeometry.jl","title":"PosDefManifold.distance","text":"(1) distance(metric::Metric, P::â„{T}) where T<:RealOrComplex\n(2) distance(metric::Metric, P::â„{T}, Q::â„{T}) where T<:RealOrComplex\n(3) distance(metric::Metric, D::ğ”»{S}) where S<:Real\n(4) distance(metric::Metric, D::ğ”»{S}, E::ğ”»{S}) where S<:Real\n\n(1) Return Î´(P I), the distance between positive definite matrix P and  the identity matrix.\n\n(2) Return Î´(P Q), the distance between positive definite  matrices P and Q.\n\n(3) and (4) are specialized methods of (1) and (2), respectively,  for real positive definite Diagonal matrices.\n\nThis is the square root of distanceSqr  and is invoked with the same syntax therein.\n\nSee also: distanceMat.\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#Graphs-and-Laplacians-1","page":"riemannianGeometry.jl","title":"Graphs and Laplacians","text":"","category":"section"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"Function Description\ndistanceSqrMat, distanceÂ²Mat Lower triangular matrix of all squared inter-distances\ndistanceMat Lower triangular matrix of all inter-distances\nlaplacian Laplacian of a squared inter-distances matrix\nlaplacianEigenMaps, laplacianEM Eigen maps (eigenvectors) of a Laplacian\nspectralEmbedding, spEmb Spectral Embedding (the above functions run in series)","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"â‹…","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"distanceSqrMat\ndistanceMat\nlaplacian\nlaplacianEigenMaps\nspectralEmbedding","category":"page"},{"location":"riemannianGeometry/#PosDefManifold.distanceSqrMat","page":"riemannianGeometry.jl","title":"PosDefManifold.distanceSqrMat","text":"    (1) distanceSqrMat(metric::Metric, ğ::â„Vector;\n    <â©=true>)\n\n    (2) distanceSqrMat(type::Type{T}, metric::Metric, ğ::â„Vector;\n    <â©=true>) where T<:AbstractFloat\n\nalias: distanceÂ²Mat\n\nGiven a 1d array ğ of k positive definite matrices  P_1P_k of â„Vector type, create the kk real  LowerTriangular matrix comprising elements Î´^2(P_i P_j)textrm for all i=j.\n\nThis is the lower triangular matrix holding all squared inter-distances  (zero on diagonal), using the  specified metric, of type Metric::Enumerated type,  giving rise to distance function Î´. See distanceSqr.\n\nOnly the lower triangular part is computed in order to optimize memory use.\n\nBy default, the result matrix is of type Float32. The type can be changed  to another real type using method (2).\n\n<optional keyword arguments>:\n\nif â©=true (default) the computation of inter-distances is multi-threaded.\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.\n\nSee: distance.\n\nSee also: laplacian, laplacianEigenMaps, spectralEmbedding.\n\nExamples\n\nusing PosDefManifold\n# Generate a set of 8 random 10x10 SPD matrices\nPset=randP(10, 8) # or, using unicode: ğ=randP(10, 8)\n# Compute the squared inter-distance matrix according to the log Euclidean metric.\n# This is much faster as compared to the Fisher metric and in general\n# it is a good approximation.\nÎ”Â²=distanceSqrMat(logEuclidean, Pset)\n\n# return a matrix of type Float64\nÎ”Â²64=distanceSqrMat(Float64, logEuclidean, Pset)\n\n# Get the full matrix of inter-distances\nfullÎ”Â²=Hermitian(Î”Â², :L)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.distanceMat","page":"riemannianGeometry.jl","title":"PosDefManifold.distanceMat","text":"    (1) distanceMat(metric::Metric, ğ::â„Vector;\n    <â©=true>)\n\n    (2) distanceMat(type::Type{T}, metric::Metric, ğ::â„Vector;\n    <â©=true>) where T<:AbstractFloat\n\nGiven a 1d array ğ of k positive definite matrices  P_1P_k of â„Vector type, create the kk real  LowerTriangular matrix comprising elements  Î´(P_i P_j)textrm for all i=j.\n\nThis is the lower triangular matrix holding all inter-distances  (zero on diagonal), using the  specified metric, of type Metric::Enumerated type,  giving rise to distance Î´. See distance.\n\nOnly the lower triangular part is computed in order to optimize memory use.\n\nBy default, the result matrix is of type Float32. The type can be changed  to another real type using method (2).\n\nThe elements of this matrix are the square root of  distanceSqrMat.\n\n<optional keyword arguments>:\n\nif â©=true the computation of inter-distances is multi-threaded.\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.\n\nSee: distance.\n\nExamples\n\nusing PosDefManifold\n# Generate a set of 4 random 10x10 SPD matrices\nPset=randP(10, 4) # or, using unicode: ğ=randP(10, 4)\nÎ”=distanceMat(Fisher, Pset)\n\n# return a matrix of type Float64\nÎ”64=distanceMat(Float64, Fisher, Pset)\n\n# Get the full matrix of inter-distances\nfullÎ”=Hermitian(Î”, :L)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.laplacian","page":"riemannianGeometry.jl","title":"PosDefManifold.laplacian","text":"laplacian(Î”Â²::ğ•ƒ{S}, epsilon::Real=0;\n          <densityInvariant=false>) where S<:Real\n\nGiven a LowerTriangular matrix of squared inter-distances Î”^2,  return the lower triangular part of the so-called  normalized Laplacian or density-invariant normalized Laplacian,  which in both cases is a symmetric Laplacian.  The elements of the Laplacian are of the same type as the elements of Î”^2.  The result is a LowerTriangular matrix.\n\nThe definition of Laplacian given by Lafon (2004)ğŸ“ is implemented:\n\nFirst, a Gaussian radial basis functions,  known as Gaussian kernel or heat kernel,  is applied to all elements of Î”^2, such as\n\nW_ij = expbigg(fracdisplaystyle-Î”^2_ijdisplaystyle2Îµbigg),\n\nwhere Îµ is the bandwidth of the kernel.\n\nIf <optional keyword argument> densityInvariant=true is used,   then the density-invariant transformation is applied\n\nW - E^-1WE^-1\n\nwhere E is the diagonal matrix holding on the main diagonal   the sum of the rows (or columns) of W.\n\nFinally, the normalized Laplacian (density-invariant or not) is defined as\n\nÎ© = D^-12WD^-12,\n\nwhere D is the diagonal matrix holding on the main diagonal   the sum of the rows (or columns) of W.\n\nIf you do not provide argument epsilon, the bandwidth Îµ is set to the   median of the elements of squared distance matrix Î”^2_ij.   Another educated guess is the dimension of the original data, that is,   the data that has been used to compute the squared distance matrix.   For positive definite matrices this is n(n-1)2, where n is the   dimension of the matrices. Still another is the dimension of the ensuing   spectralEmbedding space.   Keep in mind that by tuning the epsilon parameter   (which must be positive) you can control both the rate of compression of the   embedding space and the spread of points in the embedding space.   See Coifman et al. (2008)ğŸ“ for a discussion on Îµ.\n\nnote: Nota Bene\nThe Laplacian as here defined can be requested for any input matrix of squared inter-distances, for example, those obtained on scalars or on vectors using appropriate metrics. In any case, only the lower triangular part of the Laplacian is taken as input. See typecasting matrices.\n\nSee also: distanceSqrMat, laplacianEigenMaps, spectralEmbedding.\n\nExamples\n\nusing PosDefManifold\n# Generate a set of 4 random 10x10 SPD matrices\nPset=randP(10, 4) # or, using unicode: ğ=randP(10, 4)\nÎ”Â²=distanceSqrMat(Fisher, Pset)\nÎ©=laplacian(Î”Â²)\n\n# density-invariant Laplacian\nÎ©=laplacian(Î”Â²; densityInvariant=true)\n\n# increase the bandwidth\nr=size(Î”Â², 1)\nmyÎµFactor=0.1\nmed=Statistics.median([Î”Â²[i, j] for j=1:r-1 for i=j+1:r])\nÎµ=2*myÎµFactor*med\nÎ©=laplacian(Î”Â², Îµ; densityInvariant=true)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.laplacianEigenMaps","page":"riemannianGeometry.jl","title":"PosDefManifold.laplacianEigenMaps","text":"    laplacianEigenMaps(Î©::ğ•ƒ{S}, q::Int;\n    <\n    tol::Real=0.,\n    maxiter::Int=300,\n    verbose=false >) where S<:Real\n\nalias: laplacianEM\n\nGiven the lower triangular part of a Laplacian Î©  (see laplacian ) return the eigen maps in q dimensions,  i.e., the q eigenvectors of the Laplacian associated with the largest q  eigenvalues, excluding the first (which is always equal to 1.0).  The eigenvectors are of the same type as Î©. They are all divided  element-wise by the first eigenvector (see Lafon, 2004ğŸ“).\n\nThe eigenvectors of the Laplacian are computed by the  power iterations+modified Gram-Schmidt method (see powerIterations),  allowing the execution of this function for Laplacian matrices of very large size.\n\nReturn the 4-tuple (Î› U iterations convergence), where:\n\nÎ› is a qq diagonal matrix holding on diagonal the eigenvalues corresponding to the q dimensions of the Laplacian eigen maps,\nU holds in columns the q eigenvectors holding the q coordinates of the points in the embedding space,\niterations is the number of iterations executed by the power method,\nconvergence is the convergence attained by the power method.\n\nUsing the notion of Laplacian, spectral embedding seek a  low-dimension representation of the data emphasizing local neighbothood  information while neglecting long-distance information.  The embedding is non-linear, however the embedding space is Euclidean.  The eigenvectors of U holds the coordinates of the points in the  embedding space (typically two- or three-dimensional for plotting or more  for clustering). Spectral embedding is done for plotting data in low-dimension,  clustering, imaging, classification, following their trajectories over time  or other dimensions, and much more.  For examples of applications see Ridrigues et al. (2018) ğŸ“  and references therein.\n\nArguments:\n\nÎ© is a real LowerTriangular normalized Laplacian obtained by the laplacian function,\nq is the dimension of the Laplacian eigen maps;\nThe following are <optional keyword arguments> for the power iterations:\ntol is the tolerance for convergence (see below),\nmaxiter is the maximum number of iterations allowed,\nif verbose is true, the convergence at all iterations will be printed.\n\nnote: Nota Bene\nThe maximum value of q that can be requested is n-1, where n is the size of the Laplacian. In general, q=2 or q=3 is requested.tol defaults to the square root of Base.eps of the (real) type of Î©. This corresponds to requiring equality for the convergence criterion over two successive power iterations of about half of the significant digits.\n\nSee also: distanceSqrMat, laplacian, spectralEmbedding.\n\nExamples\n\nusing PosDefManifold\n# Generate a set of 4 random 10x10 SPD matrices\nPset=randP(10, 4)\nÎ”Â²=distanceSqrMat(Fisher, Pset)\nÎ©=laplacian(Î”Â²)\nevalues, maps, iterations, convergence=laplacianEM(Î©, 2)\nevalues, maps, iterations, convergence=laplacianEM(Î©, 2; verbose=true)\nevalues, maps, iterations, convergence=laplacianEM(Î©, 2; verbose=true, maxiter=500)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.spectralEmbedding","page":"riemannianGeometry.jl","title":"PosDefManifold.spectralEmbedding","text":"    (1) spectralEmbedding(metric::Metric, ğ::â„Vector, q::Int, epsilon::Real=0;\n    <\n    tol::Real=0.,\n    maxiter::Int=300,\n    densityInvariant=false,\n    verbose=false,\n    â©=true >)\n\n    (2) spectralEmbedding(type::Type{T}, metric::Metric, ğ::â„Vector, q::Int, epsilon::Real=0;\n    < same optional keyword arguments as in (1) >) where T<:Real\n\nalias: spEmb\n\nGiven a 1d array ğ of k positive definite matrices P_1P_k  (real or complex), compute its eigen maps in q dimensions.\n\nThis function runs one after the other the functions:\n\ndistanceSqrMat (compute the squared inter-distance matrix),\nlaplacian (compute the normalized Laplacian),\nlaplacianEigenMaps (get the eigen maps).\n\nBy default all computations above are done with Float32 precision.  Another real type can be requested using method (2), where the type argument  is defined.\n\nReturn the 4-tuple (Î›, U, iterations, convergence), where:\n\nÎ› is a qq diagonal matrix holding on diagonal the eigenvalues corresponding to the q dimensions of the Laplacian eigen maps,\nU holds in columns the q eigenvectors holding the q coordinates of the points in the embedding space,\niterations is the number of iterations executed by the power method,\nconvergence is the convergence attained by the power method.\n\nArguments:\n\nmetric is the metric of type Metric::Enumerated type used for computing the inter-distances,\nğ is a 1d array of k positive matrices of â„Vector type,\nq is the dimension of the Laplacian eigen maps,\nepsilon is the bandwidth of the Laplacian (see laplacian);\nThe following <optional keyword argument> applyies for computing the inter-distances:\nif â©=true (default) the computation of inter-distances is multi-threaded.\nThe following <optional keyword argument> applyies to the computation of the Laplacian by the laplacian function:\nif densityInvariant=true the density-invariant Laplacian is computed (see laplacian).\nThe following are <optional keyword arguments> for the power method iterative algorithm invoked by laplacianEigenMaps:\ntol is the tolerance for convergence of the power method (see below),\nmaxiter is the maximum number of iterations allowed for the power method,\nif verbose=true the convergence at all iterations will be printed;\n\nnote: Nota Bene\ntol defaults to the square root of Base.eps of the Float32 type (1) or of the type passed as argumant (2). This corresponds to requiring equality for the convergence criterion over two successive power iterations of about half of the significant digits.Multi-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.\n\nSee also: distanceSqrMat, laplacian, laplacianEigenMaps.\n\nExamples\n\nusing PosDefManifold\n# Generate a set of k random 10x10 SPD matrices\nk=10\nPset=randP(10, k)\nevalues, maps, iter, conv=spectralEmbedding(Fisher, Pset, 2)\n\n# show convergence information\nevalues, maps, iter, conv=spectralEmbedding(Fisher, Pset, 2; verbose=true)\n\n# use Float64 precision.\nevalues, maps, iter, conv=spectralEmbedding(Float64, Fisher, Pset, 2)\n\nusing Plots\n# check eigevalues and eigenvectors\nplot(diag(evalues))\nplot(maps[:, 1])\nplot!(maps[:, 2])\nplot!(maps[:, 3])\n\n# plot the data in the embedded space\nplot(maps[:, 1], maps[:, 2], seriestype=:scatter, title=\"Spectral Embedding\", label=\"Pset\")\n\n# try a different value of epsilon\nevalues, maps, iter, conv=spEmb(Fisher, Pset, k-1, 0.01; maxiter=1000)\nplot(maps[:, 1], maps[:, 2], seriestype=:scatter, title=\"Spectral Embedding\", label=\"Pset\")\n# see the example in `Laplacian` function for more on this\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#Means-1","page":"riemannianGeometry.jl","title":"Means","text":"","category":"section"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"Function Description\nmean Weighted FrÃ©chet mean (wFm) of a scalar or matrix set using any metric\nmeans As above for several sets at once\ngeneralizedMean Generalized wFm of a matrix set\ngeometricMean, gMean wFm of a matrix set minimizing the dispersion according to the Fisher metric (iterative)\ngeometricpMean, gpMean robust wFm of a matrix set minimizing the p-dispersion according to the Fisher metric (iterative)\nlogdet0Mean, ld0Mean wFm of a matrix set according to the logdet0 metric (iterative)\nwasMean wFm of a matrix set according to the Wasserstein metric (iterative)\npowerMean Power wFm of a matrix set (iterative)\ninductiveMean, indMean Recursive FrÃ©chet mean of a matrix set (constructive)\nmidrange Geometric midrange of two matrices","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"â‹…","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"mean\nmeans\ngeneralizedMean\ngeometricMean\ngeometricpMean\nlogdet0Mean\nwasMean\npowerMean\ninductiveMean\nmidrange","category":"page"},{"location":"riemannianGeometry/#Statistics.mean","page":"riemannianGeometry.jl","title":"Statistics.mean","text":"    (1) mean(metric::Metric, P::â„{T}, Q::â„{T}) where T<:RealOrComplex\n\n    (2) mean(metric::Metric, D::ğ”»{T}, E::ğ”»{T}) where T<:Real\n\n    (3) mean(metric::Metric, ğ::â„Vector;\n        <\n        w::Vector=[],\n        âœ“w=true,\n        init::Union{â„, Nothing}=nothing,\n        tol::Real=0.,\n        verbose=false,\n        â©=true >)\n\n    (4) mean(metric::Metric, ğƒ::ğ”»Vector;\n    < same optional keyword arguments as in (3) >)\n\n(1) Mean of two positive definite matrices, passed in arbitrary order as  arguments P and Q, using the specified metric of type  Metric::Enumerated type. The order is arbitrary as all metrics  implemented in PosDefManifold are symmetric.  This is the midpoint of the geodesic.  For the weighted mean of two positive definite matrices use instead  the geodesic function.  P and Q must be flagged as Hermitian. See typecasting matrices.\n\n(2) Like in (1), but for two real diagonal positive definite matrices  D and E.\n\n(3) FrÃ©chet mean of an 1d array ğ of k positive definite  matrices ğ=P_1P_k of â„Vector type,  with optional non-negative real weights w=w_1w_k and using the  specified metricas in (1).\n\n(4) FrÃ©chet mean of an 1d array ğƒ of k positive definite  matrices ğƒ=D_1D_k of ğ”»Vector type,  with optional non-negative real weights w=w_1w_k and using the  specified metricas in (1).\n\nIf you don't pass a weight vector with <optional keyword argument> w,  return the unweighted mean.\n\nIf <optional keyword argument> âœ“w=true (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.\n\nAdopting the Fisher, logdet0 and Wasserstein metric in (3) and the  logdet0 metric in (4), the mean is computed by means of an iterative  algorithm. A particular initialization for these algorithms can be  provided passing an Hermitian matrix as <optional keyword argument> init.  The convergence for these algorithm is required with a tolerance  given by <optional keyword argument> tol.  if verbose=true the covergence attained at each iteration is printed.  Other information such as if the algorithm has diverged is also printed.  For more options in computing these means call directly  functions geometricMean, logdet0Mean  and wasMean, which are called hereby.  For the meaning of the tol default value see the documentation of  these functions. See also the robust mean function geometricpMean,  which cannot be called from here. Notice that arguments init and tol  have an effect only for the aferomentioned metrics in methods (3) and (4).\n\nFor (3) and (4), if â©=true (default),  the computation of the mean is multi-threaded for all metrics.\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.\n\nMath\n\nThe FrÃ©chet mean of a set of k matrices P_1 P_2 P_k weighted by  w_1 w_2 w_ksum_i=1^kw_i=1 for the supported metrics are,  for those with closed form expression:\n\nMetric weighted FrÃ©chet mean\nEuclidean sum_i=1^kw_i P_i\ninvEuclidean big(sum_i=1^kw_i P_i^-1big)^-1\nChoEuclidean TT^*, where T=bL_P + aL_Q\nlogEuclidean textrmexpbig(sum_i=1^kw_ihspace1pt textrmlogP_i big)\nlogCholesky TT^*, where T=sum_i=1^k(w_kS_k)+sum_i=1^k(w_ktextrmlogD_k)\nJeffrey A^12big(A^-12HA^-12big)^12A^12\n\nand for those that are found by an iterative algorithm and that verify an equation:\n\nMetric equation verified by the weighted FrÃ©chet mean\nFisher sum_i=1^kw_itextrmlogbig(G^-12 P_k G^-12big)=0\nlogdet0 sum_i=1^kw_ibig(frac12P_i+frac12Gbig)^-1=G^-1\nVonNeumann N.A.\nWasserstein G=sum_i=1^kw_ibig( G^12  P_i G^12big)^12\n\nlegend: L_X, S_X and D_X   are the Cholesky lower triangle of X, its strictly lower triangular part   and diagonal part, respectively (hence, S_X+D_X=L_X,  L_XL_X^*=X).   A and H are the weighted arithmetic and weighted harmonic mean, respectively.\n\nSee: geodesic, mean, FrÃ©chet mean.\n\nExamples\n\nusing LinearAlgebra, Statistics, PosDefManifold\n# Generate 2 random 3x3 SPD matrices\nP=randP(3)\nQ=randP(3)\nM=mean(logdet0, P, Q) # (1)\nM=mean(Euclidean, P, Q) # (1)\n\n# passing several matrices and associated weights listing them\n# weights vector, does not need to be normalized\nR=randP(3)\nmean(Fisher, â„Vector([P, Q, R]); w=[1, 2, 3])\n\n# Generate a set of 4 random 3x3 SPD matrices\nPset=randP(3, 4)\nweights=[1, 2, 3, 1]\n# passing a vector of Hermitian matrices (â„Vector type)\nM=mean(Euclidean, Pset; w=weights) # (2) weighted Euclidean mean\nM=mean(Wasserstein, Pset)  # (2) unweighted Wassertein mean\n# display convergence information when using an iterative algorithm\nM=mean(Fisher, Pset; verbose=true)\n\n# run multi-threaded when the number of matrices is high\nusing BenchmarkTools\nPset=randP(20, 160)\n@benchmark(mean(logEuclidean, Pset; â©=false)) # single-threaded\n@benchmark(mean(logEuclidean, Pset)) # multi-threaded\n\n\n\n\n\nmean(metric::Metric, Î½::Vector{T}) where T<:RealOrComplex\n\nMean of k real or complex scalars, using the specified metric  of type Metric::Enumerated type. Note that using the Fisher,  logEuclidean and Jeffrey metric, the resulting mean  is the scalar geometric mean. Note also that the code of this method  is in unit statistics.jl, while the code for all the others is  in unit riemannianGeometry.jl.\n\nExamples\n\nusing PosDefManifold\n# Generate 10 random numbers distributed as a chi-square with 2 df.\nÎ½=[randÏ‡Â²(2) for i=1:10]\narithmetic_mean=mean(Euclidean, Î½)\ngeometric_mean=mean(Fisher, Î½)\nharmonic_mean=mean(invEuclidean, Î½)\nharmonic_mean<=geometric_mean<=arithmetic_mean # AGH inequality\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.means","page":"riemannianGeometry.jl","title":"PosDefManifold.means","text":"    (1) means(metric::Metric, ğ’«::â„Vectorâ‚‚;\n    <â©=true>)\n\n    (2) means(metric::Metric, ğ’Ÿ::ğ”»Vectorâ‚‚;\n    <â©=true>)\n\n(1) Given a 2d array ğ’« of positive definite matrices as an â„Vectorâ‚‚ type  compute the FrÃ©chet mean for as many â„Vector type objects  as hold in ğ’«, using the specified metric of type  Metric::Enumerated type.  Return the means in a vector of Hermitian matrices, that is, as an â„Vector type.\n\n(2) Given a 2d array ğ’Ÿ of real positive definite matrices as an ğ”»Vectorâ‚‚ type  compute the FrÃ©chet mean for as many ğ”»Vector type objects  as hold in ğ’Ÿ, using the specified metric of type  Metric::Enumerated type.  Return the means in a vector of Diagonal matrices, that is, as a ğ”»Vector type.\n\nThe weigted FrÃ©chet mean is not supported in this function.\n\nIf â©=true (default) the computation of the means  is multi-threaded.\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.\n\nSee also: mean.\n\nExamples\n\n using PosDefManifold\n # Generate a set of 4 random 3x3 SPD matrices\n Pset=randP(3, 4) # or, using unicode: ğ=randP(3, 4)\n # Generate a set of 40 random 4x4 SPD matrices\n Qset=randP(3, 40) # or, using unicode: ğ=randP(3, 40)\n # listing directly â„Vector objects\n means(logEuclidean, â„Vectorâ‚‚([Pset, Qset])) # or: means(logEuclidean, â„Vectorâ‚‚([ğ, ğ]))\n # note that [ğ, ğ] is actually a â„Vectorâ‚‚ type object\n\n # creating and passing an object of â„Vectorâ‚‚ type\n sets=â„Vectorâ‚‚(undef, 2) # or: ğ’«=â„Vectorâ‚‚(undef, 2)\n sets[1]=Pset # or: ğ’«[1]=ğ\n sets[2]=Qset # or: ğ’«[2]=ğ\n means(logEuclidean, sets) # or: means(logEuclidean, ğ’«)\n\n # going multi-threated\n\n # first, create 20 sets of 200 50x50 SPD matrices\n sets=â„Vectorâ‚‚([randP(50, 200) for i=1:20])\n\n # How much computing time we save ?\n # (example min time obtained with 4 threads & 4 BLAS threads)\n using BenchmarkTools\n\n # non multi-threaded, mean with closed-form solution\n @benchmark(means(logEuclidean, sets; â©=false)) # (6.196 s)\n\n # multi-threaded, mean with closed-form solution\n @benchmark(means(logEuclidean, sets)) # (1.897 s)\n\n sets=â„Vectorâ‚‚([randP(10, 200) for i=1:10])\n\n # non multi-threaded, mean with iterative solution\n # wait a bit\n @benchmark(means(Fisher, sets; â©=false)) # (4.672 s )\n\n # multi-threaded, mean with iterative solution\n @benchmark(means(Fisher, sets)) # (1.510 s)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.generalizedMean","page":"riemannianGeometry.jl","title":"PosDefManifold.generalizedMean","text":"    generalizedMean(ğ::Union{â„Vector, ğ”»Vector}, p::Real;\n    <\n    w::Vector=[],\n    âœ“w=true,\n    â©=true >)\n\nGiven a 1d array ğ=P_1P_k of k positive definite matrices of  â„Vector type or real positive definite diagonal matrices of  ğ”»Vector type and optional non-negative real weights vector  w=w_1w_k, return the weighted generalized means G  with real parameter p, that is,\n\nG=big(sum_i=1^kw_iP_i^pbig)^1p.\n\nIf you don't pass a weight vector with <optional keyword argument> w,  return the unweighted generalized mean\n\nG=big(sum_i=1^kP_i^pbig)^1p.\n\nIf <optional keyword argument> âœ“w=true (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the weights each time.\n\nIf <optional key argmuent> â©=true the computation of the generalized mean  is multi-threaded.\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.\n\nThe following special cases for parameter p are noteworthy:\n\nFor p=frac12 the generalized mean is the modified Bhattacharyya mean.\nFor p=1 the generalized mean is the Euclidean mean.\nFor p=-1 the generalized mean is the inverse Euclidean mean.\nFor (the limit of) p=0 the generalized mean is the log Euclidean mean, which is the Fisher mean when matrices in ğ all pair-wise commute.\n\nNotice that when matrices in ğ all pair-wise commute, for instance if the  matrices are diagonal,  the generalized means coincide with the power means  for any p-1 1 and for p=05 it coincides also with the  Wasserstein mean. For this reason the generalized means are used  as default initialization of both the powerMean and wasMean  algorithm.\n\nSee: generalized means.\n\nSee also: powerMean, wasMean, mean.\n\nExamples\n\nusing LinearAlgebra, Statistics, PosDefManifold\n# Generate a set of 4 random 3x3 SPD matrices\nPset=randP(3, 4) # or, using unicode: ğ=randP(3, 4)\n\n# weights vector, does not need to be normalized\nweights=[1, 2, 3, 1]\n\n# unweighted mean\nG = generalizedMean(Pset, 0.25) # or: G = generalizedMean(ğ, 0.25)\n\n# weighted mean\nG = generalizedMean(Pset, 0.5; w=weights)\n\n# with weights previously normalized we can set âœ“w=false\nweights=weights./sum(weights)\nG = generalizedMean(Pset, 0.5; w=weights, âœ“w=false)\n\n# run multi-threaded when the number of matrices is high\nusing BenchmarkTools\nPset=randP(20, 160)\n@benchmark(generalizedMean(Pset; â©=false)) # single-threaded\n@benchmark(generalizedMean(Pset)) # multi-threaded\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.geometricMean","page":"riemannianGeometry.jl","title":"PosDefManifold.geometricMean","text":"    geometricMean(ğ::Union{â„Vector, ğ”»Vector};\n    <\n    w::Vector=[],\n    âœ“w=true,\n    init=nothing,\n    tol::Real=0.,\n    maxiter::Int=500,\n    adaptStepSize::Bool=true,\n    verbose=false,\n    â©=true >)\n\nalias: gmean\n\nGiven a 1d array ğ=P_1P_k of k positive definite matrices of â„Vector type or diagonal matrices of ğ”»Vector type and optional non-negative real weights vector w=w_1w_k, return the 3-tuple (G iter conv), where G is the mean according to the Fisher metric and iter, conv are the number of iterations and convergence attained by the algorithm. Mean G is the unique positive definite matrix satisfying\n\nsum_i=1^kw_itextrmlogbig(G^-12 P_i G^-12big)=0\n\nFor estimating it, this function implements the well-known gradient descent algorithm, but with an exponential decaying step size Ï‚, yielding iterations\n\nG G^12textrmexpbig(Ï‚sum_i=1^kw_itextrmlog(G^-12 P_i G^-12)big)G^12\n\nIf you don't pass a weight vector with <optional keyword argument> w, return the unweighted geometric mean.\n\nIf <optional keyword argument> âœ“w=true (default), the weights are normalized so as to sum up to 1, otherwise they are used as they are passed and should be already normalized.  This option is provided to allow calling this function repeatedly without normalizing the same weights vector each time.\n\nThe following are more <optional keyword arguments>:\n\ninit is a matrix to be used as initialization for the mean. If no matrix is provided, the log Euclidean mean will be used,\ntol is the tolerance for the convergence (see below).\nmaxiter is the maximum number of iterations allowed\nif verbose=true, the convergence attained at each iteration and the step size Ï‚ is printed. Also, a warning is printed if convergence is not attained.\nif â©=true the iterations are multi-threaded (see below).\nif adaptStepSize=false the step size Ï‚ is fixed to 1 at all iterations.\n\nIf the input is a 1d array of k real positive definite diagonal matrices the solution is available in closed-form as the log Euclidean mean, hence the <optional keyword arguments> init, tol and verbose have no effect and return the 3-tuple (G 1 0). See the log Euclidean metric.\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.In normal circumstances this algorithm converges monothonically. If the algorithm diverges and verbose is true a warning is printed indicating the iteration when this happened.The exponential decaying step size features a faster convergence rate as compared to the fixed step size Ï‚=1 that is usually adopted. The decaying rate is inversely proportional to maxiter, thus, increase/decrease maxiter in order to set a slower/faster decaying rate. maxiter should not be set too low though.tol defaults to the square root of Base.eps of the nearest real type of data input ğ. This corresponds to requiring the norm of the satisfying matrix equation divided by the number of elements to vanish for about half the significant digits.\n\nSee: Fisher metric.\n\nSee also: geometricpMean, powerMean,  wasMean, logdet0Mean, mean.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\n# Generate a set of 4 random 3x3 SPD matrices\nPset=randP(3, 4) # or, using unicode: ğ=randP(3, 4)\n\n# unweighted mean\nG, iter, conv = geometricMean(Pset) # or G, iter, conv = geometricMean(ğ)\n\n# weights vector, does not need to be normalized\nweights=[1, 2, 3, 1]\n\n# weighted mean\nG, iter, conv = geometricMean(Pset, w=weights)\n\n# print the convergence at all iterations\nG, iter, conv = geometricMean(Pset; verbose=true)\n\n# now suppose Pset has changed a bit, initialize with G to hasten convergence\nPset[1]=â„(Pset[1]+(randP(3)/100))\nG, iter, conv = geometricMean(Pset; w=weights, âœ“w=true, verbose=true, init=G)\n\n# run multi-threaded when the number of matrices is high\nusing BenchmarkTools\nPset=randP(20, 120)\n@benchmark(geometricMean(Pset; â©=false)) # single-threaded\n@benchmark(geometricMean(Pset)) # multi-threaded\n\n# show the mean and the input points using spectral embedding\nusing Plots\nk=80\nPset=randP(20, k)\nG, iter, conv = geometricMean(Pset)\npush!(Pset, G)\nÎ›, U, iter, conv=spectralEmbedding(Fisher, Pset, 2; verbose=true)\nplot(U[1:k, 1], U[1:k, 2], seriestype=:scatter, title=\"Spectral Embedding\", label=\"Pset\")\nplot!(U[k+1:k+1, 1], U[k+1:k+1, 2], seriestype=:scatter, label=\"mean\")\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.geometricpMean","page":"riemannianGeometry.jl","title":"PosDefManifold.geometricpMean","text":"    geometricpMean(ğ::â„Vector, p::Real=0.5;\n    <\n    w::Vector=[],\n    âœ“w=true,\n    init=nothing,\n    tol::Real=0.,\n    maxiter::Int=500,\n    adaptStepSize=true,\n    verbose=false,\n    â©=true >)\n\nalias: gpmean\n\nGiven a 1d array ğ=P_1P_k of k positive definite matrices of  â„Vector type, a real parameter 0p=1 and optional non-negative real  weights vector w=w_1w_k, return the 3-tuple (G iter conv),  where G is the p-mean, i.e., the mean according to the  Fisher metric minimizing the p-dispersion (see below) and  iter, conv are the number of  iterations and convergence attained by the algorithm.\n\nThis function implements the p-dispersion gradient descent  algorithm with step-size Ï‚ (to be published), yielding iterations\n\nG G^12textrmexpbig(Ï‚sum_i=1^kpÎ´^2(G P_i)^p-1w_itextrmlog(G^-12 P_i G^-12)big)G^12\n\nif p=1 this yields the geometric mean (implemented specifically in geometricMean).\nif p=05 this yields the geometric median (default).\n\nIf you don't pass a weight vector with <optional keyword argument> w,  return the unweighted geometric-p mean.\n\nIf <optional keyword argument> âœ“w=true (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.\n\nThe following are more <optional keyword arguments>:\n\ninit is a matrix to be used as initialization for the mean. If no matrix is provided, the log Euclidean mean will be used,\ntol is the tolerance for the convergence (see below).\nmaxiter is the maximum number of iterations allowed.\nif adaptStepSize=true (default) the step size Ï‚ for the gradient descent is adapted at each iteration (see below).\nif verbose=true, the step-size and convergence attained at each iteration is printed. Also, a warning is printed if convergence is not attained.\nif â©=true the iterations are multi-threaded (see below).\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.If the algorithm diverges and verbose is true a warning is printed indicating the iteration when this happened. This algorithm may temporary diverge, still reach convergence. Overall, while all other iterative algorithms implemented in PosDefMaifold are very stable, this is not.The smaller the parameter p is, the slower and less likely the convergence is. If the algorithm does not converge, try increasing p, initializing the algorithm with the output of geometricMean and/or eliminating the otliers from the input set ğ.If adaptStepSize is true (default) the step-size Ï‚ is adapted at each iteration, otherwise a fixed step size Ï‚=1 is used. Adapting the step size in general hastens convergence and improves the convergence behavior.tol defaults to the square root of Base.eps of the nearest real type of data input ğ. This corresponds to requiring the norm of the satisfying matrix equation divided by the number of elements to vanish for about half the significant digits.\n\nSee: Fisher metric.\n\nSee also: geometricMean, powerMean,  wasMean, logdet0Mean, mean.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold, Plots\n\n# This examples show that this algorithm is more robust to outliers\n# as compared to the standard geometric mean algorithm\n\n# Generate a set of 100 random 10x10 SPD matrices\nPset=randP(10, 100)\n\n# Get the usual geometric mean for comparison\nG, iter1, conv1 = geometricMean(Pset, verbose=true)\n\n# change p to observe how the convergence behavior changes accordingly\n# Get the median (default)\nH, iter2, conv2 = geometricpMean(Pset, verbose=true)\n# Get the p-mean for p=0.25\nH, iter2, conv2 = geometricpMean(Pset, 0.25, verbose=true)\n\nprintln(iter1, \" \", iter2); println(conv1, \" \", conv2)\n\n# move the first matrix in Pset to possibly create an otlier\nPset[1]=geodesic(Fisher, G, Pset[1], 3)\nG1, iter1, conv1 = geometricMean(Pset, verbose=true)\nH1, iter2, conv2 = geometricpMean(Pset, 0.25, verbose=true)\nprintln(iter1, \" \", iter2); println(conv1, \" \", conv2)\n\n# collect the geometric and p-means, before and after the\n# introduction of the outier in vector of Hermitian matrices `S`.\nS=HermitianVector([G, G1, H, H1])\n\n# check the interdistance matrix Î”Â² to verify that the geometric mean\n# after the introduction of the outlier (``G1``) is farther away from\n# the geometric mean as compared to how much ``H1`` is further away\n# from ``H``, i.e., that element (4,3) is much smaller than element (2,1).\nÎ”Â²=distanceÂ²Mat(Float64, Fisher, S)\n\n# how far are all these matrices from all the others?\nfullÎ”Â²=Hermitian(Î”Â², :L)\ndist=[sum(fullÎ”Â²[:, i]) for i=1:size(fullÎ”Â², 1)]\n\n# plot the matrices in `S` using spectral embedding.\nusing Plots\nÎ›, U, iter, conv = laplacianEM(laplacian(Î”Â²), 3;  verbose=true)\nplot([U[1, 1]], [U[1, 2]], seriestype=:scatter, label=\"g-mean\")\nplot!([U[2, 1]], [U[2, 2]], seriestype=:scatter, label=\"g-mean outlier\")\nplot!([U[3, 1]], [U[3, 2]], seriestype=:scatter, label=\"p-mean\")\nplot!([U[4, 1]], [U[4, 2]], seriestype=:scatter, label=\"p-mean outlier\")\n\n# estimate how much you gain running the algorithm in multi-threaded mode\nusing BenchmarkTools\nPset=randP(20, 120)\n@benchmark(geometricpMean(Pset; â©=true)) # single-threaded\n@benchmark(geometricpMean(Pset)) # multi-threaded\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.logdet0Mean","page":"riemannianGeometry.jl","title":"PosDefManifold.logdet0Mean","text":"    logdet0Mean(ğ::Union{â„Vector, ğ”»Vector};\n    <\n    w::Vector=[],\n    âœ“w=true,\n    init=nothing,\n    tol::Real=0.,\n    maxiter::Int=500,\n    verbose=false,\n    â©=true >)\n\nalias: ld0Mean\n\nGiven a 1d array ğ=P_1P_k of k positive definite matrices of  â„Vector type or real positive definite diagonal matrices of  ğ”»Vector type and optional  non-negative real weights vector w=w_1w_k,  return the 3-tuple (G iter conv), where G is the mean according  to the logdet zero metric and iter, conv are the number of iterations  and convergence attained by the algorithm.  Mean G is the unique positive definite matrix satisfying\n\nsum_i=1^kw_ibig(frac12P_i+frac12Gbig)^-1-G^-1=0.\n\nFor estimating it, this function implements the fixed-point iteration algorithm  suggested by (Moakher, 2012, p315)ğŸ“, yielding iterations\n\nG  frac12big(sum_i=1^kw_i(P_i+G)^-1big)^-1.\n\nIf you don't pass a weight vector with <optional keyword argument> w,  return the unweighted logdet zero mean.\n\nIf <optional keyword argument> âœ“w=true (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.\n\nThe following are more <optional keyword arguments>:\n\ninit is a matrix to be used as initialization for the mean. If no matrix is provided, the log Euclidean mean will be used,\ntol is the tolerance for the convergence (see below).\nmaxiter is the maximum number of iterations allowed.\nif verbose=true, the convergence attained at each iteration is printed and a warning is printed if convergence is not attained.\nif â©=true the iterations are multi-threaded (see below).\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.In normal circumstances this algorithm converges monothonically. If the algorithm diverges and verbose is true a warning is printed indicating the iteration when this happened.tol defaults to 100 times the square root of Base.eps of the nearest real type of data input ğ. This corresponds to requiring the square root of the relative convergence criterion over two successive iterations to vanish for about half the significant digits minus 2.\n\nSee: logdet zero metric, modified Bhattacharyya mean.\n\nSee also: powerMean, wasMean, logdet0Mean,  mean.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\n# Generate a set of 4 random 3x3 SPD matrices\nPset=randP(3, 4) # or, using unicode: ğ=randP(3, 4)\n\n# unweighted mean\nG, iter, conv = logdet0Mean(Pset) # or G, iter, conv = logdet0Mean(ğ)\n\n# weights vector, does not need to be normalized\nweights=[1, 2, 3, 1]\n\n# weighted mean\nG, iter, conv = logdet0Mean(Pset, w=weights)\n\n# print the convergence at all iterations\nG, iter, conv = logdet0Mean(Pset; w=weights, verbose=true)\n\n# suppose Pset has changed a bit; initialize with G to hasten convergence\nPset[1]=â„(Pset[1]+(randP(3)/100))\nG, iter, conv = logdet0Mean(Pset; w=weights, âœ“w=false, verbose=true, init=G)\n\n# estimate how much you gain running the algorithm in multi-threaded mode\nusing BenchmarkTools\nPset=randP(20, 120)\n@benchmark(logdet0Mean(Pset; â©=false)) # single-threaded\n@benchmark(logdet0Mean(Pset)) # multi-threaded\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.wasMean","page":"riemannianGeometry.jl","title":"PosDefManifold.wasMean","text":"    wasMean(ğ::Union{â„Vector, ğ”»Vector};\n    <\n    w::Vector=[],\n    âœ“w=true,\n    init=nothing,\n    tol::Real=0.,\n    maxiter::Int=500,\n    verbose=false,\n    â©=true >)\n\nGiven a 1d array ğ=P_1P_k of k positive definite matrices  of â„Vector type or real positive definite diagonal matrices of  ğ”»Vector type and optional non-negative real weights vector  w=w_1w_k,  return the 3-tuple (G iter conv), where G is the mean according  to the Wasserstein metric and iter, conv are the number of iterations  and convergence attained by the algorithm.  Mean G is the unique positive definite matrix satisfying\n\nG=sum_i=1^kw_ibig( G^12  P_i G^12big)^12.\n\nFor estimating it, this function implements the fixed-point iterative algorithm  proposed by (Ãlvarez-Esteban et al., 2016)ğŸ“:\n\nG  G^-12big(sum_i=1^k w_i(G^12P_i G^12)^12big)^2 G^-12.\n\nIf you don't pass a weight vector with <optional keyword argument> w,  return the unweighted Wassertein mean.\n\nIf <optional keyword argument> âœ“w=true (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and they should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.\n\nThe following are more <optional keyword arguments>:\n\ninit is a matrix to be used as initialization for the mean. If no matrix is provided, the instance of generalized means with p=05 will be used,\ntol is the tolerance for the convergence (see below).\nmaxiter is the maximum number of iterations allowed.\nif verbose=true, the convergence attained at each iteration is printed and a warning is printed if convergence is not attained.\nif â©=true the iterations are multi-threaded (see below).\n\nIf the input is a 1d array of k real positive definite diagonal matrices  the solution is available in closed-form as the modified Bhattacharyya mean,  hence the <optional keyword arguments> init, tol and verbose  have no effect and return the 3-tuple (G 1 0).  See modified Bhattacharyya mean.\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.In normal circumstances this algorithm converges monothonically. If the algorithm diverges and verbose is true a warning is printed indicating the iteration when this happened.tol defaults to the square root of Base.eps of the nearest real type of data input ğ. This corresponds to requiring the norm of the satisfying matrix equation divided by the number of elements to vanish for about half the significant digits.\n\nSee: Wasserstein metric.\n\nSee also: powerMean, wasMean, logdet0Mean,  mean.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\n# Generate a set of 4 random 3x3 SPD matrices\nPset=randP(3, 4) # or, using unicode: ğ=randP(3, 4)\n\n# unweighted mean\nG, iter, conv = wasMean(Pset) # or: G, iter, conv = wasMean(ğ)\n\n# weights vector, does not need to be normalized\nweights=[1, 2, 3, 1]\n\n# weighted mean\nG, iter, conv = wasMean(Pset; w=weights)\n\n# print the convergence at all iterations\nG, iter, conv = wasMean(Pset; w=weights, verbose=true)\n\n# suppose ğ has changed a bit; initialize with G to hasten convergence\nPset[1]=â„(Pset[1]+(randP(3)/100))\nG, iter, conv = wasMean(Pset; w=weights, verbose=true, init=G)\n\n# estimate how much you gain running the algorithm in multi-threaded mode\nusing BenchmarkTools\nPset=randP(20, 120)\n@benchmark(wasMean(Pset; â©=false)) # single-threaded\n@benchmark(wasMean(Pset)) # multi-threaded\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.powerMean","page":"riemannianGeometry.jl","title":"PosDefManifold.powerMean","text":"    powerMean(ğ::Union{â„Vector, ğ”»Vector}, p::Real;\n    <\n    w::Vector=[],\n    âœ“w=true,\n    init=nothing,\n    tol::Real=0.,\n    maxiter::Int=500,\n    verbose=false,\n    â©=true >)\n\nGiven a 1d array ğ=P_1P_k of k positive definite matrices  of â„Vector type or real positive definite diagonal matrices of  ğ”»Vector type, an optional non-negative real weights vector  w=w_1w_k and a real parameter p in-1 1, return the  3-tuple (G iter conv), where G is  Lim and Palfia (2012)'s power means  of order p and  iter, conv are the number of iterations  and convergence attained by the algorithm, respectively.  Mean G is the unique positive definite matrix satisfying\n\nG=sum_i=1^k(w_iGtextrm_pP_i),\n\nwhere Gtextrm_pP_i is the Fisher geodesic equation.  In particular:\n\nwith p=-1 this is the harmonic mean (see the inverse Euclidean metric),\nwith p=+1 this is the arithmetic mean (see the Euclidean metric),\nat the limit of p evaluated at zero from both side this is the geometric mean (see Fisher metric).\n\nFor estimating power means for pin(-1 1), this function implements  the  fixed-point iterative algorithm of (Congedo et al., 2017b)ğŸ“.  For p=0 (geometric mean)  this algorithm is run two times with a small positive and negative value  of p and the geometric mean of the two  resulting means is returned, as suggested in (Congedo et al., 2017b)ğŸ“.  This way of estimating the geometric mean of  a set of matrices is faster as compared to the usual gradient descent algorithm.\n\nIf you don't pass a weight vector with <optional keyword argument> w,  return the unweighted power mean.\n\nIf <optional keyword argument> âœ“w=true (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.\n\nThe following are more <optional keyword arguments>:\n\ninit is a matrix to be used as initialization for the mean. If no matrix is provided, the instance of generalized means with parameter p will be used.\ntol is the tolerance for the convergence (see below).\nmaxiter is the maximum number of iterations allowed.\nif verbose=true, the convergence attained at each iteration is printed and a warning is printed if convergence is not attained.\nif â©=true the iterations are multi-threaded.\n\nIf the input is a 1d array of k real positive definite diagonal matrices  the solution is available in closed-form as the generalized  mean of order p, hence the <optional keyword arguments>  init, tol and verbose  have no effect and return the 3-tuple (G 1 0).  See generalized means.\n\nnote: Nota Bene\nMulti-threading is automatically disabled if Julia is instructed to use only one thread. See Threads.In normal circumstances this algorithm converges monothonically. If the algorithm diverges and verbose is true a warning is printed indicating the iteration when this happened.tol defaults to the square root of Base.eps of the nearest real type of data input ğ. This corresponds to requiring the norm of the difference of the matrix solution over two successive iterations divided by the number of elements in the matrix to vanish for about half the significant digits.\n\n(2) Like in (1), but for a 1d array ğƒ=D_1D_k of k  real positive definite diagonal matrices of ğ”»Vector type.  In this case the solution is available in closed-form, hence the  <optional keyword arguments> init, tol and verbose have no effect and return  the 3-tuple (G 1 0). See generalized means.\n\nSee: power means, generalized means, modified Bhattacharyya mean.\n\nSee also: generalizedMean, wasMean, logdet0Mean,  mean.\n\nExamples\n\nusing LinearAlgebra, PosDefManifold\n# Generate a set of 4 random 3x3 SPD matrices\nPset=randP(3, 4) # or, using unicode: ğ=randP(3, 4)\n\n# unweighted mean\nG, iter, conv = powerMean(Pset, 0.5) # or G, iter, conv = powerMean(ğ, 0.5)\n\n# weights vector, does not need to be normalized\nweights=[1, 2, 3, 1]\n\n# weighted mean\nG, iter, conv = powerMean(Pset, 0.5; w=weights)\n\n# print the convergence at all iterations\nG, iter, conv = powerMean(Pset, 0.5; w=weights, verbose=true)\n\n# suppose ğ has changed a bit; initialize with G to hasten convergence\nPset[1]=â„(Pset[1]+(randP(3)/100))\nG, iter, conv = powerMean(Pset, 0.5; w=weights, verbose=true, init=G)\n\n# estimate how much you gain running the algorithm in multi-threaded mode\nusing BenchmarkTools\nPset=randP(20, 120)\n@benchmark(powerMean(Pset, 0.5; â©=false)) # single-threaded\n@benchmark(powerMean(Pset, 0.5)) # multi-threaded\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.inductiveMean","page":"riemannianGeometry.jl","title":"PosDefManifold.inductiveMean","text":"(1) inductiveMean(metric::Metric, ğ::â„Vector)\n\n(2) inductiveMean(metric::Metric, ğ::â„Vector, q::Int, Q::â„)\n\nalias: indMean\n\n(1) Compute the FrÃ©chet mean of 1d array ğ=P_1P_k of k  positive definite matrices of â„Vector type with a law of large  number inductive procedure (Ho et al., 2013; Massart et al., 2018),  such as ğŸ“\n\nG_1=P_1\n\nG_i=Î³(i^-1 G_(i-1) P_i) i=2k\n\nwhere Î³(i^-1 G_(i-1) P_i) is a step on the geodesic relying  G_(i-1) to P_i with arclength i^-1  using the specified metric, of type Metric::Enumerated type.\n\n(2) Like (1), but for the set of matrices ğ  ğ,  where it is assumed knowledge only of the set ğ,  the mean of ğ (Hermitian matrix argument Q) and the number of  matrices in ğ (integer argument q).  This method can be used, for example, for updating a block on-line algorithm,  where ğ is the incoming block, Q the previous mean estimation  and q the cumulative number of matrices on which the mean has been  computed on-line.\n\nFor FrÃ©chet means that do not have a closed form expression,  this procedure features a computational complexity amounting to less than  two iterations of gradient descent or fixed-point algorithms. This comes at  the price of an approximation.  In fact, the solution is not invariant to permutations of the matrices  in array ğ and convergence to the FrÃ©chet mean with the  implemented procedure is not ensured  (see Massart et al., 2018)ğŸ“.\n\nSince the inductive mean uses the geodesic function,  it is not available for the Von Neumann metric.\n\nExamples\n\n# A set of 100 matrices for which we want to compute the mean\nğ=randP(10, 100)\n\nğ1=â„Vector(collect(ğ[i] for i=1:50)) # first 50\nğ2=â„Vector(collect(ğ[i] for i=51:100)) # last 50\n\n# inductive mean of the whole set ğ\nG=inductiveMean(Fisher, ğ)\n\n# mean using the usual gradient descent algorithm\nH, iter, conv=geometricMean(ğ)\n\n# inductive mean of ğ given only ğ2,\n# the number of matrices in ğ1 and the mean of ğ1\nG2=inductiveMean(Fisher, ğ2, length(ğ1), mean(Fisher, ğ1))\n\n# average error\nnorm(G-H)/(dim(G, 1)^2)\nnorm(G2-H)/(dim(G, 1)^2)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.midrange","page":"riemannianGeometry.jl","title":"PosDefManifold.midrange","text":"midrange(metric::Metric, P::â„{T}, Q::â„{T}) where T<:RealOrComplex\n\nMidrange (average of extremal values) of positive definite matrices  P and Q. Only the Fisher metric is supported, allowing the so-called  geometric midrange. This has been defined in Mostajeran et al. (2019)  ğŸ“ as\n\nP * Q = frac1sqrtlambda_(min)+sqrtlambda_(max)Big(Q+sqrtlambda_(min)*lambda_(max)PBig),\n\nwhere lambda_(min) and lambda_(max) are the extremal generalized  eigenvalues of P and Q.\n\nExamples\n\nP=randP(3)\nQ=randP(3)\nM=midrange(Fisher, P, Q)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#Tangent-Space-operations-1","page":"riemannianGeometry.jl","title":"Tangent Space operations","text":"","category":"section"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"Function Description\nlogMap Logarithmic map (from manifold to tangent space)\nexpMap Exponential map (from tangent space to manifold)\nvecP vectorization of matrices in the tangent space\nmatP matrization of matrices in the tangent space (inverse of vecp)\nparallelTransport, pt Parallel transport of tangent vectors and matrices","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"â‹…","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"logMap\nexpMap\nvecP\nmatP\nparallelTransport","category":"page"},{"location":"riemannianGeometry/#PosDefManifold.logMap","page":"riemannianGeometry.jl","title":"PosDefManifold.logMap","text":"(1) logMap(metric::Metric, P::â„{T}, G::â„{T})\n\n(2) logMap(metric::Metric, ğ::â„Vector, G::â„{T})\nfor all the above: where T<:RealOrComplex\n\n(1) Logaritmic Map: map a positive definite matrix P from the SPD or  Hermitian manifold into the tangent space at base-point G  using the Fisher metric.\n\nP and G must be flagged as Hermitian.  See typecasting matrices.\n\nThe map is defined as\n\nLog_G(P)=S=G^12textrmlogbig(G^-12PG^-12big)G^12.\n\nmetric is a metric of type Metric::Enumerated type.\n\nThe result is an Hermitian matrix.\n\n(2) Logarithmic map (1) at base-point G at once for k positive definite  matrices in 1d array ğ=P_1P_k of â„Vector type.\n\nThe result is an â„Vector.\n\nnote: Nota Bene\nCurrently only the Fisher metric is supported for tangent space operations.\n\nThe inverse operation is expMap.\n\nSee also: vecP, parallelTransport.\n\nExamples\n\nusing PosDefManifold\n(1)\nP=randP(3)\nQ=randP(3)\nmetric=Fisher\nG=mean(metric, P, Q)\n# projecting P at the base point given by the geometric mean of P and Q\nS=logMap(metric, P, G)\n\n(2)\nPset=randP(3, 4)\n# projecting all matrices in Pset at the base point given by their geometric mean.\nSset=logMap(Fisher, Pset, mean(Fisher, Pset))\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.expMap","page":"riemannianGeometry.jl","title":"PosDefManifold.expMap","text":"(1) expMap(metric::Metric, S::â„{T}, G::â„{T})\n\n(2) expMap(metric::Metric, ğ’::â„Vector, G::â„{T})\nfor all the above: where T<:RealOrComplex\n\n(1) Exponential Map: map a tangent vector (a matrix) S from the tangent  space at base-point G into the SPD or Hermitian manifold  (using the Fisher metric).\n\nS and G must be flagged as Hermitian.  See typecasting matrices.\n\nThe map is defined as\n\nExp_G(S)=P=G^12textrmexpbig(G^-12SG^-12big)G^12.\n\nmetric is a metric of type Metric::Enumerated type.\n\nThe result is an Hermitian matrix.\n\n(2) Exponential map (1) at base-point G at once for k tangent vectors  (matrices) in 1d array ğ’=S_1S_k of â„Vector type.\n\nThe result is an â„Vector.\n\nnote: Nota Bene\nCurrently only the Fisher metric is supported for tangent space operations.\n\nThe inverse operation is logMap.\n\nExamples\n\n(1)\nusing PosDefManifold, LinearAlgebra\nP=randP(3)\nQ=randP(3)\nG=mean(Fisher, P, Q)\n# projecting P on the tangent space at the Fisher mean base point G\nS=logMap(Fisher, P, G)\n# projecting back onto the manifold\nP2=expMap(Fisher, S, G)\n\n(2)\nPset=randP(3, 4)\n# projecting all matrices in Pset at the base point given by their geometric mean.\nG=mean(Fisher, Pset)\nSset=logMap(Fisher, Pset, G)\n# projecting back onto the manifold\nPset2=expMap(Fisher, Sset, G)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.vecP","page":"riemannianGeometry.jl","title":"PosDefManifold.vecP","text":"vecP(S::Union{â„{T}, Symmetric{R}};\n     range::UnitRange=1:size(S, 2)) where T<:RealOrComplex where R<:Real =\n\nVectorize a tangent vector (which is an Hermitian or Symmetric matrix)  S:  mat â†¦ vec.\n\nIt gives weight 1 to diagonal elements and 2 to off-diagonal elements  so as to preserve the norm (Barachant et al., 201E)ğŸ“, such as\n\nS_F=vecP(S)_F.\n\nThe result is a vector holding n(n+1)2 elements, where n  is the size of S.\n\nS must be flagged as Hermitian or Symmetric.  See typecasting matrices.\n\nThe reverse operation is provided by matP,  which always return an Hermitian matrix.\n\nIf an optional keyword argument range is provided,  the vectorization concerns only the rows (or columns,  since the input matrix is symmetric or Hermitian)  in the range. Note that in this case the operation  cannot be reverted by the matP, that is,  in this case the matrix is 'stuck' in the tangent space.\n\nExamples\n\nusing PosDefManifold\nP=randP(3)\nQ=randP(3)\nG=mean(Fisher, P, Q)\n# projecting P at the base point given by the geometric mean of P and Q\nS=logMap(Fisher, P, G)\n# vectorize S\nv=vecP(S)\n# vectorize onlt the first two columns of S\nv=vecP(S; range=1:2)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.matP","page":"riemannianGeometry.jl","title":"PosDefManifold.matP","text":"matP(Ï‚::Vector{T}) where T<:RealOrComplex\n\nMatrizize a tangent vector (vector) Ï‚ :  vec -> mat.\n\nThis is the function reversing the vecP function,  thus the weighting applied therein is reversed as well.\n\nIf Ï‚=vecP(S) and S is a nn Hermitian or Symmetric matrix,  Ï‚  is a tangent vector of size n(n+1)2.  The result of calling matP(Ï‚) is then nn matrix S.  S is always returned flagged as Hermitian.\n\nTo Do: This function may be rewritten more efficiently.\n\nExamples\n\nusing PosDefManifold\nP=randP(3)\nQ=randP(3)\nG=mean(Fishr, P, Q)\n# projecting P at onto the tangent space at the Fisher mean base point\nS=logMap(Fisher, P, G)\n# vectorize S\nv=vecP(S)\n# Rotate the vector by an orthogonal matrix\nn=Int(size(S, 1)*(size(S, 1)+1)/2)\nU=randP(n)\nz=U*v\n# Get the point in the tangent space\nS=matP(z)\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#PosDefManifold.parallelTransport","page":"riemannianGeometry.jl","title":"PosDefManifold.parallelTransport","text":"(1) parallelTransport(S::â„{T}, P::â„{T}, Q::â„{T})\n\n(2) parallelTransport(S::â„{T}, P::â„{T})\n\n(3) parallelTransport(ğ’::â„Vector, P::â„{T}, Q::â„{T})\n\n(4) parallelTransport(ğ’::â„Vector, P::â„{T})\nfor all the above: where T<:RealOrComplex\n\nalias: pt\n\n(1) Parallel transport of tangent vector S (a matrix) lying on  the tangent space at base-point P to the tangent space at base-point Q.\n\nS, P and Q must all be Hermitian matrices.  Return an Hermitian matrix.  The transport is defined as:\n\n_(PQ)(S)=big(QP^-1big)^12Sbig(QP^-1big)^H2.\n\nIf S is a positive definite matrix in the manifold (and not a tangent vector)  it will be 'trasported' from P to Q, amounting to (Yair et al., 2019ğŸ“)\n\nproject S onto the tangent space at base-point P,\nparallel transport it to the tangent space at base-point Q,\nproject it back onto the manifold at base-point Q.\n\n(2) Parallel transport as in (1), but to the tangent space at base-point the identity matrix.\n\nThe transport reduces in this case to:\n\n_(PI)(S)=P^-12SP^-12.\n\n(3) Parallel transport as in (1) at once for k tangent vectors (matrices) in 1d array ğ’=S_1S_k of â„Vector type.\n\n(4) Parallel transport as in (2) at once for k tangent vectors (matrices) in 1d array ğ’=S_1S_k of â„Vector type.\n\nnote: Nota Bene\nCurrently only the Fisher metric is supported for parallel transport.\n\nSee also: logMap, expMap, vecP, matP.\n\nExamples\n\nusing PosDefManifold\n\n(1)\nP=randP(3)\nQ=randP(3)\nG=mean(Fisher, P, Q)\n\n# i. projecting P onto the tangent space at base-point G\nS=logMap(Fisher, P, G)\n# ii. parallel transport S to the tangent space at base-point Q\nS_=parallelTransport(S, G, Q)\n# iii. projecting back into the manifold at base-point Q\nP_=expMap(Fisher, S_, Q)\n\n# i., ii. and iii. can be done simply by\nPP_=parallelTransport(P, G, Q)\n# check\nP_â‰ˆPP_ ? println(\" â­ \") : println(\" â›” \")\n\n(2)\nP=randP(3)\nQ=randP(3)\nG=mean(Fisher, P, Q)\n# transport to the tangent space at base-point the identity\nPP_=parallelTransport(P, G)\n\n(3)\nPset=randP(3, 4)\nQ=randP(3)\nG=mean(Fisher, Pset)\n# trasport at once all matrices in Pset\nPset2=parallelTransport(Pset, G, Q)\n\n(4)\nPset=randP(3, 4)\nG=mean(Fisher, Pset)\n# recenter all matrices so to have mean=I\nPset2=parallelTransport(Pset, G)\n# check\nmean(Fisher, Pset2) â‰ˆ I ? println(\" â­ \") : println(\" â›” \")\n\n\n\n\n\n","category":"function"},{"location":"riemannianGeometry/#Procrustes-problems-1","page":"riemannianGeometry.jl","title":"Procrustes problems","text":"","category":"section"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"Function Description\nprocrustes Solution to the Procrustes problem in the manifold of positive definite matrices","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"â‹…","category":"page"},{"location":"riemannianGeometry/#","page":"riemannianGeometry.jl","title":"riemannianGeometry.jl","text":"procrustes","category":"page"},{"location":"riemannianGeometry/#PosDefManifold.procrustes","page":"riemannianGeometry.jl","title":"PosDefManifold.procrustes","text":"procrustes(P::â„{T}, Q::â„{T}, extremum=\"min\") where T<:RealOrComplex\n\nGiven two positive definite matrices P and Q,  return by default the solution of problem\n\ntextrmargmin_UÎ´(PU^HQU),\n\nwhere U varies over the set of unitary matrices and Î´() is a  distance or divergence function.\n\nU^HQU is named in physics the unitary orbit of Q.\n\nIf the argument extremum is passed as \"max\", it returns instead the solution of\n\ntextrmargmax_UÎ´(PU^HQU).\n\nP and Q must be flagged as Hermitian. See typecasting matrices.\n\nAs it has been shown in Bhatia and Congedo (2019)ğŸ“,  using each of the Fisher, logdet zero, Wasserstein  and the Kullback-Leibler divergence (see logdet Î±),  the best approximant to P from the unitary orbit of Q  commutes with P and, surprisingly, has the same closed-form expression, namely\n\nU_Q^U_P^H for the argmin and U_Q^U_P^H for the argmax,\n\nwhere U^ denotes the eigenvector matrix of the subscript argument with  eigenvectors in columns sorted by decreasing order of corresponding eigenvalues and  U^ denotes the eigenvector matrix of the subscript argument with  eigenvectors in columns sorted by increasing order of corresponding eigenvalues.\n\nThe same solutions are known since a long time also by solving the extremal  problem here above using the Euclidean metric (Umeyama, 1988).\n\nThe generalized Procrustes problem\n\ntextrmargmin_Usum_i=1^kÎ´(P_iU^HQ_iU)\n\ncan be solved using Julia package Manopt.\n\nExamples\n\nusing PosDefManifold\nP=randP(3)\nQ=randP(3)\n# argmin problem\nU=procrustes(P, Q)\n# argmax problem\nV=procrustes(P, Q, \"max\")\n\n\n\n\n\n","category":"function"},{"location":"test/#test.jl-1","page":"test.jl","title":"test.jl","text":"","category":"section"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Most functions in PosDefManifold are tested, both for real and complex data input. This unit declares the function testall() that performs all tests.","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Some functions are fully tested, the others are just executed. Unce you ran it, for each method of each function, a â­ sign is printed if the test is succesful, while a â›” sign is printed if the test is not succesful. A â˜† sign is printed if the function has been executed correctly.","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Tests on functions for which a multi-threated version exist are indicated by symbol ( â© ).","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"If there are fails, the concerned functions will be listed as warnings.","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Note that the first time you execute the test it will take some time as the code will be compiled.","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"This here below is the output of the testall() function (v0.1.3) run on the 20th of May 2019:","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"â­ PosDefManifold testing utilityâ­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Starting tests...","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Unit 'linearAlgebra.jl'","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"typeofMatrix:           â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"dim:                    â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"det1:                   â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"function tr1:           â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"normalizeCol!:          â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"ispos:                  â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"colProd:                â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"colNorm:                â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"sumOfSqr:               â­ â­ â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"sumOfSqrDiag:           â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"sumOfSqrTril:           â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"tr:                     â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"quadraticForm:          â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"fidelity:               â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"fDiag:                  â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"DiagOfProd:             â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"mgs:                    â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"fVec:                   â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"evd:                    â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"spectralFunctions:      â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"pow:                    â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"invsqrt:                â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"sqr:                    â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"powerIterations:        â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"choL:                   â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Unit 'signalProcessing.jl'","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"randÎ»:                  â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"randÎ›:                  â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"randU:                  â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"randP:                  â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"regularize!:            â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"gram:                   â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"trade:                  â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Unit 'riemannianGeometry.jl'","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"geodesic:               â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceSqr (I):        â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceSqr (II):       â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceSqr (III):      â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distance (I):           â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distance (II):          â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceSqrMat (I):     â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceSqrMat (I â© ):  â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceSqrMat (II):    â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceSqrMat (II â© ): â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceMat (I):        â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceMat (I â© ):     â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceMat (II):       â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"distanceMat (II â© ):    â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"laplacian:              â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"laplacianEigenMaps:     â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"spectralEmbedding:      â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"mean (I):               â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"mean (II):              â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"mean (â© ):              â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"means:                  â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"means (â© ):             â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"generalizedMean:        â­ â­ â­ â­ â­ â­ â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"generalizedMean(â© ):    â˜† â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"geometricMean:          â˜† â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"geometricMean(â© ):      â˜† â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"logdet0Mean:            â­ â­ â­ â­ â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"logdet0Mean(â© ):        â˜† â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"wasMean:                â˜† â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"wasMean(â© ):            â˜† â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"powerMean:              â˜† â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"powerMean(â© ):          â˜† â˜† â˜† â˜† â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"logMap:                 â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"expMap:                 â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"vecP:                   â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"matP:                   â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"procrustes:             â˜† â˜†","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"Unit 'classification.jl'","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"softmax:                â­","category":"page"},{"location":"test/#","page":"test.jl","title":"test.jl","text":"[ Info: All tests were succesful!","category":"page"},{"location":"MainModule/#MainModule-(PosDefManifold.jl)-1","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is the main unit containing the PosDefManifold module.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"It uses the following standard Julia packages:","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"using\nLinearAlgebra\nStatistics","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Examples in some units of PosDefManifold also uses the Plots package. Take a look at this tutorial for an introduction to data plotting with Julia.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"The main module does not contains functions, but it declares all constant, types and aliases of Julia functions used in all units.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Contents\nconstants\naliases\ntypes\ntips & tricks","category":"page"},{"location":"MainModule/#constants-1","page":"MainModule (PosDefManifold.jl)","title":"constants","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"constant value numeric value\nsqrt2 âˆš2 1.4142135623730951\nsqrt2inv 1/âˆš2 0.7071067811865475\ngolden (âˆš5+1)/2 1.618033988749...\ngoldeninv (âˆš5-1)/2 0.618033988749...\nmaxpos 1e15 100000000000000","category":"page"},{"location":"MainModule/#aliases-1","page":"MainModule (PosDefManifold.jl)","title":"aliases","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"alias Julia function in Package tab-completition REPL support\nğšº sum Base \\bfSigma â›”\nğ› mean Statistics \\bfmu â›”\nğ•„ Matrix Base \\bbM â›”\nğ”» Diagonal LinearAlgebra \\bbD â›”\nâ„ Hermitian LinearAlgebra \\bbH âœ“\nğ•ƒ LowerTriangular LinearAlgebra \\bbH â›”","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"All packages above are built-in julia packages.","category":"page"},{"location":"MainModule/#types-1","page":"MainModule (PosDefManifold.jl)","title":"types","text":"","category":"section"},{"location":"MainModule/#Metric::Enumerated-type-1","page":"MainModule (PosDefManifold.jl)","title":"Metric::Enumerated type","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"@enum Metric begin\n  Euclidean    =1\n  invEuclidean =2\n  ChoEuclidean =3\n  logEuclidean =4\n  LogCholesky  =5\n  Fisher       =6\n  logdet0      =7\n  Jeffrey      =8\n  VonNeumann   =9\n  Wasserstein  =10\nend","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Riemannian manipulations are defined for a given metric (see metrics).  An instance for this type is requested as an argument in many functions  contained in the riemannianGeometry.jl unit in order to specify  the metric.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":" ## Example\n # generate a 15x15 symmetric positive definite matrix\n P=randP(15)\n # distance from P to the identity matrix according to the logdet0 metric\n d=distance(logdet0, P)","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"If you want to work consistently with a specific metric,  you may want to declare in your script a global variable such as","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"global metric=logdet0  or  global metric=Metric(Int(logdet0)),","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"and then pass metric as argument in all your computations,  e.g., referring to the above example,","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"d=distance(metric, P).","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"To know what is the current metric, you can get it as a string using:","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"s=string(metric)","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"To see the list of metrics in type Metric use:","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"instances(Metric)","category":"page"},{"location":"MainModule/#Array-of-Matrices-types-1","page":"MainModule (PosDefManifold.jl)","title":"Array of Matrices types","text":"","category":"section"},{"location":"MainModule/#ğ•„Vector-type-1","page":"MainModule (PosDefManifold.jl)","title":"ğ•„Vector type","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ•„Vector=Vector{ğ•„}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is a vector of general Matrix matrices, alias of MatrixVector.  Julia sees it as: Array{Array{T,2} where T,1}. See aliases for the ğ•„ symbol and typecasting matrices for the use of matrices in PosDefManifold.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"warning: Nota bene\nThis object is meant to hold matrices living in the same manifold, therefore it is assumed by all methods that all matrices it holds are of the same dimension.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See dim, typeofMatrix","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ•„Vectorâ‚‚ type","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ•„Vectorâ‚‚=Vector{ğ•„Vector}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is a vector of ğ•„Vector type objects,  i.e., a vector of vectors of matrices.  It is the alias of MatrixVectorâ‚‚.  Julia sees it as: Array{Array{Array{T,2} where T,1},1}.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"warning: Nota bene\nThis object is meant to hold matrices living in the same manifold, therefore it is assumed by all methods that all matrices it holds are of the same dimension. However the several ğ•„Vector objects it holds do not need to have the same length.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See dim, typeofMatrix","category":"page"},{"location":"MainModule/#ğ”»Vector-type-1","page":"MainModule (PosDefManifold.jl)","title":"ğ”»Vector type","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ”»Vector=Vector{ğ”»}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is a vector of Diagonal matrices, alias of DiagonalVector.  Julia sees it as: Array{Diagonal,1}. See aliases for the ğ”» symbol and typecasting matrices for the use of Diagonal matrices in PosDefManifold.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"warning: Nota bene\nThis object is meant to hold matrices living in the same manifold, therefore it is assumed by all methods that all matrices it holds  are of the same dimension.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See dim, typeofMatrix","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ”»Vectorâ‚‚ type","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ”»Vectorâ‚‚=Vector{ğ”»Vector}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is a vector of ğ”»Vector type objects,  i.e., a vector of vectors of Diagonal matrices.  It is the alias of DiagonalVectorâ‚‚.  Julia sees it as: Array{Array{Diagonal,1},1}.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"warning: Nota bene\nThis object is meant to hold matrices living in the same manifold, therefore it is assumed by all methods that all matrices it holds are of the same dimension. However the several ğ”»Vector objects it holds do not need to have the same length.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See dim, typeofMatrix","category":"page"},{"location":"MainModule/#ğ•ƒVector-type-1","page":"MainModule (PosDefManifold.jl)","title":"ğ•ƒVector type","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ•ƒVector=Vector{ğ•ƒ}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is a vector of LowerTriangular matrices, alias of LowerTriangularVector.  Julia sees it as: Array{LowerTriangular,1}. See aliases for the ğ•ƒ symbol and typecasting matrices for the use of LowerTriangular matrices in PosDefManifold.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"warning: Nota bene\nThis object is meant to hold matrices living in the same manifold, therefore it is assumed by all methods that all matrices it holds are of the same dimension.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See dim, typeofMatrix","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ•ƒVectorâ‚‚ type","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"ğ•ƒVectorâ‚‚=Vector{ğ•ƒVector}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is a vector of ğ•ƒVector type objects, i.e.,  a vector of vectors of LowerTriangular matrices.  It is the alias of LowerTriangularVectorâ‚‚.  Julia sees it as: Array{Array{LowerTriangular,1},1}.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"warning: Nota bene\nThis object is meant to hold matrices living in the same manifold, therefore it is assumed by all methods that all matrices it holds are of the same dimension. However the several ğ•ƒVector objects it holds do not need to have the same length.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See dim, typeofMatrix","category":"page"},{"location":"MainModule/#â„Vector-type-1","page":"MainModule (PosDefManifold.jl)","title":"â„Vector type","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"â„Vector=Vector{â„}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is a vector of Hermitian matrices, alias of HermitianVector.  Julia sees is at: Array{Hermitian,1}.See aliases for the â„ symbol and typecasting matrices for the use of Hermitian matrices in PosDefManifold.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"warning: Nota bene\nThis object is meant to hold matrices living in the same manifold, therefore it is assumed by all methods that all matrices it holds are of the same dimension.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See dim, typeofMatrix","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"â„Vectorâ‚‚ type","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"`â„Vectorâ‚‚=Vector{â„Vector}`","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is a vector of â„Vector type  objects, i.e., a vector of vectors of Hermitian matrices.  It is the alias of HermitianVectorâ‚‚.  Julia sees it as: Array{Array{Hermitian,1},1}.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"warning: Nota bene\nThis object is meant to hold matrices living in the same manifold, therefore it is assumed by all methods that all matrices it holds are of the same dimension. However the several â„Vector objects it holds do not need to have the same length.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See dim, typeofMatrix","category":"page"},{"location":"MainModule/#RealOrComplex-type-1","page":"MainModule (PosDefManifold.jl)","title":"RealOrComplex type","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"RealOrComplex=Union{Real, Complex}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is the Union of Real and Complex types.","category":"page"},{"location":"MainModule/#AnyMatrix-type-1","page":"MainModule (PosDefManifold.jl)","title":"AnyMatrix type","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"AnyMatrix=Union{ğ”»{T}, ğ•ƒ{T}, â„{T}, ğ•„{T}} where T<:RealOrComplex","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is the Union  of real or complex Diagonal, LowerTriangular, Hermitian and Matrix types. It is often used in the definition of functions.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See aliases","category":"page"},{"location":"MainModule/#AnyMatrixVector-type-1","page":"MainModule (PosDefManifold.jl)","title":"AnyMatrixVector type","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"AnyMatrixVector=Union{ğ•„Vector, ğ”»Vector, ğ•ƒVector, â„Vector}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is the Union of ğ•„Vector, ğ”»Vector, ğ•ƒVector and â„Vector. It is often used in the definition of functions.  See Array of Matrices types.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"AnyMatrixVectorâ‚‚ type","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"AnyMatrixVectorâ‚‚=Union{ğ•„Vectorâ‚‚, ğ”»Vectorâ‚‚, ğ•ƒVectorâ‚‚, â„Vectorâ‚‚}","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"This is the Union of ğ•„Vectorâ‚‚, ğ”»Vectorâ‚‚, ğ•ƒVectorâ‚‚, â„Vectorâ‚‚. It is often used in the definition of functions. See Array of Matrices types.","category":"page"},{"location":"MainModule/#tips-and-tricks-1","page":"MainModule (PosDefManifold.jl)","title":"tips & tricks","text":"","category":"section"},{"location":"MainModule/#typecasting-matrices-1","page":"MainModule (PosDefManifold.jl)","title":"typecasting matrices","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Several functions in PosDefManifold implement multiple dispatch and can handle several kinds of matrices as input, however the core functions for manipulating objects on the Riemannian manifold of positive definite matrices act by definition on positive definite matrices only.  Those matrices must therefore be either  symmetric positive definite (SPD, real) or Hermitian positive definite (HPD, complex).  Such matrices are uniformly identified in PosDefManifold as being of the Hermitian type, using the standard LinearAlgebra package.  The alias â„ is used consistently in the code (see aliases).  If the input is not flagged as Hermitian, the functions restricting the input to positive definite matrices will not be accessible.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Example","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"julia> using LinearAlgebra\n\njulia> f(S::Hermitian)=S*S'\nf (generic function with 1 method)\n\njulia> A=randn(3, 3)\n3Ã—3 Array{Float64,2}:\n -0.67407  -0.344258    0.203714\n -1.06551  -0.0233796   0.975465\n -1.04727  -1.19807    -0.0219121\n\njulia> H=A*A' # although SPD, H is not automatically flagged as Hermitian\n3Ã—3 Array{Float64,2}:\n 0.614384  0.924991  1.11391\n 0.924991  2.08738   1.12251\n 1.11391   1.12251   2.53263\n\njulia> f(H)\nERROR: MethodError: no method matching f(::Array{Float64,2})\nClosest candidates are:\n  f(::Hermitian) at none:1","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"If you construct a positive definite matrix and it is not flagged,  you can do so simply by typecasting it, that is, passing as argument to the  functions Hermitian(P) instead of just P. The â„ alias can be  used for short, i.e., â„(P). Continuing the example above:","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"julia> f(â„(H))  # this way it works, equivalent to f(Hermitian(H))\n3Ã—3 Array{Float64,2}:\n 2.47388  3.74948  4.54381\n 3.74948  6.4728   6.21635\n 4.54381  6.21635  8.91504","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Be careful: Hermitian(P) will construct and Hermitian matrix from the argument.  If the matrix argument is not symmetric (if real) or Hermitian (if complex)  it will be made so by copying the transpose (if real) or complex conjugate  and transpose (if complex) of a triangular part into the other.  See Hermitian.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"If you want to construct an â„Vector type from, say, two Hermitian matrices P and Q, don't write A=[P, Q], but rather A=â„Vector([P, Q]). In fact,  the first is seen by Julia as","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"2-element Array{Hermitian{Float64,Array{Float64,2}},1},","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"while the latter as","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"2-element Array{Hermitian,1},","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"which is the type expected in all functions taking an â„Vector type as argument.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Other functions act on generic matrices (of type Matrix). This is seen by Julia as Array{T,2} where T.  Keep in mind that the functions writing on the argument matrix such as  normalizeCol! will give an error if you pass an Hermitian matrix,  since Julia does not allow writing on non-diagonal elements of those matrices.  In this case typecast it in another object using the Matrix type;  suppose H is Hermitian, you would use for example:","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"julia> X=Matrix(H)\njulia> normalizeCol!(X, 1)\njulia> norm(X[:, 1])\n1.0","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Some more examples:","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Typecasting Adjoint matrices:\nMatrix(X')\nhere is how to get an Hermitian matrix out of the diagonal part of an Hermitian matrix H:\nHermitian(Matrix(Diagonal(H)))\nhere is how to get a LowerTriangular matrix out of an Hermitian matrix H:\nLowerTriangular(Matrix(H))","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"For example, you can use this to pass a full inter-distance matrix to the laplacian function to obtain the Laplacian matrix.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"A useful function is typeofMatrix. For example, the following line  typecasts matrix M to the type of matrix P and put the result in A:","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"A=typeofMatrix(P)(M)","category":"page"},{"location":"MainModule/#Threads-1","page":"MainModule (PosDefManifold.jl)","title":"Threads","text":"","category":"section"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Some functions in PosDefManifold explicitly call BLAS routines for optimal performnce. This is reported in the help section of the concerned functions. Most functions calls BLAS routine implicitly via Julia. You can set the number of threads the BLAS library should use by:","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"using LinearAlgebra\nBLAS.set_num_threads(n)","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"where n is the number of threads. By default, PosDefManifold reserves to BLAS all CPU threads available on your computer (given by the output of Sys.CPU_THREADS). The number of threads used by Julia for multi-threaded computations is given by the output of function Threads.nthreads(). In Windows this latter number of threads is set to half the available threads. In Linux and OSX defaults to one and is controlled by an environment variable, i.e.,","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"export JULIA_NUM_THREADS=4.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"In Linux, working with the Atom IDE, you also have to set to global the field found in Atom under Settings(or Preferences)/julia-client/Settings/Julia Options/Number of Threads.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"In Windows, set the desired number of threads in the settings of the julia-client Juno package.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"See for example this post, this post and julia doc on threads.","category":"page"},{"location":"MainModule/#","page":"MainModule (PosDefManifold.jl)","title":"MainModule (PosDefManifold.jl)","text":"Notice that PosDefManifold features many multi-threaded functions and these may allow a gain in computation time only if Julia is instructed to use at least two threads.","category":"page"},{"location":"#PosDefManifold-Documentation-1","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"","category":"section"},{"location":"#Requirements-1","page":"PosDefManifold Documentation","title":"Requirements","text":"","category":"section"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"Julia version â‰¥ 1.3","category":"page"},{"location":"#Installation-1","page":"PosDefManifold Documentation","title":"Installation","text":"","category":"section"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"Execute the following command in Julia's REPL:","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"]add PosDefManifold","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"To obtain the latest development version execute instead","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"]add PosDefManifold#master","category":"page"},{"location":"#About-the-Author-1","page":"PosDefManifold Documentation","title":"About the Author","text":"","category":"section"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"Marco Congedo is a research scientist of CNRS (Centre National de la Recherche Scientifique), working in Grenoble, France.","category":"page"},{"location":"#Overview-1","page":"PosDefManifold Documentation","title":"Overview","text":"","category":"section"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"(Image: Figure 1)","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"Riemannian geometry studies smooth manifolds, multi-dimensional curved spaces with peculiar geometries endowed with non-Euclidean metrics. In these spaces Riemannian geometry allows the definition of angles, geodesics (shortest path between two points), distances between points, centers of mass of several points, etc.","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"In this package we are concerned with the manifold P of positive definite matrices, either symmetric positive definite or Hermitian positive definite.","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"In several fields of research such as computer vision and brain-computer interface, treating data in the P manifold has allowed the introduction of machine learning approaches with remarkable characteristics, such as simplicity of use, excellent classification accuracy, as demonstrated by the winning score obtained in six international data classification competitions, and the ability to operate transfer learning (Congedo et al., 2017)ğŸ“).","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"For a formal introduction to the P manifold the reader is referred to the monography written by Bhatia (2007)ğŸ“.","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"For an introduction to Riemannian geometry and an overview of mathematical tools implemented in this package, see Intro to Riemannian Geometry in this documentation.","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"For starting using this package, browse the code units listed here below and execute the many code examples you will find therein. The core functions are contained in unit riemannianGeometry.jl.","category":"page"},{"location":"#Code-units-1","page":"PosDefManifold Documentation","title":"Code units","text":"","category":"section"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"PosDefManifold includes six code units (.jl files):","category":"page"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"Unit Description\nMainModule (PosDefManifold.jl) Main module, constants, types, aliases, tips & tricks\nriemannianGeometry.jl The fundamental unit collecting all functions acting on the P manifold\nlinearAlgebra.jl Collection of linear algebra routines\nstatistics.jl Collection of statistics routines\nsignalProcessing.jl Collection of signal processing routines\ntest.jl Unit performing all tests","category":"page"},{"location":"#Contents-1","page":"PosDefManifold Documentation","title":"Contents","text":"","category":"section"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"Pages = [       \"index.md\",\n                \"introToRiemannianGeometry.md\",\n                \"MainModule.md\",\n                \"riemannianGeometry.md\",\n                \"linearAlgebra.md\",\n                \"statistics.md\",\n                \"signalProcessing.md\",\n                \"test.md\"]\nDepth = 1","category":"page"},{"location":"#Index-1","page":"PosDefManifold Documentation","title":"Index","text":"","category":"section"},{"location":"#","page":"PosDefManifold Documentation","title":"PosDefManifold Documentation","text":"","category":"page"},{"location":"statistics/#statistics.jl-1","page":"statistics.jl","title":"statistics.jl","text":"","category":"section"},{"location":"statistics/#","page":"statistics.jl","title":"statistics.jl","text":"Unit for statistics, probability and related functions.","category":"page"},{"location":"statistics/#","page":"statistics.jl","title":"statistics.jl","text":"Category Output\n1. Probability functions relating to probability\n2. Descriptive Statistics functions relating to decriptive statistics","category":"page"},{"location":"statistics/#Probability-1","page":"statistics.jl","title":"Probability","text":"","category":"section"},{"location":"statistics/#","page":"statistics.jl","title":"statistics.jl","text":"Function Description\nsoftmax compute softmax probabilities","category":"page"},{"location":"statistics/#","page":"statistics.jl","title":"statistics.jl","text":"softmax","category":"page"},{"location":"statistics/#PosDefManifold.softmax","page":"statistics.jl","title":"PosDefManifold.softmax","text":"softmax(Ï‡::Vector{T}) where T<:Real\n\nGiven a real vector of k non-negative scores Ï‡=c_1c_k,  return the vector Ï€=p_1p_k of their  softmax probabilities,  as per\n\np_i=fractextrme^c_isum_i=1^ktextrme^c_i.\n\nExamples\n\nÏ‡=[1.0, 2.3, 0.4, 5.0]\nÏ€=softmax(Ï‡)\n\n\n\n\n\n","category":"function"},{"location":"statistics/#Descriptive-Statistics-1","page":"statistics.jl","title":"Descriptive Statistics","text":"","category":"section"},{"location":"statistics/#","page":"statistics.jl","title":"statistics.jl","text":"Function Description\nmean scalar mean of real or complex numbers according to the specified metric\nstd scalar standard deviation of real or complex numbers according to the specified metric","category":"page"},{"location":"statistics/#","page":"statistics.jl","title":"statistics.jl","text":"mean(metric::Metric, Î½::Vector{T}) where T<:RealOrComplex","category":"page"},{"location":"statistics/#","page":"statistics.jl","title":"statistics.jl","text":"See bottom of documentation of general function mean","category":"page"},{"location":"statistics/#","page":"statistics.jl","title":"statistics.jl","text":"std","category":"page"},{"location":"statistics/#Statistics.std","page":"statistics.jl","title":"Statistics.std","text":"std(metric::Metric, Î½::Vector{T};\n    corrected::Bool=true,\n    mean=nothing) where T<:RealOrComplex\n\nStandard deviation of k real or complex scalars,  using the specified metric  of type Metric::Enumerated type and the  specified mean if provided.\n\nOnly the Euclidean and Fisher  metric are supported by this function. Using the Euclidean  metric return the output of standard Julia  std  function. Using the Fisher metric return the scalar geometric standard deviation,  which is defined such as,\n\nsigma=textexpBig(sqrtk^-1sum_i=1^ktextln^2(v_imu)Big).\n\nIf corrected is true, then the sum is scaled with k-1,  whereas if it is false the sum is scaled with k.\n\nExamples\n\nusing PosDefManifold\n# Generate 10 random numbers distributed as a chi-square with 2 df.\nÎ½=[randÏ‡Â²(2) for i=1:10]\narithmetic_sd=std(Euclidean, Î½) # mean not provided\ngeometric_mean=mean(Fisher, Î½)\ngeometric_sd=std(Fisher, Î½, mean=geometric_mean) # mean provided\n\n\n\n\n\n","category":"function"},{"location":"introToRiemannianGeometry/#Intro-to-Riemannian-Geometry-1","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The study of appropriate distance measures for positive definite matrices has recently grown very fast, driven by practical problems in radar data processing, image processing, computer vision, shape analysis, medical imaging (especially diffusion MRI and Brain-Computer Interface), sensor networks, elasticity, mechanics, numerical analysis and machine learning (e.g., see references in Congedo et al., 2017a)ğŸ“.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"In many applications the observed data can be conveniently summarized by positive definite matrices, which are either symmetric positive definite (SPD: real) or Hermitian Positive Definite (HPD: complex). For example, those may be some form of the data covariance matrix in the time, frequency or time-frequency domain, or autocorrelation matrices, kernels, slices of tensors, density matrices, elements of a search space, etc. Positive definite matrices are naturally treated as points on a smooth Riemannian manifold allowing useful operations such as interpolation, smoothing, filtering, approximation, averaging, signal detection and classification. Such operations are the object of the present PosDefManifold library.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"More formally, this Julia library treats operations on the metric space (P Î´^2) of nãƒ»n positive definite matrices endowed with a distance or symmetric divergence Î´(P x P)0 . Several matrix distances or matrix divergences Î´ are considered. Using some of them, the most important one being the Fisher metric, we define a Riemannian manifold. In mathematics, this is the subject of Riemannian geometry and information geometry.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Note that throughout this library the word 'metric' is used loosely for referring to the actual Riemannian metric on the tangent space and to the resulting distance or to general symmetric divergence acting on P, regardless the fact that we are dealing with a metric in the strict sense and that it induces or not a Riemannian geometry in P. This is done for convenience of exposition, since in practice those 'metrics' in PosDefManifold may be used interchangeably.","category":"page"},{"location":"introToRiemannianGeometry/#Riemannian-manifolds-1","page":"Intro to Riemannian Geometry","title":"Riemannian manifolds","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Here are some important definitions:","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"A smooth manifold in differential geometry is a topological space that is locally similar to the Euclidean space and has a globally defined differential structure.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The tangent space at point G is the vector space containing the tangent vectors to all curves on the manifold passing through G (Fig. 1).","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"A smooth Riemannian manifold is equipped with an inner product on the tangent space (a Riemannian metric) defined at each point and varying smoothly from point to point. For manifold P the tangent space is the space of symmetric or Hermitian matrices.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Thus, a Riemannian metric turns the metric space (P Î´^2) into a Riemannian manifold. This is the case, for example, of the Fisher metric, which has a fundamental role in the manifolds of positive definite matrices and of the Wasserstein metric, fundamental in optimal transport theory.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"(Image: Figure 1) Figure 1. Schematic illustration of the Riemannian manifold of positive definite matrices. Left: geodesic relying points P and Q passing through its-mid-point (mean) G (green curve), tangent space at point G with tangent vectors to geodesic from G to P and from G to Q (blue arrowed lines) and distance Î´(G Q). Right: the center of mass (also named mean) G of points P_1P_4 defined as the point minimizing the sum of the four squared distances Î´Â²(G P_i), for i=14.","category":"page"},{"location":"introToRiemannianGeometry/#geodesic-1","page":"Intro to Riemannian Geometry","title":"geodesic","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The key object in the P manifold is the geodesic, loosely defined as the shortest path joining two points P and Q on the manifold, analogous to straight lines in the Euclidean space (Fig. 1). The gedesic equation with arclength 0a1 is the equation of the points along the path, denoted gamma(P Q a) where with a=0 we stay at P and with a=1 we move all the way to Q. The points along the geodesic in between P and Q (0a1) can be understood as weighted means of P and Q. For example, the geodesic equation according to the Euclidean metric is (1-a)P + aQ, which is the traditional way to define weighted means. With the metrics we consider here, geodesics are unique and always exist. Furthermore, as we will see, using the Fisher metric those geodesics extends indefinitely, i.e., they are definied and always remain positive definite for -a.","category":"page"},{"location":"introToRiemannianGeometry/#distance-1","page":"Intro to Riemannian Geometry","title":"distance","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The length of the geodesic (at constant velocity) between two points gives the distance Î´(P Q).  The distance is always real, non-negative and equal to zero if and only if P=Q.","category":"page"},{"location":"introToRiemannianGeometry/#distance-from-the-origin-1","page":"Intro to Riemannian Geometry","title":"distance from the origin","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"In contrast to an Euclidean space, the origin of the P manifold endowed with the Fisher metric is not 0_n, but I_n, the identity matrix of dimension nãƒ»n. The distance between a point P and the origin, i.e., Î´(P I), is analogous therein to the length of vectors in Euclidean space. This Riemannian manifold is symmetric around I_n, i.e., Î´(P I)=Î´(P^-1 I) and Î´(P Q)=Î´(P^-1 Q^-1). This will be made more precise when we talk about invariances.","category":"page"},{"location":"introToRiemannianGeometry/#mean-1","page":"Intro to Riemannian Geometry","title":"mean","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The mid-point on the geodesic relying P and Q is named the mean. Using the Euclidean metric this is the arithmetic mean of P and Q and using the inverse Euclidean metric this is their harmonic mean. As we will see, those are straightforward extensions of their scalar counterparts. Using the Fisher metric the mid-point of the geodesic relying P and Q allows the proper generalization to matrices of the scalars' geometric mean. The other metrics allows other definition of means (see below).","category":"page"},{"location":"introToRiemannianGeometry/#FrÃ©chet-mean-1","page":"Intro to Riemannian Geometry","title":"FrÃ©chet mean","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Using FrÃ©chet's variational approach we can extend to positive-definite matrices the concept of weighted mean of a set of scalars; as the midpoint G on the geodesic relying P and Q is the minimizer of sigma^2(P G)+sigma^2(Q G), so the mean G of points P_1 P_2P_k is the matrix G verifying","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"textrmargmin_Gsum_i=1^kÎ´^2(P_iG)","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Thus, every metric induces a distance (or divergence) function, which, in turn, induces a mean.","category":"page"},{"location":"introToRiemannianGeometry/#invariances-1","page":"Intro to Riemannian Geometry","title":"invariances","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"An important characteristic of metrics is that they may induce invariance properties on the distance, which are in turn inherited by the mean.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Let us denote shortly by P_i the set P_1P_k, where i=1k  and by GP_i the FrÃ©chet mean of the set (in this section we drop the weights here for keeping the notation short). The most important invariance properties are:","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"invariance effect on distance Î´(PQ) effect on mean GP_i\nrotation Î´(PQ)=Î´(U^HPUU^HQU) GU^HP_iU=U^HGP_iU\naffinity Î´(PQ)=Î´(B^HPBB^HQB) GB^HP_iB=B^HGP_iB\ninversion Î´(PQ)=Î´(P^-1Q^-1) GP_i^-1=G^-1P_i","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"for any unitary U and non-singular B.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The affine invariance implies the rotation invariance and is also named congruence invariance.","category":"page"},{"location":"introToRiemannianGeometry/#metrics-1","page":"Intro to Riemannian Geometry","title":"metrics","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"We are interested in distance or divergence functions, the difference between the two being that a divergence does not need to be symmetric nor to satisfy the triangle inequality. Note that in PosDefManifold we consider only distances and symmetric divergences. In fact those are of greater interest in practice. One can find several distances and divergences in the literature and they often turn out to be related to each other, see for example (Chebby and Moakher, 2012; Cichocki et al., 2015; Sra, 2016)ğŸ“. Ten of them are implemented in PosDefManifold and two of them are Riemannian metrics (the Fisher and Wasserstein metric as we have said). In this section we give a complete list of the expressions for their induced","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distance of a point P from the origin,\ndistance between two points P and Q,\ngeodesic relying P to Q (hence the weighted means of P and Q)\nweighted FrÃ©chet mean G(Pw) of a set of k2 points P_1P_k with associated real non-negative weights w_1w_k summing up to 1.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"note: Nota Bene\nIn the following, the weights w_1w_k are always supposed summing up to 1, superscript H indicate conjugate transpose (or just transpose if the matrix is real) and if a is the arclength of a geodesic, we define for convenience b=1-a.","category":"page"},{"location":"introToRiemannianGeometry/#Euclidean-1","page":"Intro to Riemannian Geometry","title":"Euclidean","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"This is the classical Euclidean distance leading to the usual arithmetic mean. In general this metric is not well adapted to the P manifold. It verifies only the rotation invariance, however the mean also verifies the congruence invariance.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distanceÂ² to I distanceÂ²\nP-I^2 P-Q^2","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic FrÃ©chet mean\nbP + aQ sum_i=1^kw_i P_i","category":"page"},{"location":"introToRiemannianGeometry/#inverse-Euclidean-1","page":"Intro to Riemannian Geometry","title":"inverse Euclidean","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"This is the classical harmonic distance leading to the harmonic mean. It verifies only the rotation invariance, however the mean also verifies the congruence invariance.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distanceÂ² to I distanceÂ²\nP^-1-I^2 P^-1-Q^-1^2","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic FrÃ©chet mean\nbig(bP^-1 + aQ^-1big)^-1 big(sum_i=1^kw_i P_i^-1big)^-1","category":"page"},{"location":"introToRiemannianGeometry/#Cholesky-Euclidean-1","page":"Intro to Riemannian Geometry","title":"Cholesky Euclidean","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"This is a very simple metric that has been tried to improve the Euclidean one. It is rarely used (see for example Dai et al., 2016)ğŸ“. It does not verify any invariance. Let L_P be the lower triangular Cholesky factor of P, then","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distanceÂ² to I distanceÂ²\nL_P-I^2  L_P-L_Q ^2","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic FrÃ©chet mean\n(bL_P+aL_Q)(bL_P+aL_Q)^H big(sum_i=1^kw_i L_P_ibig)big(sum_i=1^kw_i L_P_ibig)^H","category":"page"},{"location":"introToRiemannianGeometry/#log-Euclidean-1","page":"Intro to Riemannian Geometry","title":"log Euclidean","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"If matrices P_1P_k all pair-wise commute, then this metric coincides with the Fisher metric. See (Arsigny et al., 2007 ; Bhatia et al., 2019a)ğŸ“. It enjoys the rotation and inversion invariance. The log-Euclidean distance to I is the same as per the Fisher metric. This mean has the same determinant as the Fisher mean, and trace equal or superior to the trace of the Fisher mean. A minimum trace log Euclidean mean approximating well the Fisher mean has been proposed in Congedo et al. (2015)ğŸ“.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distanceÂ² to I distanceÂ²\ntextrmlog(P)^2 textrmlog(P)-textrmlog(Q)^2","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic FrÃ©chet mean\ntextrmexpbig(textrmlogP + atextrmlogQbig) textrmexpbig(sum_i=1^kw_ihspace1pttextrmlogP_ibig)","category":"page"},{"location":"introToRiemannianGeometry/#log-Cholesky-1","page":"Intro to Riemannian Geometry","title":"log Cholesky","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"It is a recently proposed distance in P. Like the Cholesky Euclidean metric here above, it exploits the diffeomorphism between matrices in P and their Cholesky factor, such that L_PL_P^H=P, thanks to the fact that the Cholesky factor is unique and that the map is smooth (Lin, 2019)ğŸ“. The mean has the same determinant as the Fisher and log-Euclidean mean.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Let L_X,S_X and D_X be the lower triangle, the strictly lower triangle and the diagonal part of X, respectively (hence, S_X+D_X=L_X), then","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"DistanceÂ² to I DistanceÂ²\nS_P-I^2+textrmlogD_P^2 S_P-S_Q^2+textrmlogD_P-textrmlogD_Q^2","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic: S_P+a(S_Q-S_P)+D_Phspace2pttextrmexpbig(atextrmlogD_Q-atextrmlogD_Pbig)","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"FrÃ©chet mean: TT^H, where T=sum_i=1^kw_iS_P_i+sum_i=1^kw_itextrmlogD_P_i","category":"page"},{"location":"introToRiemannianGeometry/#Fisher-1","page":"Intro to Riemannian Geometry","title":"Fisher","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The Fisher metric, also known as affine-invariant, natural and Fisher-Rao metric, among others names, has a paramount importance for the P manifold, standing out as the natural choice both from the perspective of differential geometry and information geometry. Endowed with the Fisher metric the manifold P is Riemannian, has nonpositive curvature and is symmetric. This metric verifies all three invariances we have considered.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"DistanceÂ² to I DistanceÂ²\ntextrmlog(P)^2 textrmlog(P^-12QP^-12)^2","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic\nP^12 big(P^-12 Q P^-12big)^a P^12","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"FrÃ©chet mean: it does not have a closed-form solution in general. The solution is the unique positive definite matrix G satisfying (Bhatia and Holbrook, 2006; Moakher, 2005).ğŸ“","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"sum_i=1^kw_itextrmlogbig(G^-12 P_i G^-12big)=0","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"For estimating it, PosDefManifold implements the well-known gradient descent algorithm, resulting in iterations:","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"G G^12textrmexpbig(sum_i=1^kw_itextrmlog(G^-12 P_i G^-12)big)G^12","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Alternatively, and more efficiently, one can ask for an approximate solution invoking the MPM algorithm (Congedo et al., 2017b)ğŸ“, which is also implemented (in order to estimate the geometric mean use function powerMean with parameter p=0 or with a very small value of p).","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"This mean is known under many different names (Fisher, Rao, Fisher-Rao, Pusz-Woronowicz, Cartan, FrÃ©chet, Karcher, geometric....). The â€˜centralityâ€™ of this mean among a wide family of divergence-based means can be appreciated in Fig. 4 of Cichocki et al. (2015)ğŸ“.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The geometric mean G of two matrices P and Q is denoted gamma(P Q frac12). Currently it is an object of intense study because of its interesting mathematical properties. For instance,","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"it is the unique solution to Riccati equation GQ^-1G=P\nit is equal to F^-HD_1^12D_2^12F^-1 for whatever joint diagonalizer F of P and Q, i.e., for whatever matrix F satisfying F^HPF=D_1 and F^HQF=D_2, with D_1, D_1 non-singular diagonal matrices (Congedo et al., 2015)ğŸ“.\nit enjoys all 10 properties of means postulated in the seminal work of Ando et al. (2010)ğŸ“.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"When P and Q commutes, the Fisher mean of two matrices reduces to P^12Q^12, which indeed in this case is the log-Euclidean mean frac12textrmlogP + frac12textrmlogQ.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"We denote the Fisher geodesic equation as gamma(P Q a). Note that gamma(I P a)=P^a and gamma(P I a)=P^b, where b=1-a.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Fisher geodesic equation verifies gamma(P Q a)=gamma(Q P b) and (gamma(P Q a))^-1=gamma(P^-1 Q^-1 a).","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"An interesting property of the Fisher metric is that using its geodesic equation we can extrapolate positive matrices, always remaining in P. That is, using any real value of a :","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"with 0  a  1 we move toward Q\t\t(attraction),\nwith a  1 we move over and beyond Q\t(extrapolation) and\nwith a 0 we move back away from Q \t(repulsion).","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Something similar can be done using the log Cholesky metric as well.","category":"page"},{"location":"introToRiemannianGeometry/#power-means-1","page":"Intro to Riemannian Geometry","title":"power means","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The arithmetic, harmonic and geometric mean we have encountered are all members of the 1-parameter family of power means (with parameter p-1 1) introduced by Lim and Palfia (2012)ğŸ“ to generalize the concept of power means of scalars (also known as HÃ¶lder means or generalized means). The family of power means G with parameter p satisfies equation","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"G=sum_i=1^kw_igamma(G P p),","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"wheregamma(G P p) is the Fisher geodesic equation we have discussed here above talking about the Fisher metric. In particular:","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"with p=-1 this is the harmonic mean (see the inverse Euclidean metric)\nwith p=+1 this is the arithmetic mean (see the Euclidean metric)\nat the limit of p evaluated at zero from both side this is the geometric mean (see the Fisher metric).","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Thus, the family of power means continuously interpolate between the arithmetic and harmonic mean passing through the the geometric mean.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Power means are the unique positive definite solution of (Yamazaki, 2019)ğŸ“","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"sum_i=1^kw_ibig(G^-12 P_i G^-12big)^p=I.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"All power means enjoy the congruence invariance (hence the rotation invariance), but only the geometric mean enjoy also the inversion invariance.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The power mean with p=frac12 is the solution of the FrÃ©chet mean problem using the following divergence (Bhatia, Gaubert and Jain, 2019)ğŸ“","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Î´^2(PQ)=textrmtr(P+Q)-2textrmtrgamma(G P frac12) = textrmtr(textrmarithm mean(P Q))  textrmtr(textrmgeom mean(P Q))","category":"page"},{"location":"introToRiemannianGeometry/#generalized-means-1","page":"Intro to Riemannian Geometry","title":"generalized means","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"When the matrices in the set all pairwise commute, it has been proved in Lim and Palfia (2012, see Property 1, p. 1502) ğŸ“ that the power means we have just seen reduce to","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"big(sum_i=1^kw_iP_i^pbig)^1p,","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"which are the straightforward extension of scalar power means (see generalized means) to matrices. As usual, such straightforward extensions work well in commuting algebra, but not in general. See for example the case of the mean obtained using the log Euclidean metric, which is the straightforward extension to matrices of the scalar geometric mean, but is not the matrix geometric mean, unless the matrices all pairwise commute.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Both the generalized means and the power means have a parameter p-1 1. For the latter, the solution is implemented via the fixed-point MPM algorithm (Congedo et al., 2017b)ğŸ“.","category":"page"},{"location":"introToRiemannianGeometry/#modified-Bhattacharyya-mean-1","page":"Intro to Riemannian Geometry","title":"modified Bhattacharyya mean","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"If matrices P_1 P_2P_k all pair-wise commute, the special case p=frac12 yields the following instance of power means (and of generalized means):","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"big(sum_i=1^kw_iP_i^12big)^12.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"This mean has been proposed  in a different context by Moakher (2012)ğŸ“ as a modified Bhattacharyya mean, since it is a modification of the Bhattacharyya mean we will encounter next under the name logdet zero. It is worth noting that in commuting algebra Moakherâ€™s mean also corresponds to the mean obtained with the Wasserstein metric.","category":"page"},{"location":"introToRiemannianGeometry/#logdet-zero-1","page":"Intro to Riemannian Geometry","title":"logdet zero","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The logdet zero divergence, also known as the square of the Bhattacharyya divergence (Mohaker, 2013)ğŸ“, Stein divergence (Harandi et al., 2016)ğŸ“, symmetrized Jensen divergence, the S-divergence (Sra, 2016)ğŸ“ or the log determinant Î±-divergence (with Î±=0, Chebby and Moakher, 2012 ğŸ“) is a Jensen-Bregman symmetric divergence enjoying all three invariances we have listed.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Its square root has been shown to be a distance (Sra, 2016)ğŸ“. It behaves very similarly to the Fisher metric at short distances (Moakher, 2012; Sra, 2016; Cichocki et al., 2015; Harandi et al., 2016) ğŸ“ and the mean of two matrices in P is the same as the Fisher mean  (Harandi et al., 2016) ğŸ“. Thus, it has often been used instead of the Fisher metric because it allows more efficient calculations. In fact, the calculation of this distance requires only three Cholesky decompositions, whereas the computation of the Fisher distance involves extracting generalized eigenvalues.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distanceÂ² to I distanceÂ²\ntextrmlogdetfrac12(P+I)-frac12textrmlogdet(P) textrmlogdetfrac12(P+Q)-frac12textrmlogdet(PQ)","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic: we use the FrÃ©chet mean with appropriate weights.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"FrÃ©chet mean: the solution is the unique positive definite matrix G satisfying","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"sum_i=1^kw_ibig(frac12P_i+frac12Gbig)^-1=G^-1.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"For estimating it PosDefManifold implements the fixed-point iterations (Moakher, 2012, p315)ğŸ“:","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"G  frack2big(sum_i=1^kw_i(P_i+G)^-1big)^-1.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The logdet zero divergence between P and Q can also be written as the log-determinant of their arithmetic mean minus the log-determinant of their geometric mean (Moakher, 2012)ğŸ“, which thus defines a possible extension to matrices of the useful concept of Wiener entropy.","category":"page"},{"location":"introToRiemannianGeometry/#logdet-Î±-1","page":"Intro to Riemannian Geometry","title":"logdet Î±","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The log determinant Î±-divergence family for Î±-11 (Chebby and Moakher, 2012)ğŸ“ allows","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"the logdet zero mean for Î±=0,\nthe left Kullback-Leibler mean for Î±=-1 (which is the harmonic mean)\nthe right Kullback-Leibler mean for Î±=1 (which is the arithmetic mean).","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"We do not consider the left and right Kullback-Leibler divergences because the related means are trivially the arithmetic and harmonic one (Moakher, 2012). As per the symmetrized Kullback-Leibler divergence, this is known as Jeffrey divergence and will be considered next. The log determinant Î±-divergence family of means is not implemented in PosDefManifold (besides the special cases Î±=(-1 0 1), since the family of power means are implemented.","category":"page"},{"location":"introToRiemannianGeometry/#Jeffrey-1","page":"Intro to Riemannian Geometry","title":"Jeffrey","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"This is a Jensen-Bregman symmetric divergence, also known as the symmetrized Kullback-Leibler divergence (see logdet Î±) (Faraki et al., 2015)ğŸ“. It enjoyes all three invariances we have listed.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distanceÂ² to I distanceÂ²\nfrac12textrmtr big(P+P^-1big)-n frac12textrmtr(Q^-1P+P^-1Q)-n","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic: we use the FrÃ©chet mean with appropriate weights.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"FrÃ©chet mean: A^12big(A^-12HA^-12big)^12A^12, where A is the arithmetic mean (see Euclidean metric) and H is the harmonic mean (see inverse Euclidean metric). Thus, the weighted FrÃ©chet mean is the geometric mean (see Fisher metric) of the arithmetic and harmonic mean (Moakher, 2012)ğŸ“.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Note that this is the geometric mean only for k=2, that is, for scalars, but not in general for matrices, the geometric mean is the geometric mean of the arithmetic mean and harmonic mean (the only metric inducing the geometric mean in general is the Fisher mean).","category":"page"},{"location":"introToRiemannianGeometry/#Von-Neumann-1","page":"Intro to Riemannian Geometry","title":"Von Neumann","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The Von Neumann divergence is a Jensen-Bregman symmetric divergence (Sra, 2016; Taghia et al., 2019)ğŸ“. It enjoyes only the rotation invariance.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distanceÂ² to I distanceÂ²\nfrac12textrmtr(PtextrmlogP-textrmlogP) frac12textrmtrbig(P(textrmlogP-textrmlogQ)+Q(textrmlogQ-textrmlogP)big)","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The geodesic and weighted FrÃ©chet mean for this metric are not available.","category":"page"},{"location":"introToRiemannianGeometry/#Wasserstein-1","page":"Intro to Riemannian Geometry","title":"Wasserstein","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"This is an extension to matrices of the Hellinger divergence for vectors and is also known as the Bures divergence in quantum physics, where it is applied on density matrices (unit trace positive-definite matrices). It enjoyes only the rotation invariance. Endowed with the Wasserstein metric the manifold P has a Riemannian geometry of nonnegative curvature. See ( Bhatia et al., 2019a; Bhatia et al., 2019b)ğŸ“.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"distanceÂ² to I distanceÂ²\ntextrmtr(P+I)-2textrmtr(P^12) textrmtr(P+Q) -2textrmtrbig(P^12QP^12big)^12","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"geodesic\nb^2P+a^2Q +abbig(PQ)^12 +(QP)^12big","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"The quantity textrmtrbig(P^12QP^12big)^12 is known in quantum physics as the fidelity of P and  Q when those are density matrices (unit-trace positive definite matrices).","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"FrÃ©chet mean: the solution is the unique positive definite matrix G satisfying (Agueh and Carlier, 2011) ğŸ“","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"G=sum_i=1^kw_ibig( G^12  P_i G^12big)^12.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"For estimating it, PosDefManifold implements the fixed-point algorithm of Ãlvarez-Esteban et al. (2016)ğŸ“, giving iterations:","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"G  G^-12 big(sum_i=1^k w_i(G^12P_i G^12)^12big)^2 G^-12","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"In the special case when the matrices all pair-wise commute, the Wasserstein mean is equal to the instance of power means and generalized means with p=frac12 (Bhatia, Jain and Lim, 2019b)ğŸ“, that is, to the modified Bhattacharyya mean.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"In the special case k=2 and equal weight the mean is W=frac14big(P+Q+(PQ) ^12+(QP)^12big).","category":"page"},{"location":"introToRiemannianGeometry/#-1","page":"Intro to Riemannian Geometry","title":"ğŸ“","text":"","category":"section"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"References","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"M. Agueh, G. Carlier (2011) Barycenters in the Wasserstein space, SIAM J. Mat. Anal. Appl. 43, 904-924.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"P. C. Ãlvarez-Esteban, E. del Barrio, J.A. Cuesta-Albertos, C. MatrÃ¡na (2016) A fixed-point approach to barycenters in Wasserstein space, Journal of Mathematical Analysis and Applications, 441(2), 744-762.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"T. Ando, C.-K. Li, R. Mathias (2004) Geometric means, Linear Algebra and its Applications, 385(1), 305-334.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"V. Arsigny, P. Fillard, X. Pennec, N. Ayache (2007) Geometric means in a novel vector space structure on symmetric positive-definite matrices, SIAM journal on matrix analysis and applications, 29(1), 328-347.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"A. Barachant, S. Bonnet, M. Congedo, C. Jutten (2012) Multi-class Brain Computer Interface Classification by Riemannian Geometry, IEEE Transactions on Biomedical Engineering, 59(4), 920-928.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"A. Barachant, S. Bonnet, M. Congedo, C. Jutten (2013) Classification of covariance matrices using a Riemannian-based kernel for BCI applications, Neurocomputing, 112, 172-178.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"R. Bhatia (2007) Positive Definite Matrices. Princeton University press.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"R. Bhatia, M. Congedo (2019) Procrustes problems in manifolds of positive definite matrices Linear Algebra and its Applications, 563, 440-445.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"R. Bhatia, S. Gaubert, T. Jain (2019) Matrix versions of the Hellinger distance, arXiv:1901.01378.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"R. Bhatia, J. Holbrook (2006) Riemannian geometry and matrix geometric means, Linear Algebra and its Applications, 413 (2-3), 594-618.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"R. Bhatia, T. Jain (2010) Approximation problems in the Riemannian metric on positive definite matrices, Ann. Funct. Anal., 5(2), 118-126.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"R. Bhatia, T. Jain,Y. Lim (2019a) Inequalities for the Wasserstein mean of positive definite matrices, Linear Algebra and its Applications, in press.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"R. Bhatia, T. Jain, Y. Lim (2019b) On the Bures-Wasserstein distance between positive definite matrices Expositiones Mathematicae, in press.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Z. Chebbi, M. Moakher (2012) Means of Hermitian positive-definite matrices based on the log-determinant Î±-divergence function, Linear Algebra and its Applications, 436(7), 1872-1889.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"A. Cichocki, S. Cruces, S-I- Amari (2015) Log-Determinant Divergences Revisited: Alpha-Beta and Gamma Log-Det Divergences, Entropy, 17(5), 2988-3034.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"R.R. Coifman, Y. Shkolnisky, F.J. Sigworth, A. Singer (2008) Graph Laplacian Tomography From Unknown Random Projections, IEEE Transactions on Image Processing, 17(10), 1891-1899.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"M. Congedo, B. Afsari, A. Barachant, M Moakher (2015) Approximate Joint Diagonalization and Geometric Mean of Symmetric Positive Definite Matrices, PLoS ONE 10(4): e0121423.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"M. Congedo, A. Barachant, R. Bhatia R (2017a) Riemannian Geometry for EEG-based Brain-Computer Interfaces; a Primer and a Review, Brain-Computer Interfaces, 4(3), 155-174.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"M. Congedo, A. Barachant, E. Kharati Koopaei (2017b) Fixed Point Algorithms for Estimating Power Means of Positive Definite Matrices, IEEE Transactions on Signal Processing, 65(9), 2211-2220.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"X. Dai, S. Khamis, Y. Zhang, L.S. Davis (2016) Parameterizing region covariance: an efficient way to apply sparse codes on second order statistics, arXiv:1602.02822.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"M. Faraki, M. Harandi, F. Porikli (2015) More About VLAD: A Leap from Euclidean to Riemannian Manifolds, IEEE Conference on Computer Vision and Pattern Recognition (CVPR), Boston.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"W. FÃ¶rstner, B. Moonen (1999) A metric for covariance matrices, In Krumm K and Schwarze VS eds. Qho vadis geodesia...?, number 1999.6 in tech. report of the Dep. Of Geodesy and Geoinformatics, p.113â€“128, Stuttgart University.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"M.T. Harandi, R. Hartley, B. Lovell, C. Sanderson (2016) Sparse coding on symmetric positive definite manifolds using bregman divergences, IEEE transactions on neural networks and learning systems, 27 (6), 1294-1306.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"N.J. Higham (1988) Computing a Nearest Symmetric Positive Semidefinite Matrix Linear Algebra and its Applications, 103, 103-118.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"J. Ho, G. Cheng, H. Salehian, B.C. Vemuri (2013) Recursive Karcher Expectation Estimators and Geometric Law of Large Numbers, Proc. of the AISTATS Conf.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"B. Iannazzo (2016) The geometric mean of two matrices from a computational viewpoint Numerical Linear Algebra with Applications, 23-2, 208-229.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"S. Lafon (2004) Diffusion maps and geometric harmonics, Ph.D. dissertation, Yale University, New Heaven, CT.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Y. Lim, M. PÃ¡lfia (2012) Matrix power means and the Karcher mean, Journal of Functional Analysis, 262(4), 1498-1514.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"Z. Lin (2019) Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition, in press.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"E. Massart, J.M. Hendrickx, P.-A. Absil (2018) Matrix Geometric Meansbased on shuffled inductive sequences Linear Algebra and its Aplications, 252, 334-359.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"M. Moakher (2005) A Differential Geometric Approach to the Geometric Mean of Symmetric Positive-Definite Matrices, SIAM Journal on Matrix Analysis and Applications, 26(3), 735-747.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"M. Moakher (2012) Divergence measures and means of symmetric positive-definite matrices, in D.H Lailaw and A. Vilanova (Eds) \"New Developments in the Visualization and Processing of Tensor Fields\", Springer, Berlin.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"C. Mostajeran, C. Grussler, R. Sepulchre (2019) Geometric Matrix Midranges arXiv:1907.04188.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"X. Pennec, P. Fillard, N. Ayache (2006) A Riemannian Framework for Tensor Computing, International Journal of Computer Vision, 66(1), 41-66.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"P.L.C. Rodrigues, M. Congedo, C Jutten (2018) Multivariate Time-Series Analysis Via Manifold Learning, in Proc. of the the IEEE Statistical Signal Processing Workshop (SSP 2018), Fribourg-en-Brisgau, Germany.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"S. Sra (2016) Positive definite matrices and the S-divergence, Proc. Amer. Math. Soc., 144, 2787-2797.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"J. Taghia, M. BÃ¥nkestad, F. Lindsten, T.B. SchÃ¶n (2019) Constructing the Matrix Multilayer Perceptron and its Application to the VAE, arXiv:1902.01182v1","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"S. Umeyama (1988) An Eigendecomposition Approach to Weighted Graph Matching Problems, IEEE Trans. Pattern. Anal. Mach. Intell., 10(5), 695-703.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"O. Yair, M. Ben-Chen, R. Talmon (2019) Parallel Transport on the Cone Manifold of SPD Matrices for Domain Adaptation IEEE Trans. Sig. Process. 67(7), 1797-1811.","category":"page"},{"location":"introToRiemannianGeometry/#","page":"Intro to Riemannian Geometry","title":"Intro to Riemannian Geometry","text":"T. Yamazaki (2019) The Ando-Hiai inequalities for the solution of the generalized Karcher Equation and related results arXiv:1802.06200v2.","category":"page"}]
}
