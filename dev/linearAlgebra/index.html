<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>linearAlgebra.jl Â· PosDefManifold</title><meta name="title" content="linearAlgebra.jl Â· PosDefManifold"/><meta property="og:title" content="linearAlgebra.jl Â· PosDefManifold"/><meta property="twitter:title" content="linearAlgebra.jl Â· PosDefManifold"/><meta name="description" content="Documentation for PosDefManifold."/><meta property="og:description" content="Documentation for PosDefManifold."/><meta property="twitter:description" content="Documentation for PosDefManifold."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PosDefManifold logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PosDefManifold</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">PosDefManifold Documentation</a></li><li><a class="tocitem" href="../introToRiemannianGeometry/">Intro to Riemannian Geometry</a></li><li><a class="tocitem" href="../MainModule/">MainModule (PosDefManifold.jl)</a></li><li><a class="tocitem" href="../riemannianGeometry/">riemannianGeometry.jl</a></li><li class="is-active"><a class="tocitem" href>linearAlgebra.jl</a><ul class="internal"><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Matrix-normalizations-and-approximations"><span>Matrix normalizations and approximations</span></a></li><li><a class="tocitem" href="#Boolean-functions-of-matrices"><span>Boolean functions of matrices</span></a></li><li><a class="tocitem" href="#Scalar-functions-of-matrices"><span>Scalar functions of matrices</span></a></li><li><a class="tocitem" href="#Diagonal-functions-of-matrices"><span>Diagonal functions of matrices</span></a></li><li><a class="tocitem" href="#Unitary-functions-of-matrices"><span>Unitary functions of matrices</span></a></li><li><a class="tocitem" href="#Matrix-function-of-matrices"><span>Matrix function of matrices</span></a></li><li><a class="tocitem" href="#Spectral-decompositions-of-positive-matrices"><span>Spectral decompositions of positive matrices</span></a></li><li><a class="tocitem" href="#Decompositions-involving-triangular-matrices"><span>Decompositions involving triangular matrices</span></a></li></ul></li><li><a class="tocitem" href="../statistics/">statistics.jl</a></li><li><a class="tocitem" href="../signalProcessing/">signalProcessing.jl</a></li><li><a class="tocitem" href="../test/">test.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>linearAlgebra.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>linearAlgebra.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/PosDefManifold.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/master/docs/src/linearAlgebra.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="linearAlgebra.jl"><a class="docs-heading-anchor" href="#linearAlgebra.jl">linearAlgebra.jl</a><a id="linearAlgebra.jl-1"></a><a class="docs-heading-anchor-permalink" href="#linearAlgebra.jl" title="Permalink"></a></h1><p>This unit contains linear algebra functions useful in relation to the Riemannian  geometry of the manifold of <em>Symmetric Positive Definite (SPD)</em> or  <em>Hermitian Positive Definite (HPD)</em> matrices. In Julia those are <code>Hermitian</code> matrices, see <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p>In general they take a matrix as input (some may take other arrays as input) and are divided in eight categories depending on what kind of functions thay are and what they give as output:</p><table><tr><th style="text-align: left">Category</th><th style="text-align: left">Output</th></tr><tr><td style="text-align: left">1. <a href="#Utilities">Utilities</a></td><td style="text-align: left">- - -</td></tr><tr><td style="text-align: left">2. <a href="#Matrix-normalizations-and-approximations">Matrix normalizations and approximations</a></td><td style="text-align: left">matrix</td></tr><tr><td style="text-align: left">3. <a href="#Boolean-functions-of-matrices">Boolean functions of matrices</a></td><td style="text-align: left">matrix</td></tr><tr><td style="text-align: left">4. <a href="#Scalar-functions-of-matrices">Scalar functions of matrices</a></td><td style="text-align: left">scalar</td></tr><tr><td style="text-align: left">5. <a href="#Diagonal-functions-of-matrices">Diagonal functions of matrices</a></td><td style="text-align: left">diagonal matrix</td></tr><tr><td style="text-align: left">6. <a href="#Unitary-functions-of-matrices">Unitary functions of matrices</a></td><td style="text-align: left">orthogonal/unitary matrix</td></tr><tr><td style="text-align: left">7. <a href="#Matrix-function-of-matrices">Matrix function of matrices</a></td><td style="text-align: left">matrix</td></tr><tr><td style="text-align: left">8. <a href="#Spectral-decompositions-of-positive-matrices">Spectral decompositions of positive matrices</a></td><td style="text-align: left">spectral function of input</td></tr><tr><td style="text-align: left">9. <a href="#Decompositions-involving-triangular-matrices">Decompositions involving triangular matrices</a></td><td style="text-align: left">triangular matrix</td></tr></table><p>â‹…</p><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.typeofMatrix"><code>typeofMatrix</code></a>, <code>typeofMat</code></td><td style="text-align: left">Return the type of the matrix argument</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.typeofVector"><code>typeofVector</code></a>, <code>typeofVec</code></td><td style="text-align: left">Return the type of the matrix vector argument</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.dim"><code>dim</code></a></td><td style="text-align: left">length of the dimensions of matrices and vectors of matrices</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.remove"><code>remove</code></a></td><td style="text-align: left">Remove one or more elements from a vector or one or more</td></tr><tr><td style="text-align: left">columns or rows from a matrix</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.isSquare"><code>isSquare</code></a></td><td style="text-align: left">Return true if matrix arguement is square, false otherwise</td></tr></table><p>â‹…</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.typeofMatrix" href="#PosDefManifold.typeofMatrix"><code>PosDefManifold.typeofMatrix</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function typeofMatrix(
array::Union{AnyMatrix, AnyMatrixVector, AnyMatrixVectorâ‚‚})</code></pre><p><strong>alias</strong>: <code>typeofMat</code></p><p>Return the type of a matrix, either <code>Hermitian</code>, <code>Diagonal</code>, <code>LowerTriangular</code>, or <code>Matrix</code>. Argument <code>array</code> may be a matrix of one of these types, but also one of the following:</p><p><code>â„Vector</code>, <code>â„Vectorâ‚‚</code>, <code>ğ”»Vector</code>, <code>ğ”»Vectorâ‚‚</code>, <code>ğ•ƒVector</code>, <code>ğ•ƒVectorâ‚‚</code>, <code>ğ•„Vector</code>, <code>ğ•„Vectorâ‚‚</code>.</p><p>Those are <a href="../MainModule/#Array-of-Matrices-types">Array of Matrices types</a>. See also <a href="../MainModule/#aliases">aliases</a> for the symbols <code>â„</code>, <code>ğ”»</code>, <code>ğ•ƒ</code> and <code>ğ•„</code>.</p><p>Note that this function is different from Julia function <a href="https://docs.julialang.org/en/v1/base/base/#Core.typeof">typeof</a>, which returns the concrete type (see example below), thus cannot be used for <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
P=randP(3) # generate a 3x3 Hermitian matrix
typeofMatrix(P) # returns `Hermitian`
typeof(P) # returns `Hermitian{Float64,Array{Float64,2}}`
# typecast P as a `Matrix` M
M=Matrix(P)
# typecast M as a matrix of the same type as P and write the result in A
A=typeofMatrix(P)(M)

Pset=randP(3, 4) # generate a set of 4 3x3 Hermitian matrix
# Pset is an â„Vector type
typeofMatrix(Pset) # again returns `Hermitian`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L81-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.typeofVector" href="#PosDefManifold.typeofVector"><code>PosDefManifold.typeofVector</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function typeofVector(
array::Union{AnyMatrix, AnyMatrixVector, AnyMatrixVectorâ‚‚})</code></pre><p><strong>alias</strong>: <code>typeofVec</code></p><p>Return the type of a Vector, either <code>HermitianVector</code>, <code>DiagonalVector</code>, <code>LowerTriangularVector</code>, or <code>MatrixVector</code>. The aliases of those are, respectvely, <code>â„Vector</code>, <code>ğ”»Vector</code>, <code>ğ•ƒVector</code> and <code>ğ•„Vector</code>. Argument <code>array</code> may be a vector of one of these types, but also one of the following:</p><p><code>â„</code>, <code>ğ”»</code>, <code>ğ•ƒ</code> and <code>ğ•„</code>, <code>â„Vectorâ‚‚</code>, <code>ğ”»Vectorâ‚‚</code>, <code>ğ•ƒVectorâ‚‚</code>, <code>ğ•„Vectorâ‚‚</code>.</p><p>See <a href="../MainModule/#aliases">aliases</a> for the symbols <code>â„</code>, <code>ğ”»</code>, <code>ğ•ƒ</code> and <code>ğ•„</code>. The last four are <a href="../MainModule/#Array-of-Matrices-types">Array of Matrices types</a>.</p><p>Note that this function is different from Julia function <a href="https://docs.julialang.org/en/v1/base/base/#Core.typeof">typeof</a> only in that it returns the vector type also if <code>array</code> is not of the <code>â„Vector</code>, <code>ğ”»Vector</code>, <code>ğ•ƒVector</code> or <code>ğ•„Vector</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
P=randP(3, 4) # generate 4 3x3 Hermitian matrix
typeofMatrix(P) # returns `Array{Hermitian,1}`
typeof(P) # also returns `Array{Hermitian,1}`

typeofMatrix(P[1]) # returns `Array{Hermitian,1}`
typeof(P[1]) # returns `Hermitian{Float64,Array{Float64,2}}`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L127-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.dim" href="#PosDefManifold.dim"><code>PosDefManifold.dim</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) function dim(X::AnyMatrix, [d])
(2) function dim(vector::AnyMatrixVector, [d])
(3) function dim(vectorâ‚‚::AnyMatrixVectorâ‚‚, [d])</code></pre><p>(1) <span>$X$</span> is a real or complex <code>Matrix</code>, <code>Diagonal</code>, <code>LowerTriangular</code> or <code>Hermitian</code> matrix. Return a 2-tuple containing the dimensions of <span>$X$</span>, which is two times the same dimension for all possible types of <span>$X$</span> with the exception of the <code>Matrix</code> type, which can be rectangular. Optionally you can specify a dimension (1 or 2) to get just the length of that dimension.</p><p>(2) <code>vector</code> is an ğ•„Vector, ğ”»Vector, ğ•ƒVector or â„Vector type (see <a href="../MainModule/#AnyMatrixVector-type">AnyMatrixVector type</a>). Return a 3-tuple containing the number of matrices it holds (dimension 1) and their dimensions (dimension 2 and 3). Optionally you can specify a dimension (1, 2, or 3) to get just the length of that dimension.</p><p>(3) <code>vectorâ‚‚</code> is an ğ•„Vectorâ‚‚, ğ”»Vectorâ‚‚, ğ•ƒVectorâ‚‚ or â„Vectorâ‚‚ type (see <a href="../MainModule/#AnyMatrixVector-type">AnyMatrixVector type</a>). Return a 4-tuple containing</p><ul><li>the number of vectors of matrices it holds (dimension 1),</li><li>a vector holding the number of matrices in each vector of matrices (dimensions 2),</li><li>the two dimensions of the matrices (dimension 3 and 4).</li></ul><p>Optionally you can specify a dimension (1, 2, 3 or 4) to get just the length of that dimension.</p><p><code>vector</code> and <code>vectorâ‚‚</code> are <a href="../MainModule/#Array-of-Matrices-types">Array of Matrices types</a>. See also <a href="../MainModule/#aliases">aliases</a> for the symbols <code>â„</code>, <code>ğ”»</code>, <code>ğ•ƒ</code> and <code>ğ•„</code>.</p><div class="admonition is-info" id="Nota-Bene-79ae39a5bc47b020"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-79ae39a5bc47b020" title="Permalink"></a></header><div class="admonition-body"><p>If you specify a dimension and this is out of the valid range, the function returns zero.</p><p>Both the <code>vector</code>(2) and the <code>vectorâ‚‚</code>(3) object are meant to hold matrices living in the same manifold, therefore it is assumed that all matrices they holds are of the same dimension. The dimensions of the matrices are retrived from</p><ul><li>the first matrix in <code>vector</code>(2),</li><li>the first matrix in the first vector of <code>vectorâ‚‚</code>(3).</li></ul></div></div><p>This function replaces Julia <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.size">size</a> function, which cannot be used to retrive dimension for matrix vectors. It is not possible to overload the <code>size</code> function for matrix vectors since this causes problems to other Julia functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
# (1)
M=randn(3, 4) # generate a 3x4 `Matrix`
dim(M) # returns (3, 4)
dim(M, 1) # returns 3
dim(M, 2) # returns 4
dim(M, 3) # out of range: returns 0

# (2)
Pset=randP(3, 4) # generate an â„Vector holding 4 3x3 Hermitian matrices
dim(Pset) # returns (4, 3, 3)
dim(Pset, 1) # returns 4
dim(Pset, 2) # returns 3
dim(Pset, 3) # returns 3

# (3)
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4)
# Generate a set of 40 random 4x4 SPD matrices
Qset=randP(3, 40)
A=â„Vectorâ‚‚([Pset, Qset])
dim(A) # return (2, [4, 40], 3, 3)
dim(A, 1) # return 2
dim(A, 2) # return [4, 40]
dim(A, 2)[1] # return 4
dim(A, 3) # return 3
dim(A, 4) # return 3
dim(A, 5) # out of range: return 0

# note: to create an â„Vectorâ‚‚ object holding k â„Vector objects use
sets=â„Vectorâ‚‚(undef, k) # and then fill them</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L170-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.remove" href="#PosDefManifold.remove"><code>PosDefManifold.remove</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function remove(X::Union{Vector, Matrix}, what::Union{Int, Vector{Int}};
				dims=1)</code></pre><p>Remove one or more elements from a vector or one or more columns or rows from a matrix.</p><p>If <code>X</code> is a Matrix, <code>dims</code>=1 (default) remove rows, <code>dims</code>=2 remove columns.</p><p>If <code>X</code> is a Vector, <code>dims</code> has no effect.</p><p>The second argument is either an integer or a vector of integers.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a=randn(5)
b=remove(a, 2)
b=remove(a, collect(1:3)) # remove rows 1 to 3
A=randn(3, 3)
B=remove(A, 2)
B=remove(A, 2; dims=2)
A=randn(5, 5)
B=remove(A, collect(1:2:5)) # remove rows 1, 3 and 5
C=remove(A, [1, 4])
A=randn(10, 10)
A=remove(A, [collect(2:3); collect(8:10)]; dims=2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L276-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.isSquare" href="#PosDefManifold.isSquare"><code>PosDefManifold.isSquare</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function isSquare(X::Matrix)=size(X, 1)==size(X, 2)</code></pre><p>Return true if matrix <code>X</code> is square, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L319-L323">source</a></section></article><h2 id="Matrix-normalizations-and-approximations"><a class="docs-heading-anchor" href="#Matrix-normalizations-and-approximations">Matrix normalizations and approximations</a><a id="Matrix-normalizations-and-approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-normalizations-and-approximations" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.det1"><code>det1</code></a></td><td style="text-align: left">Normalize the determinant</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.tr1"><code>tr1</code></a></td><td style="text-align: left">Normalize the trace</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.nearestPosDef"><code>nearestPosDef</code></a></td><td style="text-align: left">Nearest Symmetric/Hermitian Positive Semi-definite matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.nearestOrthogonal"><code>nearestOrthogonal</code></a> <code>nearestOrth</code></td><td style="text-align: left">Nearest Orthogonal matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.normalizeCol!"><code>normalizeCol!</code></a></td><td style="text-align: left">Normalize one or more columns</td></tr></table><p>â‹…</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.det1" href="#PosDefManifold.det1"><code>PosDefManifold.det1</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function det1(X::AnyMatrix; &lt;tol::Real=0.&gt;)</code></pre><p>Return the argument matrix <span>$X$</span> normalized so as to have <em>unit determinant</em>. For square positive definite matrices this is the best approximant from the set of matrices in the <a href="https://bit.ly/2W5jDZ6">special linear group</a> - see Bhatia and Jain (2014)<a href="../introToRiemannianGeometry/">ğŸ“</a>.</p><p><span>$X$</span> can be a real or complex <code>Diagonal</code>, <code>LowerTriangular</code>, <code>Matrix</code>, or <code>Hermitian</code> matrix. (see <a href="../MainModule/#AnyMatrix-type">AnyMatrix type</a>)</p><p>If the determinant is not greater than <code>tol</code> (which defalts to zero) a warning is printed and <span>$X$</span> is returned.</p><div class="admonition is-info" id="Nota-Bene-daa76e03969a62f3"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-daa76e03969a62f3" title="Permalink"></a></header><div class="admonition-body"><p>This function is meant for positive definite matrices. Julia may throws an error while computing the determinant if the matrix is defective.</p></div></div><p><strong>See</strong> <a href="https://bit.ly/2Y4MnTF">Julia det function</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.tr1"><code>tr1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
P=randP(5) # generate a random real positive definite matrix 5x5
Q=det1(P)
det(Q) # must be 1
# using a tolerance
Q=det1(P; tol=1e-12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L331-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.tr1" href="#PosDefManifold.tr1"><code>PosDefManifold.tr1</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tr1(X::AnyMatrix; tol::Real=0.)</code></pre><p>Return the argument matrix <span>$X$</span> normalized so as to have <em>unit trace</em>.</p><p><span>$X$</span> can be a real or complex <code>Diagonal</code>, <code>LowerTriangular</code>, <code>Matrix</code> or <code>Hermitian</code> matrix (see <a href="../MainModule/#AnyMatrix-type">AnyMatrix type</a>). Its trace must be real. If the absolute value of its imaginary part is greater than <code>tol</code> (which defalts to zero) a warning is printed and <span>$X$</span> is returned. Also, if the trace is not greater than <code>tol</code> a warning is printed and <span>$X$</span> is returned.</p><p><strong>See</strong>: <a href="https://bit.ly/2HoOLiM">Julia trace function</a>.</p><p><strong>See also</strong>: <a href="#LinearAlgebra.tr"><code>tr</code></a>, <a href="#PosDefManifold.det1"><code>det1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold

P=randP(5) # generate a random real positive definite matrix 5x5
Q=tr1(P)
tr(Q)  # must be 1
# using a tolerance
Q=tr1(P; tol=1e-12)

Pc=randP(ComplexF64, 5) # generate a random real positive definite matrix 5x5
Qc=tr1(Pc)
tr(Qc)  # must be 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L373-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.nearestPosDef" href="#PosDefManifold.nearestPosDef"><code>PosDefManifold.nearestPosDef</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nearestPosDef(X::Union{ğ”», ğ•„}; tol::Real=0.)</code></pre><p>Return the nearest symmetric/Hermitian positive semi-definite matrix of a diagonal or of an arbitary square matrix <code>X</code> according to the Frobenius norm. If the eigenvalues of the symmetric part of <code>X</code> are all non-negative, the result is positive definite and will be flagged as <code>Hermitian</code>, otherwise it is positive semi-definite and will not be flagged. The nearest matrix is given by</p><p><span>$(Y+H)/2$</span></p><p>where</p><p><span>$Y=(X+X^H)/2$</span></p><p>is the symmetric part of <span>$X$</span>, and <span>$H$</span> is the symmetric polar factor of <span>$Y$</span>. See Higham(1988)<a href="../introToRiemannianGeometry/">ğŸ“</a> for details and for the way it is computed.</p><p><strong>See also</strong>: <a href="#PosDefManifold.det1"><code>det1</code></a>, <a href="../riemannianGeometry/#PosDefManifold.procrustes"><code>procrustes</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
X=randn(5, 5) # generate an arbitrary 5x5 matrix
S=nearestPosDef(X)

P=randP(5) # generate a random real positive definite 5x5 matrix
S=nearestPosDef(Matrix(P)) # typecasting an Hermitian matrix as a `Matrix`
# Since P is a positive definite matrix S must be equal to P
S â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L427-L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.nearestOrthogonal" href="#PosDefManifold.nearestOrthogonal"><code>PosDefManifold.nearestOrthogonal</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nearestOrthogonal(X::AnyMatrix)</code></pre><p><strong>alias</strong>: <code>nearestOrth</code></p><p>Return the nearest orthogonal matrix of a square <code>Hermitian</code>, <code>LowerTriangular</code>, <code>Diagonal</code> or generic <code>Matrix</code> <code>X</code> (see <a href="../MainModule/#AnyMatrix-type">AnyMatrix type</a>). This is given by</p><p><span>$UV^H$</span>,</p><p>where</p><p><span>$\textrm(SVD)=UÎ›V^H$</span>.</p><p>If <code>X</code> is <code>Diagonal</code>, return <code>X</code>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.nearestPosDef"><code>nearestPosDef</code></a>, <a href="../riemannianGeometry/#PosDefManifold.procrustes"><code>procrustes</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
U=nearestOrth(randn(5, 5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L477-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.normalizeCol!" href="#PosDefManifold.normalizeCol!"><code>PosDefManifold.normalizeCol!</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) normalizeCol!(X::ğ•„{T}, j::Int)
(2) normalizeCol!(X::ğ•„{T}, j::Int, by::Number)
(3) normalizeCol!(X::ğ•„{T}, range::UnitRange)
(4) normalizeCol!(X::ğ•„{T}, range::UnitRange, by::Number)
for all above: where T&lt;:RealOrComplex</code></pre><p>Given a <code>Matrix</code> type <span>$X$</span> comprised of real or complex elements,</p><ul><li>(1) normalize the <span>$j^{th}$</span> column to unit norm</li><li>(2) divide the elements of the <span>$j^{th}$</span> column by number <span>$by$</span></li><li>(3) normalize the columns in <span>$range$</span> to unit norm</li><li>(4) divide the elements of columns in <span>$range$</span>  by number <span>$by$</span>.</li></ul><p><span>$by$</span> is a number of abstract supertype <a href="https://bit.ly/2JwXjGr">Number</a>. It should be an integer, real or complex number. For efficiency, it should be of the same type as the elements of <span>$X$</span>.</p><p><span>$range$</span> is a <a href="https://bit.ly/2HSfK5J">UnitRange</a> type.</p><p>Methods (1) and (3) call the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.BLAS.nrm2">BLAS.nrm2</a> routine for computing the norm of concerned columns. See <a href="../MainModule/#Threads">Threads</a>.</p><div class="admonition is-info" id="Nota-Bene-5d842d75ef075d99"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-5d842d75ef075d99" title="Permalink"></a></header><div class="admonition-body"><p>Julia does not allow normalizing the columns of <code>Hermitian</code> matrices. If you want to call this function for an <code>Hermitian</code> matrix see <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p></div></div><p><strong>See</strong> <a href="https://bit.ly/2TaAkR0">norm</a> and also <a href="https://bit.ly/2I1Vgrg">randn</a> for the example below.</p><p><strong>See also</strong>: <a href="#PosDefManifold.colNorm"><code>colNorm</code></a>, <a href="#PosDefManifold.colProd"><code>colProd</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
X=randn(10, 20)
normalizeCol!(X, 2)                  # (1) normalize columns 2
normalizeCol!(X, 2, 10.0)            # (2) divide columns 2 by 10.0
normalizeCol!(X, 2:4)                # (3) normalize columns 2 to 4
X=randn(ComplexF64, 10, 20)
normalizeCol!(X, 3)                  # (1) normalize columns 3
normalizeCol!(X, 3:6, (2.0 + 0.5im)) # (4) divide columns 3 to 5 by (2.0 + 0.5im)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L516-L561">source</a></section></article><h2 id="Boolean-functions-of-matrices"><a class="docs-heading-anchor" href="#Boolean-functions-of-matrices">Boolean functions of matrices</a><a id="Boolean-functions-of-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Boolean-functions-of-matrices" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.ispos"><code>ispos</code></a></td><td style="text-align: left">Check whether a real vector or diagonal matrix are comprised of all positive elements</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.ispos" href="#PosDefManifold.ispos"><code>PosDefManifold.ispos</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    (1) ispos(Î»::Vector{T};
	&lt;
	tol::Real=0,
	rev=true,
	ğŸ””=true,
	msg=&quot;&quot;&gt;)

    (2) ispos(Î›::ğ”»{T};
	&lt; same optional keyword arguments as in (1) &gt; )

	for all above: where T&lt;:Real</code></pre><p>Return <span>$true$</span> if all numbers in (1) real vector <span>$Î»$</span> or in (2) real <code>Diagonal</code> matrix <span>$Î›$</span> are not inferior to <span>$tol$</span>, otherwise return <span>$false$</span>. This is used, for example, in spectral functions to check that all eigenvalues are positive.</p><div class="admonition is-info" id="Nota-Bene-aa7ab1179b1c2d03"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-aa7ab1179b1c2d03" title="Permalink"></a></header><div class="admonition-body"><p><span>$tol$</span> defaults to the square root of <code>Base.eps</code> of the type of <span>$Î»$</span> (1)  or <span>$Î›$</span> (2). This corresponds to requiring positivity beyond about half of  the significant digits.</p></div></div><p>The following are <em>&lt;optional keyword arguments&gt;</em>:</p><ul><li>If <span>$rev=true$</span> the (1) elements in <span>$Î»$</span> or (2) the diagonal elements</li></ul><p>in <span>$Î›$</span> will be chacked in reverse order. This is done for allowing a very fast check when the elements are sorted and it is known from where is best to start checking.</p><p>If the result is <span>$false$</span>:</p><ul><li>if <span>$ğŸ””=true$</span> a bell character will be printed. In most systems this will ring a bell on the computer.</li><li>if string <span>$msg$</span> is provided, a warning will print <span>$msg$</span> followed by:</li></ul><p>&quot;at position <em>pos</em>&quot;, where <em>pos</em> is the position where the first non-positive element has been found.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
a=[1, 0, 2, 8]
ispos(a, msg=&quot;non-positive element found&quot;)

# it will print:
# â”Œ Warning: non-positive element found at position 2
# â”” @ [here julie will point to the line of code issuing the warning]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L584-L631">source</a></section></article><h2 id="Scalar-functions-of-matrices"><a class="docs-heading-anchor" href="#Scalar-functions-of-matrices">Scalar functions of matrices</a><a id="Scalar-functions-of-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-functions-of-matrices" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.colProd"><code>colProd</code></a></td><td style="text-align: left">Sum of products of the elements in two columns</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a>, <code>ss</code></td><td style="text-align: left">Sum of squares of all elements or of specified columns</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.sumOfSqrDiag"><code>sumOfSqrDiag</code></a>, <code>ssd</code></td><td style="text-align: left">Sum of squares of the diagonal elements</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.colNorm"><code>colNorm</code></a></td><td style="text-align: left">Eucliden norm of a column</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.sumOfSqrTril"><code>sumOfSqrTril</code></a>, <code>sst</code></td><td style="text-align: left">Sum of squares of the lower triangle elements up to a given underdiagonal</td></tr><tr><td style="text-align: left"><a href="#LinearAlgebra.tr"><code>tr</code></a></td><td style="text-align: left">Fast trace of the product of two Hermitian matrices</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.quadraticForm"><code>quadraticForm</code></a>, <code>qf</code></td><td style="text-align: left">Fast quadratic form</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.fidelity"><code>fidelity</code></a></td><td style="text-align: left">(Quantum) Fidelity of two positive matrices</td></tr></table><p>â‹…</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.colProd" href="#PosDefManifold.colProd"><code>PosDefManifold.colProd</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) colProd(X::Union{ğ•„{T}, â„{T}}, j::Int, l::Int)
(2) colProd(X::Union{ğ•„{T}, â„{T}}, Y::Union{ğ•„{T}, â„{T}}, j::Int, l::Int)
for all above: where T&lt;:RealOrComplex</code></pre><p>(1) Given a real or complex <code>Matrix</code> or <code>Hermitian</code> matrix <span>$X$</span>, return the dot product of the <span>$j^{th}$</span> and <span>$l^{th}$</span> columns, defined as,</p><p><span>$\sum_{i=1}^{r} \big(x_{ij}^*x_{il}\big),$</span></p><p>where <span>$r$</span> is the number of rows of <span>$X$</span> and <span>$^*$</span> denotes complex conjugate (nothing if the matrix is real).</p><p>(2) Given real or complex <code>Matrix</code> or <code>Hermitian</code> matrices <span>$X$</span> and <span>$Y$</span>, return the dot product of the <span>$j^{th}$</span> column of <span>$X$</span> and the <span>$l^{th}$</span> column of <span>$Y$</span>, defined as,</p><p><span>$\sum_{i=1}^{r} \big(x_{ij}^*y_{il}\big),$</span></p><p>where <span>$r$</span> is the number of rows of <span>$X$</span> and of <span>$Y$</span> and <span>$^*$</span> is as above.</p><div class="admonition is-info" id="Nota-Bene-f08069bb6036f0f0"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-f08069bb6036f0f0" title="Permalink"></a></header><div class="admonition-body"><p><span>$X$</span> and of <span>$Y$</span> may have a different number of columns, but must have the same number of rows.</p></div></div><p>Arguments <span>$j$</span> and <span>$l$</span> must be positive integers in range</p><ul><li>(1) <code>j,l in 1:size(X, 2)</code>,</li><li>(2) <code>j in 1:size(X, 2), l in 1:size(Y, 2)</code>.</li></ul><p><strong>See also</strong>: <a href="#PosDefManifold.normalizeCol!"><code>normalizeCol!</code></a>, <a href="#PosDefManifold.colNorm"><code>colNorm</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
X=randn(10, 20)
p=colProd(X, 1, 3)
Y=randn(10, 30)
q=colProd(X, Y, 2, 25)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L662-L702">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.sumOfSqr" href="#PosDefManifold.sumOfSqr"><code>PosDefManifold.sumOfSqr</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) sumOfSqr(A::Array)
(2) sumOfSqr(H::â„{T})
(3) sumOfSqr(L::ğ•ƒ{T})
(4) sumOfSqr(D::ğ”»{T})
(5) sumOfSqr(X::Union{ğ•„{T}, â„{T}}, j::Int)
(6) sumOfSqr(X::Union{ğ•„{T}, â„{T}}, range::UnitRange)
for (1)-(6) above: where T&lt;:RealOrComplex</code></pre><p><strong>alias</strong>: <code>ss</code></p><p>Return</p><ul><li>(1) the sum of squares of the elements in an array <span>$A$</span> of any dimensions.</li><li>(2) as in (1), but for an <code>Hermitian</code> matrix <span>$H$</span>, using only the lower triangular part.</li><li>(3) as in (1), but for a <code>LowerTriangular</code> matrix <span>$L$</span>.</li><li>(4) as in (1), but for a <code>Diagonal</code> matrix <span>$D$</span> (sum of squares of diagonal elements).</li><li>(5) the sum of square of the <span>$j^{th}$</span> column of a <code>Matrix</code> or <code>Hermitian</code> <span>$X$</span>.</li><li>(6) the sum of square of the columns of a <code>Matrix</code> or <code>Hermitian</code> <span>$X$</span> in a given range.</li></ul><p>All methods support real and complex matrices.</p><p>Only method (1) works for arrays of any dimensions.</p><p>Methods (1)-(4) return the square of the <a href="https://bit.ly/2Fi10eH">Frobenius norm</a>.</p><p>For method (5), <span>$j$</span> is a positive integer in range <code>1:size(X, 1)</code>.</p><p>For method (6), <span>$range$</span> is a <a href="https://bit.ly/2HDoFbk">UnitRange type</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.colNorm"><code>colNorm</code></a>, <a href="#PosDefManifold.sumOfSqrDiag"><code>sumOfSqrDiag</code></a>, <a href="#PosDefManifold.sumOfSqrTril"><code>sumOfSqrTril</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
X=randn(10, 20)
sum2=sumOfSqr(X)        # (1) sum of squares of all elements
sum2=sumOfSqr(X, 1)     # (2) sum of squares of elements in column 1
sum2=sumOfSqr(X, 2:4)   # (3) sum of squares of elements in column 2 to 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L744-L784">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.sumOfSqrDiag" href="#PosDefManifold.sumOfSqrDiag"><code>PosDefManifold.sumOfSqrDiag</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sumOfSqrDiag(X::AnyMatrix)</code></pre><p><strong>alias</strong>: <code>ssd</code></p><p>Sum of squares of the diagonal elements in real or complex <code>Matrix</code>, <code>Diagonal</code>, <code>Hermitian</code> or <code>LowerTriangular</code> matrix <span>$X$</span>. If <span>$X$</span> is rectangular (which can be only if it is of the <code>Matrix</code> type), the main diagonal is considered.</p><p><strong>See</strong> <a href="../MainModule/#AnyMatrix-type">AnyMatrix type</a></p><p><strong>See also</strong>: <a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a>, <a href="#PosDefManifold.sumOfSqrTril"><code>sumOfSqrTril</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
X=randn(10, 20)
sumDiag2=sumOfSqrDiag(X) # (1)
sumDiag2=sumOfSqrDiag(ğ”»(X)) # (2)
# ğ”»=LinearAlgebra.Diagonal is declated in the main module</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L816-L839">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.colNorm" href="#PosDefManifold.colNorm"><code>PosDefManifold.colNorm</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">colNorm(X::Union{ğ•„{T}, â„{T}}, j::Int) where T&lt;:RealOrComplex</code></pre><p>Given a real or complex <code>Matrix</code> or <code>Hermitian</code> matrix <span>$X$</span>, return the Euclidean norm of its <span>$j^{th}$</span> column.</p><p>This function calls the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.BLAS.nrm2">BLAS.nrm2</a> routine. See <a href="../MainModule/#Threads">Threads</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.normalizeCol!"><code>normalizeCol!</code></a>, <a href="#PosDefManifold.colProd"><code>colProd</code></a>, <a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
X=randn(10, 20)
normOfSecondColumn=colNorm(X, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L720-L739">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.sumOfSqrTril" href="#PosDefManifold.sumOfSqrTril"><code>PosDefManifold.sumOfSqrTril</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sumOfSqrTril(X::AnyMatrix, k::Int=0)</code></pre><p><strong>alias</strong>: <code>sst</code></p><p>Given a real or complex <code>Matrix</code>, <code>Diagonal</code>, <code>Hermitian</code> or <code>LowerTriangular</code> matrix <span>$X$</span> (see <a href="../MainModule/#AnyMatrix-type">AnyMatrix type</a>), return the sum of squares of the elements in its lower triangle up to the <span>$k^{th}$</span> underdiagonal.</p><p><code>Matrix</code> <span>$X$</span> may be rectangular.</p><p><span>$k$</span> must be in range</p><ul><li><code>1-size(X, 1):c-1</code> for <span>$X$</span> <code>Matrix</code>, <code>Diagonal</code> or <code>Hermitian</code>,</li><li><code>1-size(X, 1):0</code> for <span>$X$</span> <code>LowerTriangular</code>.</li></ul><p>For <span>$X$</span> <code>Diagonal</code> the result is</p><ul><li><span>$0$</span> if <span>$k&lt;0$</span>,</li><li>the sum of the squares of the diagonal elements otherwise.</li></ul><p>See julia <a href="https://bit.ly/2Tbx8o7">tril(M, k::Integer)</a> function for numbering of diagonals.</p><p><strong>See also</strong>: <a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a>, <a href="#PosDefManifold.sumOfSqrDiag"><code>sumOfSqrDiag</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
A=[4. 3.; 2. 5.; 1. 2.]
#3Ã—2 Array{Float64,2}:
# 4.0  3.0
# 2.0  5.0
# 1.0  2.0

s=sumOfSqrTril(A, -1)
# 9.0 = 1Â²+2Â²+2Â²

s=sumOfSqrTril(A, 0)
# 50.0 = 1Â²+2Â²+2Â²+4Â²+5Â²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L848-L889">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) tr(P::â„{T}, Q::â„{T})
(2) tr(P::â„{T}, M::ğ•„{T})
(3) tr(D::ğ”»{T}, H::Union{â„{T}, ğ•„{T}})
(4) tr(H::Union{â„{T}, ğ•„{T}}, D::ğ”»{T})
for all above: where T&lt;:RealOrComplex</code></pre><p>Given (1) two <code>Hermitian</code> positive definite matrix <span>$P$</span> and <span>$Q$</span>, return the trace of the product <span>$PQ$</span>. This is real even if <span>$P$</span> and <span>$Q$</span> are complex.</p><p><span>$P$</span> must always be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p>In (2) <span>$Q$</span> is a <code>Matrix</code> object, in which case return</p><ul><li>a real trace if the product <span>$PQ$</span> is real or if it has all positive real eigenvalues.</li><li>a complex trace if the product <span>$PQ$</span> is not real and has complex eigenvalues.</li></ul><p>Methods (3) and (4) return the trace of the product <span>$DH$</span> or <span>$HD$</span>, where <span>$D$</span> is a <code>Diagonal</code> matrix and <span>$H$</span> an <span>$Hermitian$</span> or <span>$Matrix$</span> object. The result is of the same type as the input matrices.</p><p>For all methods all arguments must be of the same type.</p><p><strong>Math</strong></p><p>Let <span>$P$</span> and <span>$Q$</span> be <code>Hermitian</code> matrices, using the properties of the trace (e.g., the cyclic property and the similarity invariance) you can use this function to fast compute the trace of several expressions. For example:</p><p><span>$\textrm{tr}(PQ)=\textrm{tr}(P^{1/2}QP^{1/2})$</span></p><p>and</p><p><span>$\textrm{tr}(PQP)=\textrm{tr}(P^{2}Q)$</span> (see example below).</p><p><strong>See</strong>: <a href="https://bit.ly/2HoOLiM">trace</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.DiagOfProd"><code>DiagOfProd</code></a>, <a href="#PosDefManifold.tr1"><code>tr1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
P=randP(ComplexF64, 5) # generate a random complex positive definite matrix 5x5
Q=randP(ComplexF64, 5) # generate a random complex positive definite matrix 5x5
tr(P, Q) â‰ˆ tr(P*Q) ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
tr(P, Q) â‰ˆ tr(sqrt(P)*Q*sqrt(P)) ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
tr(sqr(P), Q) â‰ˆ tr(P*Q*P) ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L903-L953">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.quadraticForm" href="#PosDefManifold.quadraticForm"><code>PosDefManifold.quadraticForm</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) quadraticForm(v::Vector{T}, P::â„{T}) where T&lt;:Real
(2) quadraticForm(v::Vector{T}, L::ğ•ƒ{T}) where T&lt;:Real
(3) quadraticForm(v::Vector{T}, X::ğ•„{T}, forceLower::Bool=false) where T&lt;:Real
(4) quadraticForm(v::Vector{S}, X::Union{ğ•„{S}, â„{S}, ğ•ƒ{S}}) where S&lt;:Complex</code></pre><p><strong>alias</strong>: <code>qf</code></p><p>(1) Given a real vector <span>$v$</span> and a real <code>Hermitian</code> matrix <span>$P$</span>, compute the quadratic form</p><p><span>$v^TPv$</span>,</p><p>where the superscript <em>T</em> denotes transpose. It uses only the lower triangular part of <span>$P$</span>.</p><p>(2) As in (1), given a real vector <span>$v$</span> and a <code>LowerTriangular</code> matrix <span>$L$</span>.</p><p>(3) As in (1), given a real vector <span>$v$</span> and a real generic <code>Matrix</code> <span>$M$</span>, if <code>forceLower=true</code>. If <code>forceLower=false</code>, the product <span>$v^TMv$</span> is evaluated instead using the whole matrix <span>$M$</span>.</p><p>(4) Quadratic form <span>$v^HPv$</span>, where superscript <em>H</em> denotes complex conjugate and transpose, for a complex vector <code>v</code> and a complex <code>Matrix</code>, <code>LowerTrianglar</code> or <code>Hermitian</code> matrix. The whole matrix is used.</p><p><strong>Math</strong></p><p>For <span>$v$</span> and <span>$X$</span> real and <span>$X$</span> symmetric, the quadratic form is</p><p><span>$\sum_i(v_i^2x_{ii})+\sum_{i&gt;j}(2v_iv_jx_{ij})$</span>.</p><p>For <span>$L$</span> lower triangular is</p><p><span>$\sum_i(v_i^2x_{ii})+\sum_{i&gt;j}(v_iv_jx_{ij})$</span>.</p><p>These formula are used in methods (1), (2) and (3).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
P=randP(5) # generate a random real positive definite matrix 5x5
v=randn(5)
q1=quadraticForm(v, P) # or q1=qf(v, P)
q2=v&#39;*P*v
q1 â‰ˆ q2 ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L979-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.fidelity" href="#PosDefManifold.fidelity"><code>PosDefManifold.fidelity</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fidelity(P::â„{T}, Q::â„{T}) where T&lt;:RealOrComplex</code></pre><p>Given two positive definte <code>Hermitian</code> matrices <span>$P$</span> and <span>$Q$</span>, return their <em>fidelity</em>:</p><p><span>$tr\big(P^{1/2}QP^{1/2}\big)^{1/2}.$</span></p><p>This is used in quantum physics and is related to the <a href="../introToRiemannianGeometry/#Wasserstein">Wasserstein</a> metric. See for example Bhatia, Jain and Lim (2019b)<a href="../introToRiemannianGeometry/">ğŸ“</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
P=randP(5);
Q=randP(5);
f=fidelity(P, Q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1073-L1092">source</a></section></article><h2 id="Diagonal-functions-of-matrices"><a class="docs-heading-anchor" href="#Diagonal-functions-of-matrices">Diagonal functions of matrices</a><a id="Diagonal-functions-of-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonal-functions-of-matrices" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.fDiag"><code>fDiag</code></a>, <code>ğ‘“ğ”»</code></td><td style="text-align: left">Elemen-wise functions of matrix diagonals</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.DiagOfProd"><code>DiagOfProd</code></a>, <code>dop</code></td><td style="text-align: left">Diagonal of the product of two matrices</td></tr></table><p>â‹…</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.fDiag" href="#PosDefManifold.fDiag"><code>PosDefManifold.fDiag</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fDiag(func::Function, X::AnyMatrix, k::Int=0)</code></pre><p><strong>alias</strong>: <code>ğ‘“ğ”»</code></p><p>Applies function <code>func</code> element-wise to the elements of the <span>$k^{th}$</span> diagonal of real or complex <code>Diagonal</code>, <code>LowerTriangular</code>, <code>Matrix</code> or <code>Hermitian</code> matrix <span>$X$</span> and return a diagonal matrix with these elements. <span>$X$</span> must be square in all cases, but for the ğ•„=<code>Matrix</code> type argument, in which case it may be of dimension <em>râ‹…c</em>, with <em>r â‰  c</em>.</p><p>See julia <a href="https://bit.ly/2Tbx8o7">tril(M, k::Integer)</a> function for numbering of diagonals.</p><p>Bt default the main diagonal is considered.</p><ul><li>If <span>$X$</span> is <code>Diagonal</code>, <span>$k$</span> is set automatically to zero (main diagonal).</li><li>If <span>$X$</span> is <code>LowerTriangular</code>, <span>$k$</span> cannot be positive.</li></ul><p>Note that if <span>$X$</span> is rectangular the dimension of the result depends on the size of <span>$X$</span> and on the chosen diagonal. For example,</p><ul><li><em>r â‰  c</em> and <span>$k$</span>=0 (main diagonal), the result will be of dimension min<em>(r,c)</em>â‹…<em>min(r,c)</em>,</li><li><span>$X$</span> <em>3â‹…4</em> and <span>$k=-1$</span>, the result will be <em>2â‹…2</em>,</li><li><span>$X$</span> <em>3â‹…4</em> and <span>$k=1$</span>, the result will be <em>3â‹…3</em>, etc.</li></ul><div class="admonition is-info" id="Nota-Bene-bc973dc13b5aa8c0"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-bc973dc13b5aa8c0" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>func</code> must support the <code>func.</code> syntax and therefore must be able to apply element-wise to the elements of the chosen diagonal (this includes <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions-1">anonymous functions</a>). If the input matrix is complex, the function <code>func</code> must be able to support complex arguments.</p></div></div><p><strong>See also</strong>: <a href="#PosDefManifold.DiagOfProd"><code>DiagOfProd</code></a>, <a href="#LinearAlgebra.tr"><code>tr</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
P=randP(5) # use P=randP(ComplexF64, 5) for generating an Hermitian matrix

# diagonal matrix with the inverse of the first sub-diagonal of P
D=fDiag(inv, P, -1)

(Î›, U) = evd(P) # Î› holds the eigenvalues of P, see evd

# diagonal matrix with the log of the eigenvalues
Î”=fDiag(log, Î›)

# using an anonymous function for the square of the eigenvalues
Î”=fDiag(x-&gt;x^2, Î›)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1102-L1153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.DiagOfProd" href="#PosDefManifold.DiagOfProd"><code>PosDefManifold.DiagOfProd</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagOfProd(P::â„{T}, Q::â„{T}) where T&lt;:RealOrComplex</code></pre><p><strong>alias</strong>: <code>dop</code></p><p>Return the <code>Diagonal</code> matrix holding the diagonal of the product <span>$PQ$</span> of two <code>Hermitian</code> matrices <code>P</code> and <code>Q</code>. Only the diagoanl part of the product is computed.</p><p><strong>See also</strong>: <a href="#LinearAlgebra.tr"><code>tr</code></a>, <a href="#PosDefManifold.fDiag"><code>fDiag</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold, LinearAlgebra
P, Q=randP(5), randP(5)
DiagOfProd(P, Q)â‰ˆDiagonal(P*Q) ? println(&quot;â­ &quot;) : println(&quot;â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1168-L1186">source</a></section></article><h2 id="Unitary-functions-of-matrices"><a class="docs-heading-anchor" href="#Unitary-functions-of-matrices">Unitary functions of matrices</a><a id="Unitary-functions-of-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-functions-of-matrices" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.mgs"><code>mgs</code></a></td><td style="text-align: left">Modified Gram-Schmidt orthogonalization</td></tr></table><p>â‹…</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.mgs" href="#PosDefManifold.mgs"><code>PosDefManifold.mgs</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mgs(X::ğ•„{T}, numCol::Int=0) where T&lt;:RealOrComplex</code></pre><p>Modified (stabilized) <a href="https://bit.ly/2YE6zvy">Gram-Schmidt orthogonalization</a> of the columns of square or tall matrix <span>$X$</span>, which can be comprised of real or complex elements. The orthogonalized <span>$X$</span> is returned by the function. <span>$X$</span> is not changed.</p><p>All columns are orthogonalized by default. If instead argument <code>numCol</code> is provided, then only the first <code>numCol</code> columns of <span>$X$</span> are orthogonalized. In this case only the firt <code>numCol</code> columns will be returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
X=randn(10, 10);
U=mgs(X)        # result is 10â‹…10
U=mgs(X, 3)     # result is 10â‹…3
U&#39;*U â‰ˆ I ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
# julia undertands also:
U&#39;U â‰ˆ I ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1196-L1219">source</a></section></article><h2 id="Matrix-function-of-matrices"><a class="docs-heading-anchor" href="#Matrix-function-of-matrices">Matrix function of matrices</a><a id="Matrix-function-of-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-function-of-matrices" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.fVec"><code>fVec</code></a></td><td style="text-align: left">General function for multi-threaded computation of means and sums of matrix vectors</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.congruence"><code>congruence</code></a>, <code>cong</code></td><td style="text-align: left">Compute congruent transformations</td></tr></table><p>â‹…</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.fVec" href="#PosDefManifold.fVec"><code>PosDefManifold.fVec</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">	(1) fVec(f::Function, ğ::AnyMatrixVector;
	&lt;
	w::Vector=[],
	âœ“w=false,
	allocs=[])
	&gt;

	(2) fVec(f::Function, g::Function, ğ::AnyMatrixVector;
	&lt; same optional keyword arguments in (1) &gt;)</code></pre><p>Given a 1d array <span>$ğ={P_1,...,P_k}$</span> of <span>$k$</span> matrices of the <a href="../MainModule/#ğ•„Vector-type">ğ•„Vector type</a>, <a href="../MainModule/#ğ”»Vector-type">ğ”»Vector type</a>, <a href="../MainModule/#ğ•ƒVector-type">ğ•ƒVector type</a> or <a href="../MainModule/#â„Vector-type">â„Vector type</a> and an optional non-negative real weights vector <span>$w={w_1,...,w_k}$</span>, return expression</p><p><span>$(1)\hspace{6pt}f_{i=1}^{k}(w_iP_i)$</span>,</p><p>or</p><p><span>$(2)\hspace{6pt}f_{i=1}^{k}(w_ig(P_i))$</span>,</p><p>where <span>$f$</span> is either the <code>mean</code> or the <code>sum</code> standard julia functions and <span>$g$</span> is whatever matrix function applying to each matrix <span>$P_k$</span>, such as <code>exp</code>, <code>log,</code>sqrt`, etc, and <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions-1">anonymous functions</a>.</p><p>This function is <strong>multi-threaded</strong>. It works by partitioning the <span>$k$</span> operations required by the <span>$f$</span> function in several groups, passing each group to a separate thread and combining the result of the intermediate operations. This function allows a gain in computational time only when the number of matrices (1) and/or their size (2) is high. Use <code>mean</code> and <code>sum</code> otherwise. The maximal gain is obtained when the number of matrices in <code>ğ</code> is an exact multiple of the number of threads Julia is instructed to use. For this latter, see <a href="../MainModule/#Threads">Threads</a>.</p><div class="admonition is-info" id="Nota-Bene-6e7365832fb4a574"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-6e7365832fb4a574" title="Permalink"></a></header><div class="admonition-body"><p>Contrarily to Julia <code>mean</code> and <code>sum</code> function (v 1.1.0) the <code>fVec</code> function returns a matrix of the same type of the matrices in <span>$ğ$</span>.</p></div></div><p><em>&lt;optional keword argument&gt;</em> <code>allocs</code> allows to pass pre-allocated memory for holding the intermediate result of each thread. Argument <code>allocs</code> must be a vector of as many matrices as threads and where the matrices have the same dimension as the the matrices in <span>$ğ$</span> (see the example here below). Using this option is worthwhile only if the size of the matrices is very high and/or when <code>fVec</code> is to be called repeatedly on many vector of matrices, where the matrices have always the same size, so that one allocation works for all calls.</p><p>If <em>&lt;optional keyword argument&gt;</em> <code>âœ“w=true</code> is passed, the weights are normalized so as to sum up to 1, otherwise they are used as they are passed. This option is provided to allow calling this function repeatedly without normalizing the same weights vector each time. By default <code>âœ“w</code> is false.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
Pset=randP(4, 1000); # generate 1000 positive definite 4x4 matrices
mean(Pset) # arithmetic mean calling Julia function
Threads.nthreads() # check how many threads are available
fVec(mean, Pset) # multi-threaded arithmetic mean

inv(mean(inv, Pset)) # Harmonic mean calling Julia function
inv(fVec(mean, inv, Pset)) # multi-threaded Harmonic mean

exp(mean(log, Pset)) # log Euclidean mean calling Julia function
exp(fVec(mean, log, Pset)) # multi-threaded log Euclidean mean

# notice that Julia `exp` function has changed the type of the result
# to `Symmetric`. To obtain an `Hermitian` output use
â„(exp(fVec(mean, log, Pset)))

w=(randn(1000)).^2
w=w./sum(w)  		# generate normalized random weights

# weighted arithmetic mean calling Julia function
sum(Pset[i]*w[i] for i=1:length(w))
# multi-threaded weighted arithmetic mean
fVec(sum, Pset, w=w)

# weighted harmonic mean calling Julia function
inv(sum(inv(Pset[i])*w[i] for i=1:length(w)))
# multi-threaded weighted harmonic mean
inv(fVec(sum, inv, Pset, w=w))

# pre-allocating memory
Pset=randP(100, 1000); # generate 1000 positive definite 100x100 matrices
Qset=MatrixVector(repeat([similar(Pset[1])], Threads.nthreads()))
fVec(mean, log, Pset, allocs=Qset)

# How much computing time we save ?
# (example min time obtained with 4 threads &amp; 4 BLAS threads)
using BenchmarkTools
# standard Julia function
@benchmark(mean(log, Pset)) 					# (5.271 s)
# fVec
@benchmark(fVec(mean, log, Pset))				# (1.540 s)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1241-L1344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.congruence" href="#PosDefManifold.congruence"><code>PosDefManifold.congruence</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) congruence(B::AnyMatrix, P::AnyMatrix, matrixType)
(2) congruence(B::AnyMatrix, ğ::AnyMatrixVector, matrixVectorType)
(3) congruence(B::AnyMatrix, ğ‘·::AnyMatrixVectorâ‚‚, matrixVectorâ‚‚Type)
(4) congruence(ğ::AnyMatrixVector, ğ‘·::AnyMatrixVectorâ‚‚, matrixVectorâ‚‚Type)</code></pre><p><strong>alias</strong>: <code>cong</code></p><p>(1) Return the congruent transformation</p><p><span>$BPB^H$</span>,</p><p>for <span>$B$</span> and <span>$P$</span> any combination of <code>Hermitian</code>, <code>LowerTriangular</code>, <code>Diagonal</code> or general <code>Matrix</code> type.</p><p>The result is of the <code>matrixType</code> argument, which must be provided and must be one of these four abstract type (not an instance of them). See <a href="../MainModule/#aliases">aliases</a> for shortening these type using symbols <code>â„</code>, <code>ğ”»</code>, <code>ğ•ƒ</code> and <code>ğ•„</code>.</p><p>(2) Return a vector of matrices holding the congruent transformations</p><p><span>$BP_kB^H$</span>,</p><p>for all <span>$k$</span> matrices in <span>$ğ={P_1,...,P_k}$</span>, for <span>$B$</span> and <span>$ğ$</span> any combination of matrix type <code>Hermitian</code>, <code>LowerTriangular</code>, <code>Diagonal</code> or <code>Matrix</code> (<span>$B$</span>) and vector of matrices type <code>â„Vector</code>, <code>ğ”»Vector</code>, <code>ğ•ƒVector</code> and <code>ğ•„Vector</code> (<span>$ğ$</span>). See <a href="../MainModule/#Array-of-Matrices-types">Array of Matrices types</a>.</p><p>The result is a vector of matrices of the <code>matrixVectorType</code> argument, which must be provided and must be one of the following abstract types: <code>â„Vector</code>, <code>ğ”»Vector</code>, <code>ğ•ƒVector</code> or <code>ğ•„Vector</code> (and not an instance of these types).</p><p>(3) Return a vector of vector of matrices holding the congruent transformations</p><p><span>$BP_{mk}B^H$</span>,</p><p>for all <span>$m$</span> vectors of <span>$k[m]$</span> vectors of matrices in <span>$ğ‘·$</span>, for <span>$B$</span> and <span>$ğ‘·$</span> any combination of matrix type <code>Hermitian</code>, <code>LowerTriangular</code>, <code>Diagonal</code> or <code>Matrix</code> (<span>$B$</span>) and vector of matrices type <code>â„Vectorâ‚‚</code>, <code>ğ”»Vectorâ‚‚</code>, <code>ğ•ƒVectorâ‚‚</code> and <code>ğ•„Vectorâ‚‚</code> (<span>$ğ‘·$</span>). See <a href="../MainModule/#Array-of-Matrices-types">Array of Matrices types</a>.</p><p>The result is a vector of vector of matrices of the <code>matrixVectorâ‚‚Type</code> argument, which must be provided and must be one of the following abstract types: <code>â„Vectorâ‚‚</code>, <code>ğ”»Vectorâ‚‚</code>, <code>ğ•ƒVectorâ‚‚</code> or <code>ğ•„Vectorâ‚‚</code> (and not an instance of these types).</p><p>(4) Return a vector of vector of matrices holding the congruent transformations</p><p><span>$B_iP_{ij}B_j^H$</span>, for <span>$i,jâˆˆ[1,...,m]$</span>.</p><p>for <span>$ğ$</span> holding <span>$m$</span> matrices and <span>$ğ‘·$</span> holding <span>$m$</span> vectors holding <span>$m$</span> matrices each. Note that, differently from method (3), here the vectors of <span>$ğ‘·$</span> are all of the same length and this is eaxctly the length of <span>$ğ$</span>. <span>$ğ$</span> and <span>$ğ‘·$</span> may be any combination of matrix vector type <code>â„Vector</code>, <code>ğ”»Vector</code>, <code>ğ•ƒVector</code> and <code>ğ•„Vector</code> (<span>$ğ$</span>) and vector of matrices type <code>â„Vectorâ‚‚</code>, <code>ğ”»Vectorâ‚‚</code>, <code>ğ•ƒVectorâ‚‚</code> and <code>ğ•„Vectorâ‚‚</code> (<span>$ğ‘·$</span>). See <a href="../MainModule/#Array-of-Matrices-types">Array of Matrices types</a>.</p><p>Note that this function computes the following algebraic expression:</p><p><span>$\begin{pmatrix} B_1 &amp; \hspace{0.01cm} &amp; 0 \\ \hspace{0.01cm} &amp; \ddots &amp; \hspace{0.01cm} \\ 0 &amp; \hspace{0.01cm} &amp; B_m \end{pmatrix} \begin{pmatrix} C_{11} &amp; \cdots &amp; C_{1m} \\ \vdots &amp; \ddots &amp; \vdots \\ C_{m1} &amp; \cdots &amp; C_{mm} \end{pmatrix} \begin{pmatrix}B_1^T &amp; \hspace{0.01cm} &amp; 0 \\ \hspace{0.01cm} &amp; \ddots &amp; \hspace{0.01cm} \\ 0 &amp; \hspace{0.01cm} &amp; B_m^T\end{pmatrix}$</span></p><p>The result is a vector of vector of matrices of the <code>matrixVectorâ‚‚Type</code> argument, which must be provided and must be one of the following abstract types: <code>â„Vectorâ‚‚</code>, <code>ğ”»Vectorâ‚‚</code>, <code>ğ•ƒVectorâ‚‚</code> or <code>ğ•„Vectorâ‚‚</code> (and not an instance of these types).</p><p>When you pass it to this function, make sure to typecast <span>$ğ$</span> as an <code>â„Vector</code>, <code>ğ”»Vector</code>, <code>ğ•ƒVector</code> or <code>ğ•„Vector</code> type if it is not already created as one of these types. See the example here below and <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p>Method (2), (3) and (4) are <strong>multi-threaded</strong>. See <a href="../MainModule/#Threads">Threads</a>.</p><div class="admonition is-info" id="Nota-Bene-26a6159c4b35532"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-26a6159c4b35532" title="Permalink"></a></header><div class="admonition-body"><p>Types <code>â„</code>, <code>ğ”»</code>, <code>ğ•ƒ</code> or <code>ğ•„</code> are actually constructors, thus they may modify the result of the congruence(s). This greatly expand the possibilities of this function, but it is your responsibility to pick the right argument <code>matrixType</code> in (1), <code>matrixVectorType</code> in (2) and <code>matrixVectorâ‚‚Type</code> in (3)-(4). For example, in (1) if <span>$B$</span> and <span>$P$</span> are <code>Hermitian</code>, calling <code>cong(B, P, ğ”»)</code> will actually return the diagonal part of <span>$B*P*B&#39;$</span> and calling <code>cong(B, P, ğ•ƒ)</code> will actually return its lower triangular part. The full congruence can be obtained as an <code>Hermitian</code> matrix by <code>cong(B, P, â„)</code> and as a generic matrix object by <code>cong(B, P, ğ•„)</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold

# (1)
P=randP(3) # generate a 3x3 positive matrix
M=randn(3, 3)
C=cong(M, P, â„) # equivalent to C=â„(M*P*M&#39;)

# (2)
Pset=randP(4, 100); # generate 100 positive definite 4x4 matrices
M=randn(4, 4)
Qset=cong(M, Pset, â„Vector) # = [M*Pset_1*M&#39;,...,M*Pset_k*M&#39;] as an â„Vector type

# recenter the matrices in Pset to their Fisher mean:
Qset=cong(invsqrt(mean(Fisher, Pset)), Pset, â„Vector)

# as a check, the Fisher mean of Qset is now the identity
mean(Fisher, Qset)â‰ˆI ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)

# (3)
Pset1=randP(4, 10); # generate 10 positive definite 4x4 matrices
Pset2=randP(4, 8);
Pset=â„Vectorâ‚‚([Pset1, Pset2]);
M=randn(4, 4)
Qset=cong(M, Pset, MatrixVectorâ‚‚)
Qset[1][1]â‰ˆM*Pset[1][1]*M&#39; ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)
Qset[1][5]â‰ˆM*Pset[1][5]*M&#39; ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)
Qset[2][1]â‰ˆM*Pset[2][1]*M&#39; ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)
Qset[2][4]â‰ˆM*Pset[2][4]*M&#39; ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)

# (4)
Pset1=randP(4, 2); # generate 2 positive definite 4x4 matrices
Pset2=randP(4, 2);
Pset=â„Vectorâ‚‚([Pset1, Pset2]);
U=ğ•„Vector([randU(4), randU(4)])
Qset=cong(U, Pset, MatrixVectorâ‚‚)
Qset[1][1]â‰ˆU[1]*Pset[1][1]*U[1]&#39; ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)
Qset[1][2]â‰ˆU[1]*Pset[1][2]*U[2]&#39; ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)
Qset[2][1]â‰ˆU[2]*Pset[2][1]*U[1]&#39; ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)
Qset[2][2]â‰ˆU[2]*Pset[2][2]*U[2]&#39; ? println(&quot;â­&quot;) : println(&quot;â›”&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1379-L1517">source</a></section></article><h2 id="Spectral-decompositions-of-positive-matrices"><a class="docs-heading-anchor" href="#Spectral-decompositions-of-positive-matrices">Spectral decompositions of positive matrices</a><a id="Spectral-decompositions-of-positive-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-decompositions-of-positive-matrices" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.evd"><code>evd</code></a></td><td style="text-align: left">Eigenvalue-Eigenvector decomposition of a matrix in <span>$UÎ›U&#39;=P$</span> form</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.frf"><code>frf</code></a></td><td style="text-align: left">Full-rank factorization of an Hermitian matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.invfrf"><code>invfrf</code></a></td><td style="text-align: left">Inverse of the full-rank factorization of an Hermitian matrix (whitening)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.spectralFunctions"><code>spectralFunctions</code></a></td><td style="text-align: left">Mother function for creating spectral functions of eigenvalues</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.pow"><code>pow</code></a></td><td style="text-align: left">Power of a positive matrix for any number of exponents in one pass</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.invsqrt"><code>invsqrt</code></a></td><td style="text-align: left">Principal square root inverse (whitening) of a positive matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.sqr"><code>sqr</code></a></td><td style="text-align: left">Square of a positive matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.powerIterations"><code>powerIterations</code></a>, <code>powIter</code></td><td style="text-align: left">Power method for estimating any number of eigenvectors and associated eigenvalues</td></tr></table><p>â‹…</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.evd" href="#PosDefManifold.evd"><code>PosDefManifold.evd</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evd(S::Union{ğ•„{T}, â„{T}}) where T&lt;:RealOrComplex</code></pre><p>Given a positive semi-definite matrix <span>$S$</span>, returns a 2-tuple <span>$(Î›, U)$</span>, where <span>$U$</span> is the matrix holding in columns the eigenvectors and <span>$Î›$</span> is the matrix holding the eigenvalues on the diagonal. This is the output of Julia <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.eigen">eigen</a> function in <span>$UÎ›U&#39;=S$</span> form.</p><p>As for the <code>eigen</code> function, the eigenvalues and associated eigenvectors are sorted by increasing values of eigenvalues.</p><p><span>$S$</span> may be real or complex and may be flagged by Julia as <code>Hermitian</code> (in this case <strong>PosDefManifold</strong> assumes it is positive definite).</p><p>See <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.spectralFunctions"><code>spectralFunctions</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
A=randn(3, 3);
S=A+A&#39;;
Î›, U=evd(S); # which is equivalent to (Î›, U)=evd(P)
(U*Î›*U&#39;) â‰ˆ S ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
# =&gt; UÎ›U&#39;=S, UÎ›=SU, Î›U&#39;=U&#39;S</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1574-L1604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.frf" href="#PosDefManifold.frf"><code>PosDefManifold.frf</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frf(P::â„{T}) where T&lt;:RealOrComplex</code></pre><p>Full-rank factorization of <code>Hermitian</code> matrix <code>P</code>. It is given by</p><p><span>$F=UD^{1/2}$</span>,</p><p>where</p><p><span>$\textrm{EVD}(P)=UDU^{H}$</span></p><p>is the eigenvalue-eigenvector decomposition of <code>P</code>. It verifies</p><p><span>$FF^H=P$</span>,</p><p>thus <span>$F^{-1}$</span> is a whitening matrix.</p><p><strong>See also</strong>: <a href="#PosDefManifold.invfrf"><code>invfrf</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
P=randP(3)
F = frf(P)
F*F&#39;â‰ˆP ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1612-L1641">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.invfrf" href="#PosDefManifold.invfrf"><code>PosDefManifold.invfrf</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invfrf(P::â„{T}) where T&lt;:RealOrComplex</code></pre><p>Inverse of the full-rank factorization of <code>Hermitian</code> matrix <code>P</code>. It is given by</p><p><span>$F=D^{-1/2}U^H$</span>,</p><p>where</p><p><span>$\textrm{EVD}(P)=UDU^{H}$</span></p><p>is the eigenvalue-eigenvector decomposition of <code>P</code>. It verifies</p><p><span>$FPF^H=I$</span>,</p><p>thus <span>$F$</span> is a whitening matrix.</p><p><strong>See also</strong>: <a href="#PosDefManifold.frf"><code>frf</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
P=randP(3)
F = invfrf(P)
F*P*F&#39;â‰ˆI ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1649-L1678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.spectralFunctions" href="#PosDefManifold.spectralFunctions"><code>PosDefManifold.spectralFunctions</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) spectralFunctions(P::â„{T}, func) where T&lt;:RealOrComplex
(2) spectralFunctions(D::ğ”»{S}, func) where S&lt;:Real</code></pre><p>(1) This is the <em>mother function</em> for all spectral functions of eigenvalues implemented in this library, which are:</p><ul><li><code>pow</code>     (power),</li><li><code>isqrt</code>   (inverse square root).</li></ul><p>The function <code>sqr</code> (square) does not use it, as it can be obtained more efficiently by simple multiplication.</p><p>You can use this function if you need another spectral function of eigenvalues besides those and those already implemented in the standard package <code>LinearAlgebra</code>. In general, you won&#39;t call it directly.</p><p><code>func</code> is the function that will be applied on the eigenvalues.</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>. It must be a positive definite or positive semi-definite matrix, depending on <code>func</code>.</p><p>A special method is provided for real <code>Diagonal</code> matrices (2).</p><div class="admonition is-info" id="Nota-Bene-443fe3d0e1fe863c"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-443fe3d0e1fe863c" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>func</code> must support the <code>func.</code> syntax and therefore must be able to apply element-wise to the eigenvalues (those include <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions-1">anonymous functions</a>).</p></div></div><p><strong>Maths</strong></p><p>The definition of spectral functions for a positive definite matrix <span>$P$</span> is at it follows:</p><p><span>$f\big(P\big)=Uf\big(Î›\big)U^H,$</span></p><p>where <span>$U$</span> is the matrix holding in columns the eigenvectors of <span>$P$</span>, <span>$Î›$</span> is the matrix holding on diagonal its eigenvalues and <span>$f$</span> is a function applying element-wise to the eigenvalues.</p><p><strong>See also</strong>: <a href="#PosDefManifold.evd"><code>evd</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
n=5
P=randP(n) # P=randP(ComplexF64, 5) to generate an Hermitian complex matrix
noise=0.1;
Q=spectralFunctions(P, x-&gt;x+noise) # add white noise to the eigenvalues
tr(Q)-tr(P) â‰ˆ noise*n ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1686-L1738">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.pow" href="#PosDefManifold.pow"><code>PosDefManifold.pow</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) pow(P::â„{T}, args...) where T&lt;:RealOrComplex
(2) pow(D::ğ”»{S}, args...) where S&lt;:Real</code></pre><p>(1) Given a positive semi-definite <code>Hermitian</code> matrix <span>$P$</span>, return the power <span>$P^{r_1}, P^{r_2},...$</span> for any number of exponents <span>$r_1, r_2,...$</span>. It returns a tuple comprising as many elements as arguments passed after <span>$P$</span>.</p><p><span>$P$</span> must be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p><span>$arg1, arg2,...$</span> are real numbers.</p><p>A special method is provided for real <code>Diagonal</code> matrices (2).</p><p><strong>See also</strong>: <a href="#PosDefManifold.invsqrt"><code>invsqrt</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
P=randP(5);     # use P=randP(ComplexF64, 5) for generating an Hermitian matrix
Q=pow(P, 0.5);            # =&gt;  QQ=P
Q, W=pow(P, 0.5, -0.5);
W*P*W â‰ˆ I ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
Q*Q â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
R, S=pow(P, 0.3, 0.7);
R*S â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1750-L1779">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.invsqrt" href="#PosDefManifold.invsqrt"><code>PosDefManifold.invsqrt</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) invsqrt(P{T}::â„) where T&lt;:RealOrComplex
(2) invsqrt(D{S}::ğ”») where S&lt;:Real</code></pre><p>Given a positive definite <code>Hermitian</code> matrix <span>$P$</span>, compute the inverse of the principal square root <span>$P^{-1/2}$</span>.</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p>A special method is provided for real <code>Diagonal</code> matrices (2).</p><p><strong>Maths</strong></p><p>The principal square root of a positive definite matrix <span>$P$</span> is the only symmetric (if <span>$P$</span> is real) or Hermitian (if <span>$P$</span> is complex) square root. Its inverse <span>$P^{-1/2}$</span> is also named the <strong>whitening</strong> or <strong>sphering</strong> matrix since<span>$P^{-1/2}PP^{-1/2}=I$</span>.</p><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.pow"><code>pow</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
P=randP(ComplexF64, 5);
Q=invsqrt(P);
Q*P*Q â‰ˆ I ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1796-L1827">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.sqr" href="#PosDefManifold.sqr"><code>PosDefManifold.sqr</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) sqr(P::â„{T}) where T&lt;:RealOrComplex
(2) sqr(X::Union{ğ•„{T}, ğ•ƒ{T}, ğ”»{S}}) where T&lt;:RealOrComplex where S&lt;:Real</code></pre><p>(1) Given a positive semi-definite <code>Hermitian</code> matrix <span>$P$</span>, compute its square <span>$P^{2}$</span>.</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices">typecasting matrices</a>.</p><p>A method is provided also for generic matrices of the <code>Matrix</code> type, <code>LowerTriangular</code> matrices and real <code>Diagonal</code> matrices (2). The output is of the same type as the input.</p><p><strong>See also</strong>: <a href="#PosDefManifold.pow"><code>pow</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
P=randP(5);
PÂ²=sqr(P);  # =&gt;  PÂ²=PP
sqrt(PÂ²)â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1834-L1857">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.powerIterations" href="#PosDefManifold.powerIterations"><code>PosDefManifold.powerIterations</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">powerIterations(H::Union{â„{T}, ğ•„{T}}, q::Int;
&lt;
evalues=false,
tol::Real=0,
maxiter::Int=300,
verbose=false&gt;) where T&lt;:RealOrComplex

powerIterations(L::ğ•ƒ{S}, q::Int;
&lt; same optional keyword arguments in (1)&gt;) where S&lt;:Real</code></pre><p><strong>alias</strong>: <code>powIter</code></p><p>(1) Compute the <span>$q$</span> eigenvectors associated to the <span>$q$</span> largest (real) eigenvalues of real or complex <code>Hermitian</code> or <code>Matrix</code> <span>$H$</span> using the <a href="https://bit.ly/2JSo0pb">power iterations</a> + <a href="https://bit.ly/2YE6zvy">Gram-Schmidt orthogonalization</a> as suggested by Strang. The eigenvectors are returned with the same type as the elements of <span>$H$</span>.</p><p><span>$H$</span> must have real eigenvalues, that is, it must be a symmetric matrix if it is real or an Hermitian matrix if it is complex.</p><p>(2) as in (1), but using only the <code>LowerTriangular</code> view <span>$L$</span> of a matrix. This option is available only for real matrices (see below).</p><p>The following are <em>&lt;optional keyword arguments&gt;</em>:</p><ul><li>`tol is the tolerance for the convergence of the power method (see below),</li><li>`maxiter is the maximum number of iterations allowed for the power method,</li><li>if `verbose=true, the convergence of all iterations will be printed,</li><li>if <code>evalues=true, return the 4-tuple</code><code>(Î›, U, iterations, covergence)</code>`,</li><li>if <code>evalues=false return the 3-tuple</code><code>(U, iterations, covergence)</code>`.</li></ul><div class="admonition is-info" id="Nota-Bene-f528d78e3a208dfa"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-f528d78e3a208dfa" title="Permalink"></a></header><div class="admonition-body"><p>Differently from the <a href="#PosDefManifold.evd"><code>evd</code></a> function, the eigenvectors and eigenvalues are sorted by decreasing order of eigenvalues.</p><p>If <span>$H$</span> is <code>Hermitian</code> and real, only its lower triangular part is used for computing the power iterations, like in (2). In this case the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.BLAS.symm">BLAS.symm</a> routine is used. Otherwise the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.BLAS.gemm">BLAS.gemm</a> routine is used. See <a href="../MainModule/#Threads">Threads</a>.</p><p><span>$tol$</span> defaults to 100 times the square root of <code>Base.eps</code> of the type of <span>$H$</span>. This corresponds to requiring the relative convergence criterion over two successive iterations to vanish for about half the significant digits minus 2.</p></div></div><p><strong>See also</strong>: <a href="#PosDefManifold.mgs"><code>mgs</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, PosDefManifold
# Generate an Hermitian (complex) matrix
H=randP(ComplexF64, 10);
# 3 eigenvectors and eigenvalues
U, iterations, convergence=powIter(H, 3, verbose=true)
# all eigenvectors
Î›, U, iterations, convergence=powIter(H, size(H, 2), evalues=true, verbose=true);
U&#39;*U â‰ˆ I &amp;&amp; U*Î›*U&#39;â‰ˆH ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)

# passing a `Matrix` object
Î›, U, iterations, convergence=powIter(Matrix(H), 3, evalues=true)

# passing a `LowerTriangular` object (must be a real matrix in this case)
L=ğ•ƒ(randP(10))
Î›, U, iterations, convergence=powIter(L, 3, evalues=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1863-L1932">source</a></section></article><h2 id="Decompositions-involving-triangular-matrices"><a class="docs-heading-anchor" href="#Decompositions-involving-triangular-matrices">Decompositions involving triangular matrices</a><a id="Decompositions-involving-triangular-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Decompositions-involving-triangular-matrices" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.choL"><code>choL</code></a></td><td style="text-align: left">Lower triangular factor of Cholesky decomposition</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.choInv"><code>choInv</code></a></td><td style="text-align: left">Lower triangular factor of Cholesky decomposition and its inverse in one pass</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.choInv!"><code>choInv!</code></a></td><td style="text-align: left">as <a href="#PosDefManifold.choInv"><code>choInv</code></a>, but destroying the input matrix</td></tr></table><p>â‹…</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.choL" href="#PosDefManifold.choL"><code>PosDefManifold.choL</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) choL(P::â„{T}) where T&lt;:RealOrComplex
(2) choL(D::ğ”»{S}) where S&lt;:Real</code></pre><p>(1) Given a real or complex positive definite <code>Hermitian</code> matrix <span>$P$</span>, return the <em>Cholesky lower triangular factor</em> <span>$L$</span> such that <span>$LL^H=P$</span>. To obtain <span>$L^H$</span> or both <span>$L$</span> and <span>$L^H$</span>, use instead julia function <a href="https://bit.ly/2u9Hw5P">cholesky</a>.</p><p>On output, <span>$L$</span> is of type <a href="https://bit.ly/2U511f3"><code>LowerTriangular</code></a>.</p><p>(2) For a real <code>Diagonal</code> matrix <span>$D$</span>, return <span>$D^{1/2}$</span>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.choInv"><code>choInv</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
P=randP(5);
L=choL(P);
L*L&#39;â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L1991-L2014">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.choInv" href="#PosDefManifold.choInv"><code>PosDefManifold.choInv</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">choInv(P::AbstractArray{T};
	kind::Symbol = :LLt, tol::Real = âˆšeps(T)) where T&lt;:RealOrComplex</code></pre><p>For a real or complex positive definite matrix <span>$P$</span>, let <span>$P=LL^H$</span> be its <em>Cholesky decomposition</em> and <span>$P=L_1DL_1^H$</span> the related <em>LDLt</em> decomposition. In the above, <span>$L$</span> is a lower triangular matrix, <span>$D$</span> a positive-definite diagonal matrix and <span>$L_1$</span> a unit lower triangular matrix. Return:</p><ul><li>if <code>kind</code>is <code>:LLt</code> (default), the 2-tuple <span>$L$</span>, <span>$L^{-H}$</span></li><li>if <code>kind</code>is <code>:LDLt</code>, the 3-tuple <span>$L_1$</span>, <span>$D$</span>, <span>$L_1^{-H}$</span>.</li></ul><p>Those are obtained in one pass and for small matrices this is faster then calling Julia&#39;s <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.cholesky">chelosky</a> function and inverting the lower factor unless you set</p><pre><code class="nohighlight hljs">BLAS.set_num_threads(1).</code></pre><p>Input matrix <code>P</code> may be of type <code>Matrix</code> or <code>Hermitian</code>. Since only the lower triangle is used, <code>P</code> may also be a <code>LowerTriangular</code> view of a positive definite matrix. If <code>P</code> is real, it can also be of the <code>Symmetric</code> type.</p><p>The algorithm is a <em>multiplicative Gaussian elimination</em>. If run completely, in input matrix <code>P</code> there will be the Identity at the end.</p><p><strong>Notes:</strong> Output <span>$L^{-H}$</span> is an inverse square root (whitening matrix) of <span>$P$</span>, since <span>$L^{-1}PL^{-H}=I$</span>. It therefore yields the inversion of <span>$P$</span> as <span>$P^{-1}=L^{-H}L^{-1}$</span>. It is the fastest whitening matrix to be computed, however it yields poor numerical precision, especially for large matrices.</p><p>The following relations holds:</p><ul><li><span>$L=PL^{-H}$</span></li><li><span>$L^{H}=L^{-1}P$</span></li><li><span>$L^{-H}=P^{-1}L$</span></li><li><span>$L^{-1}=L^{H}P^{-1}$</span>.</li></ul><p>We also have</p><ul><li><span>$L^{H}L=L^{-1}P^{2}L^{-H}=UPU^H$</span>, with <span>$U$</span> orthogonal (see below) and</li><li><span>$L^{-1}L^{-H}=L^{H}P^{-2}L=UP^{-1}U^H$</span>.</li></ul><p><span>$LL^{H}$</span> and <span>$L^{H}L$</span> are unitarily similar, that is,</p><p><span>$ULL^{H}U^H=L^{H}L$</span>,</p><p>where <span>$U=L^{-1}P^{1/2}$</span>, with <span>$P^{1/2}=H$</span> the <em>principal</em> (unique symmetric) square root of <span>$P$</span>. This is seen writing <span>$PP^{-1}=HHL^{-H}L^{-1}$</span>; multiplying both sides on the left by <span>$L^{-1}$</span> and on the right by <span>$L$</span> we obtain</p><p><span>$L^{-1}PP^{-1}L=L^{-1}HHL^{-H}=I=(L^{-1}H)(L^{-1}H)^H$</span></p><p>and since <span>$L^{-1}H$</span> is square it must be unitary.</p><p>From these expressions we have</p><ul><li><span>$H=LU=U^HL^H$</span></li><li><span>$L=HU^H$</span></li><li><span>$H^{-1}=U^HL^{-1}$</span></li><li><span>$L^{-1}=UH^{-1}$</span>.</li></ul><p><span>$U$</span> is the <em>polar factor</em> of <span>$L^{H}$</span>, <em>i.e.</em>, <span>$L^{H}=UH$</span>, since <span>$LL^{H}=HU^HUH^H=H^2=P$</span>.</p><p>From <span>$L^{H}L=UCU^H$</span> we have <span>$L^{H}LU=UC=ULL^{H}$</span> and from <span>$U=L^{-1}H$</span> we have <span>$L=HU^H$</span>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.choInv!"><code>choInv!</code></a>, <a href="#PosDefManifold.choL"><code>choL</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifold
n, t = 800, 6000
etol = 1e-9
Z=randn(t, n)
Y=Z&#39;*Z
Yi=inv(Y)

A, B=choInv!(copy(Y))
norm(A*A&#39;-Y)/âˆšn &lt; etol ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
norm(B*B&#39;-Yi)/âˆšn &lt; etol ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)

A, D, B=choInv!(copy(Y); kind=:LDLt)
norm(Y-A*D*A&#39;)/âˆšn &lt; etol ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
norm(Yi-B*inv(D)*B&#39;)/âˆšn &lt; etol ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)

# repeat the test for complex matrices
Z=randn(ComplexF64, t, n)
Y=Z&#39;*Z
Yi=inv(Y)

A, B=choInv!(copy(Y))
norm(A*A&#39;-Y)/âˆšn &lt; etol ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
norm(B*B&#39;-Yi)/âˆšn &lt; etol ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)

A, D, B=choInv!(copy(Y); kind=:LDLt)
norm(Y-A*D*A&#39;)/âˆšn &lt; etol ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
norm(Yi-B*inv(D)*B&#39;)/âˆšn &lt; etol ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L2023-L2124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.choInv!" href="#PosDefManifold.choInv!"><code>PosDefManifold.choInv!</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">choInv!(P::AbstractArray{T};
	kind::Symbol = :LLt, tol::Real = âˆšeps(T)) where T&lt;:RealOrComplex</code></pre><p>The same thing as <a href="#PosDefManifold.choInv"><code>choInv</code></a>, but destroys the input matrix. This function does nt require copying the input matrix, thus it is slightly faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/cbd73fd822fb4180e6a2f0a36260cfea973436c0/src/linearAlgebra.jl#L2135-L2142">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../riemannianGeometry/">Â« riemannianGeometry.jl</a><a class="docs-footer-nextpage" href="../statistics/">statistics.jl Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Monday 12 May 2025 04:49">Monday 12 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
