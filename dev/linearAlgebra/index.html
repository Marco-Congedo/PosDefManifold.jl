<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>linearAlgebra.jl Â· PosDefManifold</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PosDefManifold logo"/></a><h1>PosDefManifold</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifold Documentation</a></li><li><a class="toctext" href="../introToRiemannianGeometry/">Intro to Riemannian Geometry</a></li><li><a class="toctext" href="../MainModule/">MainModule (PosDefManifold.jl)</a></li><li><a class="toctext" href="../riemannianGeometry/">riemannianGeometry.jl</a></li><li class="current"><a class="toctext" href>linearAlgebra.jl</a><ul class="internal"><li><a class="toctext" href="#Matrix-normalizations-1">Matrix normalizations</a></li><li><a class="toctext" href="#Boolean-functions-of-matrices-1">Boolean functions of matrices</a></li><li><a class="toctext" href="#Scalar-functions-of-matrices-1">Scalar functions of matrices</a></li><li><a class="toctext" href="#Diagonal-functions-of-matrices-1">Diagonal functions of matrices</a></li><li><a class="toctext" href="#Unitary-functions-of-matrices-1">Unitary functions of matrices</a></li><li><a class="toctext" href="#Matrix-function-of-matrices-1">Matrix function of matrices</a></li><li><a class="toctext" href="#Spectral-decompositions-of-positive-matrices-1">Spectral decompositions of positive matrices</a></li><li><a class="toctext" href="#Decompositions-involving-triangular-matrices-1">Decompositions involving triangular matrices</a></li></ul></li><li><a class="toctext" href="../signalProcessing/">signalProcessing.jl</a></li><li><a class="toctext" href="../test/">test.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>linearAlgebra.jl</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/master/docs/src/linearAlgebra.md"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>linearAlgebra.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="linearAlgebra.jl-1" href="#linearAlgebra.jl-1">linearAlgebra.jl</a></h1><p>This unit contains linear algebra functions useful in relation to the Riemannian  geometry of the manifold of <em>Symmetric Positive Definite (SPD)</em> or  <em>Hermitian Positive Definite (HPD)</em> matrices. In Julia those are <code>Hermitian</code> matrices, see <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>In general they take a matrix as input (some may take other arrays as input) and are divided in seven categories depending on what kind of functions thay are and what they give as output:</p><table><tr><th>Category</th><th>Output</th></tr><tr><td>1. <a href="#Matrix-normalizations-1">Matrix normalizations</a></td><td>matrix</td></tr><tr><td>2. <a href="#Boolean-functions-of-matrices-1">Boolean functions of matrices</a></td><td>matrix</td></tr><tr><td>3. <a href="#Scalar-functions-of-matrices-1">Scalar functions of matrices</a></td><td>scalar</td></tr><tr><td>4. <a href="#Diagonal-functions-of-matrices-1">Diagonal functions of matrices</a></td><td>diagonal matrix</td></tr><tr><td>5. <a href="#Unitary-functions-of-matrices-1">Unitary functions of matrices</a></td><td>orthogonal/unitary matrix</td></tr><tr><td>6. <a href="#Matrix-function-of-matrices-1">Matrix function of matrices</a></td><td>matrix</td></tr><tr><td>7. <a href="#Spectral-decompositions-of-positive-matrices-1">Spectral decompositions of positive matrices</a></td><td>spectral function of input</td></tr><tr><td>8. <a href="#Decompositions-involving-triangular-matrices-1">Decompositions involving triangular matrices</a></td><td>triangular matrix</td></tr></table><p>â‹…</p><h2><a class="nav-anchor" id="Matrix-normalizations-1" href="#Matrix-normalizations-1">Matrix normalizations</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.det1"><code>det1</code></a></td><td>Normalize the determinant</td></tr><tr><td><a href="#PosDefManifold.tr1"><code>tr1</code></a></td><td>Normalize the trace</td></tr><tr><td><a href="#PosDefManifold.normalizeCol!"><code>normalizeCol!</code></a></td><td>Normalize one or more columns</td></tr></table><p>â‹…</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.det1" href="#PosDefManifold.det1"><code>PosDefManifold.det1</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">det1(X::ğ•„)
det1(X::â„)</code></pre><p>Given a real or complex square <code>Matrix</code> or <code>Hermitian</code> matrix <span>$X$</span>,  return the best approximant to  <span>$X$</span> from the set of matrices in the <a href="https://bit.ly/2W5jDZ6">special linear group</a>,  <em>i.e.</em>, the closer matrix having determinant equal to 1.  See Bhatia and Jain (2014)[ğŸ“].</p><p><strong>See</strong> <a href="https://bit.ly/2Y4MnTF">det</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.tr1"><code>tr1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
P=randP(5) # generate a random real positive definite matrix 5x5
Q=det1(P)
det(Q) # must be 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L27-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.tr1" href="#PosDefManifold.tr1"><code>PosDefManifold.tr1</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tr1(X::â„)
tr1(X::ğ•„)</code></pre><p>Given a real or complex square <code>Matrix</code> or <code>Hermitian</code> matrix <span>$X$</span>,  return the trace-normalized <span>$X$</span>  (trace=1).</p><p><strong>See</strong>: <a href="https://bit.ly/2HoOLiM">Julia trace function</a>.</p><p><strong>See also</strong>: <a href="#LinearAlgebra.tr"><code>tr</code></a>, <a href="#PosDefManifold.det1"><code>det1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
P=randP(5) # generate a random real positive definite matrix 5x5
Q=tr1(P)
tr(Q)  # must be 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L53-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.normalizeCol!" href="#PosDefManifold.normalizeCol!"><code>PosDefManifold.normalizeCol!</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) normalizeCol!(X::ğ•„, j::Int)
(2) normalizeCol!(X::ğ•„, j::Int, by::Number)
(3) normalizeCol!(X::ğ•„, range::UnitRange)
(4) normalizeCol!(X::ğ•„, range::UnitRange, by::Number)</code></pre><p>Given a <code>Matrix</code> <span>$X$</span>,</p><ul><li>(1) normalize the <span>$j^{th}$</span>column</li><li>(2) divide the elements of the <span>$j^{th}$</span> column by number <span>$by$</span></li><li>(3) normalize the columns in <span>$range$</span></li><li>(4) divide the elements of columns in <span>$range$</span>  by number <span>$by$</span>.</li></ul><p><span>$by$</span> is a number of abstract supertype <a href="https://bit.ly/2JwXjGr">Number</a>.  It should be an integer, real or complex number.</p><p><span>$range$</span> is a <a href="https://bit.ly/2HSfK5J">UnitRange</a> type.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>Julia does not allow normalizing the columns of <code>Hermitian</code> matrices. If you want to call this function for an <code>Hermitian</code> matrix see <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p></div></div><p><strong>See</strong> <a href="https://bit.ly/2TaAkR0">norm</a> and <a href="https://bit.ly/2I1Vgrg">randn</a> for the example</p><p><strong>See also</strong>: <a href="#PosDefManifold.colNorm"><code>colNorm</code></a>, <a href="#PosDefManifold.colProd"><code>colProd</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(10, 20)
normalizeCol!(X, 2)                  # (1) normalize columns 2
normalizeCol!(X, 2, 10.0)            # (2) divide columns 2 by 10.0
normalizeCol!(X, 2:4)                # (3) normalize columns 2 to 4
X=randn(ComplexF64, 10, 20)
normalizeCol!(X, 3)                  # (1) normalize columns 3
normalizeCol!(X, 3:6, (2.0 + 0.5im)) # (4) divide columns 3 to 5 by (2.0 + 0.5im)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L77-L113">source</a></section><h2><a class="nav-anchor" id="Boolean-functions-of-matrices-1" href="#Boolean-functions-of-matrices-1">Boolean functions of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.ispos"><code>ispos</code></a></td><td>Check whether a real vector or diagonal matrix are comprised of all positive elements</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.ispos" href="#PosDefManifold.ispos"><code>PosDefManifold.ispos</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    (1) ispos(   Î»::Vector{T};
                &lt;tol::Real=0, rev=true, ğŸ””=true, msg=&quot;&quot;&gt;) where T&lt;:Real

    (2) ispos(   Î›::Diagonal{T};
                &lt;tol::Real=0, rev=true, ğŸ””=true, msg=&quot;&quot;&gt;) where T&lt;:Real</code></pre><p>Return <span>$true$</span> if all numbers in (1) real vector <span>$Î»$</span> or in (2) real diagonal  matrix <span>$Î›$</span> are not inferior to <span>$tol$</span>, otherwise return <span>$false$</span>. This is used,  for example, in spectral functions to check that all eigenvalues are positive.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p><span>$tol$</span> defaults to the square root of <code>Base.eps</code> of the type of <span>$Î»$</span> (1)  or <span>$Î›$</span> (2). This corresponds to requiring positivity beyond about half of  the significant digits.</p></div></div><p>The following are <em>&lt;optional keyword arguments&gt;</em>:</p><ul><li>If <span>$rev=true$</span> the (1) elements in <span>$Î»$</span> or (2) the diagonal elements in <span>$Î›$</span> will be chacked in reverse order.</li></ul><p>This is done for allowing a very fast  check when the elements are sorted and it is known where to start checking.</p><p>If the result is <span>$false$</span>:</p><ul><li>if <span>$ğŸ””=true$</span> a bell character will be printed. In most systems this will ring a bell on the computer.</li><li>if string <span>$msg$</span> is provided, a warning will print <span>$msg$</span> followed by:</li></ul><p>&quot;at position <em>pos</em>&quot;, where <em>pos</em> is the position where the  first non-positive element has been found.</p><pre><code class="language-none"> ## Examples
 using PosDefManifold
 a=[1, 0, 2, 8]
 ispos(a, msg=&quot;non-positive element found&quot;)

 # it will print:
 # â”Œ Warning: non-positive element found at position 2
 # â”” @ [here julie will point to the line of code issuing the warning]</code></pre><pre><code class="language-none"></code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L133-L173">source</a></section><h2><a class="nav-anchor" id="Scalar-functions-of-matrices-1" href="#Scalar-functions-of-matrices-1">Scalar functions of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.colProd"><code>colProd</code></a></td><td>Sum of products of the elements in two columns</td></tr><tr><td><a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a></td><td>Sum of squares of all elements or of specified columns</td></tr><tr><td><a href="#PosDefManifold.sumOfSqrDiag"><code>sumOfSqrDiag</code></a>, <code>ssd</code></td><td>Sum of squares of the diagonal elements</td></tr><tr><td><a href="#PosDefManifold.colNorm"><code>colNorm</code></a></td><td>Eucliden norm of a column</td></tr><tr><td><a href="#PosDefManifold.sumOfSqrTril"><code>sumOfSqrTril</code></a>, <code>sst</code></td><td>Sum of squares of the lower triangle elements up to a given underdiagonal</td></tr><tr><td><a href="#LinearAlgebra.tr"><code>tr</code></a></td><td>Fast trace of the product of two Hermitian matrices</td></tr><tr><td><a href="#PosDefManifold.quadraticForm"><code>quadraticForm</code></a>, <code>qufo</code></td><td>Fast quadratic form</td></tr><tr><td><a href="#PosDefManifold.fidelity"><code>fidelity</code></a></td><td>(Quantum) Fidelity of two positive matrices</td></tr></table><p>â‹…</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.colProd" href="#PosDefManifold.colProd"><code>PosDefManifold.colProd</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) colProd(X::Union{ğ•„, â„, j::Int, l::Int)
(2) colProd(X::Union{ğ•„, â„, Y::Union{ğ•„, â„}, j::Int, l::Int)</code></pre><p>(1) Given a real or complex <code>Matrix</code> or <code>Hermitian</code> matrix <span>$X$</span>,  return the dot product of the <span>$j^{th}$</span> and <span>$l^{th}$</span> columns, defined as,</p><p><span>$\sum_{i=1}^{r} \big(x_{ij}^*x_{il}\big),$</span></p><p>where <span>$r$</span> is the number of rows of <span>$X$</span> and <span>$^*$</span> denotes complex conjugate.</p><p>(2) Given real or complex <code>Matrix</code> or <code>Hermitian</code> matrices <span>$X$</span> and <span>$Y$</span>,  return the dot product of the <span>$j^{th}$</span> column of <span>$X$</span> and the <span>$l^{th}$</span> column  of <span>$Y$</span>, defined as,</p><p><span>$\sum_{i=1}^{r} \big(x_{ij}^*y_{il}\big),$</span></p><p>where <span>$r$</span> is the number of rows of <span>$X$</span> and of <span>$Y$</span> and <span>$^*$</span> denotes  the complex conjugate.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p><span>$X$</span> and of <span>$Y$</span> may have a different number of columns, but must have the same number of rows.</p></div></div><p>Arguments <span>$j$</span> and <span>$l$</span> must be positive integers in range</p><ul><li>(1) <code>j,l in 1:size(X, 2)</code>,</li><li>(2) <code>j in 1:size(X, 2), l in 1:size(Y, 2)</code>.</li></ul><p><strong>See also</strong>: <a href="#PosDefManifold.normalizeCol!"><code>normalizeCol!</code></a>, <a href="#PosDefManifold.colNorm"><code>colNorm</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(10, 20)
p=colProd(X, 1, 3)
Y=randn(10, 30)
q=colProd(X, Y, 2, 25)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L196-L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.sumOfSqr" href="#PosDefManifold.sumOfSqr"><code>PosDefManifold.sumOfSqr</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) sumOfSqr(A::Array)
(2) sumOfSqr(H::Union{â„, ğ•ƒ})
(3) sumOfSqr(X::Union{ğ•„, â„}, j::Int)
(4) sumOfSqr(X::Union{ğ•„, â„}, range::UnitRange)</code></pre><p>Return</p><ul><li>(1) the sum of square of the elements in an array <span>$A$</span> of any dimensions.</li><li>(2) as in (1), but for an <code>Hermitian</code> or <code>LowerTriangular</code> matrix <span>$H$</span>, using only the lower triangular part.</li><li>(2) the sum of square of the <span>$j^{th}$</span> column of a <code>Matrix</code> or <code>Hermitian</code> <span>$X$</span>.</li><li>(3) the sum of square of the columns of a <code>Matrix</code> or <code>Hermitian</code> <span>$X$</span> in a given range.</li></ul><p>All methods support real and complex matrices.</p><p>Only method (1) works for arrays of any dimensions.</p><p>For method (2) and (1), if <span>$A$</span> is a matrix return the square of the  <a href="https://bit.ly/2Fi10eH">Frobenius norm</a>:  <span>$\sum |a_{ij}|^2.$</span></p><p>For method (3), <span>$j$</span> is a positive integer in range <code>1:size(X, 1)</code>.</p><p>For method (4), <span>$range$</span> is a <a href="https://bit.ly/2HDoFbk">UnitRange type</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.colNorm"><code>colNorm</code></a>, <a href="#PosDefManifold.sumOfSqrDiag"><code>sumOfSqrDiag</code></a>, <a href="#PosDefManifold.sumOfSqrTril"><code>sumOfSqrTril</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(10, 20)
sum2=sumOfSqr(X)        # (1) sum of squares of all elements
sum2=sumOfSqr(X, 1)     # (2) sum of squares of elements in column 1
sum2=sumOfSqr(X, 2:4)   # (3) sum of squares of elements in column 2 to 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L258-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.sumOfSqrDiag" href="#PosDefManifold.sumOfSqrDiag"><code>PosDefManifold.sumOfSqrDiag</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) sumOfSqrDiag(X::ğ•„)
(2) sumOfSqrDiag(X::Union{ğ”», â„, ğ•ƒ})</code></pre><p><strong>alias</strong>: <code>ssd</code></p><p>(1) Sum of squares of the diagonal elements in real or complex <code>Matrix</code> <span>$X$</span>.  If <span>$X$</span> is rectangular, the main diagonal is considered.</p><p>(2) Sum of squares of the main diagonal of real or complex <code>Diagonal</code>,  <code>Hermitian</code> or <code>LowerTriangular</code> matrix <span>$X$</span>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a>, <a href="#PosDefManifold.sumOfSqrTril"><code>sumOfSqrTril</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
X=randn(10, 20)
sumDiag2=sumOfSqrDiag(X) # (1)
sumDiag2=sumOfSqrDiag(ğ”»(X)) # (2) ğ”»=LinearAlgebra.Diagonal</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L319-L339">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.colNorm" href="#PosDefManifold.colNorm"><code>PosDefManifold.colNorm</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">colNorm(X::Union{ğ•„, â„}, j::Int)</code></pre><p>Given a real or complex <code>Matrix</code> or <code>Hermitian</code> matrix <span>$X$</span>,  return the Euclidean norm of its <span>$j^{th}$</span> column.</p><p><strong>See also</strong>: <a href="#PosDefManifold.normalizeCol!"><code>normalizeCol!</code></a>, <a href="#PosDefManifold.colProd"><code>colProd</code></a>, <a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(10, 20)
normOfSecondColumn=colNorm(X, 2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L241-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.sumOfSqrTril" href="#PosDefManifold.sumOfSqrTril"><code>PosDefManifold.sumOfSqrTril</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sumOfSqrTril(X::Union{ğ•„, ğ”», â„, ğ•ƒ}, k::Int=0)</code></pre><p><strong>alias</strong>: <code>sst</code></p><p>Given a real or complex <code>Matrix</code>, <code>Diagonal</code>, <code>Hermitian</code> or  <code>LowerTriangular</code> matrix <span>$X$</span>,  return the sum of squares of the elements  in its lower triangle up to the <span>$k^{th}$</span> underdiagonal.</p><p><code>Matrix</code> <span>$X$</span> may be rectangular.</p><p><span>$k$</span> must be in range</p><ul><li><code>1-size(X, 1):c-1</code> for <span>$X$</span> <code>Matrix</code>, <code>Diagonal</code> or <code>Hermitian</code>,</li><li><code>1-size(X, 1):0</code> for <span>$X$</span> <code>LowerTriangular</code>.</li></ul><p>See julia <a href="https://bit.ly/2Tbx8o7">tril(M, k::Integer)</a> function  for numbering of diagonals.</p><p><strong>See also</strong>: <a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a>, <a href="#PosDefManifold.sumOfSqrDiag"><code>sumOfSqrDiag</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
A=[4. 3.; 2. 5.; 1. 2.]
#3Ã—2 Array{Float64,2}:
# 4.0  3.0
# 2.0  5.0
# 1.0  2.0

s=sumOfSqrTril(A, -1)
# 9.0 = 1Â²+2Â²+2Â²

s=sumOfSqrTril(A, 0)
# 50.0 = 1Â²+2Â²+2Â²+4Â²+5Â²</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L346-L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) tr(P::â„, Q::â„)
(2) tr(P::â„, Q::ğ•„)</code></pre><p>Given (1) two <code>Hermitian</code> positive definite matrix <span>$P$</span> and <span>$Q$</span>,  return the trace of the product <span>$PQ$</span>.  This is real even if <span>$P$</span> and <span>$Q$</span> are complex.</p><p><span>$P$</span> must always be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.  In (2) <span>$Q$</span> is a <code>Matrix</code> object,  in which case return</p><ul><li>a real trace if the product <span>$PQ$</span> is real or if it has all positive real eigenvalues.</li><li>a complex trace if the product <span>$PQ$</span> is not real and has complex eigenvalues.</li></ul><p><strong>Math</strong></p><p>Let <span>$P$</span> and <span>$Q$</span> be <code>Hermitian</code> matrices, using the properties of the trace  (e.g., the cyclic property and the similarity invariance) you can use this  function to fast compute the trace of several expressions. For example:</p><p><span>$\textrm{tr}(PQ)=\textrm{tr}(P^{1/2}QP^{1/2})$</span></p><p>and</p><p><span>$\textrm{tr}(PQP)=\textrm{tr}(P^{2}Q)$</span> (see example below).</p><p><strong>See</strong>: <a href="https://bit.ly/2HoOLiM">trace</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.tr1"><code>tr1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(ComplexF64, 5) # generate a random complex positive definite matrix 5x5
Q=randP(ComplexF64, 5) # generate a random complex positive definite matrix 5x5
tr(P, Q) â‰ˆ tr(P*Q) ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
tr(P, Q) â‰ˆ tr(sqrt(P)*Q*sqrt(P)) ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
tr(sqr(P), Q) â‰ˆ tr(P*Q*P) ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L395-L433">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.quadraticForm" href="#PosDefManifold.quadraticForm"><code>PosDefManifold.quadraticForm</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">quadraticForm(v::Vector{T}, X::Union(ğ•„{T}, â„{T}) where T&lt;:RealOrComplex
quadraticForm(v::Vector{T}, L::ğ•ƒ{T}) where T&lt;:Real</code></pre><p><strong>alias</strong>: <code>qufo</code></p><p>(1) Given a real or complex vector <span>$v$</span> and <code>Hermitian</code> matrix <span>$X$</span>,  compute the quadratic form</p><p><span>$v^HXv$</span>,</p><p>where the superscript <em>H</em> denotes complex conjugate transpose.</p><p>If <span>$v$</span> and <span>$X$</span> are real and <span>$X$</span> is <code>Hermitian</code>, only the  lower triangular part of <span>$X$</span> is used.</p><p>(2) Compute the quadratic form given a real vector <span>$v$</span>  and the <code>LowerTriangular</code> view <span>$L$</span> of a real matrix.</p><p><strong>Math</strong></p><p>For <span>$v$</span> and <span>$X$</span> real and <span>$X$</span> symmetric, the quadratic form is</p><p><span>$\sum_i(v_i^2x_{ii})+\sum_{i&gt;j}(2v_iv_jx_{ij})$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5) # generate a random real positive definite matrix 5x5
v=randn(5)
q1=quadraticForm(v, P) # or q1=quad(v, P)
# obtain a lower Triangular view of P
L=LowerTriangular(Matrix(P)) # or L=ğ•ƒ(Matrix(P))
q2=quadraticForm(v, L)
q1 â‰ˆ q2 ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L449-L485">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.fidelity" href="#PosDefManifold.fidelity"><code>PosDefManifold.fidelity</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fidelity(P::â„, Q::â„)</code></pre><p>Given two positive definte <code>Hermitian</code> matrices <span>$P$</span> and <span>$Q$</span>,  return their <em>fidelity</em>:</p><p><span>$tr\big(P^{1/2}QP^{1/2}\big)^{1/2}.$</span></p><p>This is used in quantum physics and is related to the  <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a> metric. See for example Bhatia, Jain and Lim (2019b)<a href="../introToRiemannianGeometry/#-1">ğŸ“</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5);
Q=randP(5);
f=fidelity(P, Q)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L504-L521">source</a></section><h2><a class="nav-anchor" id="Diagonal-functions-of-matrices-1" href="#Diagonal-functions-of-matrices-1">Diagonal functions of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.fDiagonal"><code>fDiagonal</code></a>, <code>ğ‘“ğ”»</code></td><td>Elemen-wise functions of matrix diagonals</td></tr></table><p>â‹…</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.fDiagonal" href="#PosDefManifold.fDiagonal"><code>PosDefManifold.fDiagonal</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) fDiagonal(func::Function, X::ğ”», k::Int=0)
(2) fDiagonal(func::Function, X::ğ•ƒ, k::Int=0)
(3) fDiagonal(func::Function, X::Union{ğ•„, â„}, k::Int=0)</code></pre><p><strong>alias</strong>: <code>ğ‘“ğ”»</code></p><p>Applies function <code>func</code> element-wise to the elements of the <span>$k^{th}$</span>  diagonal of matrix <span>$X$</span> (square in all cases but for the ğ•„=<code>Matrix</code> argument,  in which case it may be of dimension <em>râ‹…c</em>)  and return a diagonal matrix with these elements.</p><p>See julia <a href="https://bit.ly/2Tbx8o7">tril(M, k::Integer)</a> function  for numbering of diagonals.</p><p>Bt default the main diagonal is considered.</p><ul><li>If the matrix is Diagonal (1) <span>$k$</span> must be zero (main diagonal).</li><li>If the matrix is lower triangular (2) <span>$k$</span> cannot be positive.</li></ul><p>Note that if <span>$X$</span> is rectangular the dimension of the result depends  on the size of <span>$X$</span> and on the chosen diagonal.  For example,</p><ul><li><em>r â‰  c</em> and <span>$k$</span>=0 (main diagonal), the result will be of dimension min<em>(r,c)</em>â‹…<em>min(r,c)</em>,</li><li><span>$X$</span> <em>3â‹…4</em> and <span>$k=-1$</span>, the result will be <em>2â‹…2</em>,</li><li><span>$X$</span> <em>3â‹…4</em> and <span>$k=1$</span>, the result will be <em>3â‹…3</em>, etc.</li></ul><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The function <code>func</code> must support the <code>func.</code> syntax and therefore must be able to apply element-wise to the elements of the chosen diagonal (this includes anonymous functions). If the input matrix is complex, the function <code>func</code> must be able to support complex arguments.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5) # use P=randP(ComplexF64, 5) for generating an Hermitian matrix
D=fDiagonal(inv, P, -1) # diagonal matrix with the inverse of the first sub-diagonal of P
(Î›, U) = evd(P)         # Î› holds the eigenvalues of P, see evd
Î”=fDiagonal(log, Î›)     # diagonal matrix with the log of the eigenvalues
Î”=fDiagonal(x-&gt;x^2, Î›)  # using an anonymous function for the square of the eigenvalues</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L531-L571">source</a></section><h2><a class="nav-anchor" id="Unitary-functions-of-matrices-1" href="#Unitary-functions-of-matrices-1">Unitary functions of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.mgs"><code>mgs</code></a></td><td>Modified Gram-Schmidt orthogonalization</td></tr></table><p>â‹…</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.mgs" href="#PosDefManifold.mgs"><code>PosDefManifold.mgs</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mgs(T::ğ•„, numCol::Int=0)</code></pre><p>Modified (stabilized) <a href="https://bit.ly/2YE6zvy">Gram-Schmidt orthogonalization</a>  of the columns of square or tall matrix <span>$T$</span>, which can be comprised of real  or complex elements.  The orthogonalized <span>$T$</span> is returned by the function. <span>$T$</span> is not changed.</p><p>All columns are orthogonalized by default. If instead argument <code>numCol</code> is provided,  then only the first <code>numCol</code> columns of <span>$T$</span> are orthogonalized.  In this case only the firt <code>numCol</code> columns will be returned.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
X=randn(10, 10);
U=mgs(X)        # result is 10â‹…10
U=mgs(X, 3)     # result is 10â‹…3
U&#39;*U â‰ˆ I ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
# julia undertands also:
U&#39;U â‰ˆ I ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L589-L610">source</a></section><h2><a class="nav-anchor" id="Matrix-function-of-matrices-1" href="#Matrix-function-of-matrices-1">Matrix function of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td>none for now</td><td>ipse lorem...</td></tr></table><p>â‹…</p><h2><a class="nav-anchor" id="Spectral-decompositions-of-positive-matrices-1" href="#Spectral-decompositions-of-positive-matrices-1">Spectral decompositions of positive matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.evd"><code>evd</code></a></td><td>Eigenvalue-Eigenvector decomposition of a matrix in <span>$UÎ›U&#39;=P$</span> form</td></tr><tr><td><a href="#PosDefManifold.spectralFunctions"><code>spectralFunctions</code></a></td><td>Mother function for creating spectral functions of eigenvalues</td></tr><tr><td><a href="#PosDefManifold.pow"><code>pow</code></a></td><td>Power of a positive matrix for any number of exponents in one pass</td></tr><tr><td><a href="#PosDefManifold.invsqrt"><code>invsqrt</code></a></td><td>Principal square root inverse (whitening) of a positive matrix</td></tr><tr><td><a href="#PosDefManifold.sqr"><code>sqr</code></a></td><td>Square of a positive matrix</td></tr><tr><td><a href="#PosDefManifold.powerIterations"><code>powerIterations</code></a>, <code>powIter</code></td><td>Power method for estimating any number of eigenvectors and associated eigenvalues</td></tr></table><p>â‹…</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.evd" href="#PosDefManifold.evd"><code>PosDefManifold.evd</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evd(S::â„)</code></pre><p>Given a positive semi-definite <code>Hermitian</code> matrix <span>$S$</span>,  returns a 2-tuple <span>$(Î›, U)$</span>, where <span>$U$</span> is the matrix holding in columns  the eigenvectors and <span>$Î›$</span> is the matrix holding the eigenvalues on the diagonal.  This is the output of Julia <code>eigen</code> function in <span>$UÎ›U&#39;=S$</span> form.</p><p>As for the <code>eigen</code> function, the eigenvalues and associated  eigenvectors are sorted by increasing values of eigenvalues.</p><p><span>$S$</span> must be flagged by Julia as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.spectralFunctions"><code>spectralFunctions</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
A=randn(3, 3);
S=â„(A+A&#39;);
Î›, U=evd(S); # which is equivalent to (Î›, U)=evd(P)
(U*Î›*U&#39;) â‰ˆ S ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
# =&gt; UÎ›U&#39;=S, UÎ›=SU, Î›U&#39;=U&#39;S</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L635-L658">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.spectralFunctions" href="#PosDefManifold.spectralFunctions"><code>PosDefManifold.spectralFunctions</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spectralFunctions(P::â„, func)</code></pre><p>This is the <em>mother function</em> for all spectral functions of eigenvalues implemented  in this library, which are:</p><ul><li><code>pow</code>     (power),</li><li><code>isqrt</code>   (inverse square root).</li></ul><p>The function <code>sqr</code> (square) does not use it, as it can be obtained more  efficiently by simple multiplication.</p><p>You can use this function if you need another spectral function of eigenvalues  besides those and those already implemented in the standard package <code>LinearAlgebra</code>.  In general, you won&#39;t call it directly.</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>Arguments</strong> <code>(P, func)</code>;</p><ul><li><span>$P$</span> is a positive matrix,</li><li><code>func</code> is the function that will be applied on the eigenvalues.</li></ul><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The function <code>func</code> must support the <code>func.</code> syntax and therefore must be able to apply element-wise to the eigenvalues (those include anonymous functions).</p></div></div><p><strong>Maths</strong></p><p>The definition of spectral functions for a positive definite matrix <span>$P$</span>  is at it follows:</p><p><span>$f\big(P\big)=Uf\big(Î›\big)U^H,$</span></p><p>where <span>$U$</span> is the matrix holding in columns the eigenvectors of <span>$P$</span>,  <span>$Î›$</span> is the matrix holding on diagonal its eigenvalues and <span>$f$</span> is  a function applying element-wise to the eigenvalues.</p><p><strong>See also</strong>: <a href="#PosDefManifold.evd"><code>evd</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
n=5
P=randP(n) # P=randP(ComplexF64, 5) to generate an Hermitian complex matrix
noise=0.1;
Q=spectralFunctions(P, x-&gt;x+noise) # add white noise to the eigenvalues
tr(Q)-tr(P) â‰ˆ noise*n ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L665-L713">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.pow" href="#PosDefManifold.pow"><code>PosDefManifold.pow</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pow(P::â„, p)        # one argument
pow(P::â„, args...)  # several arguments</code></pre><p>Given a positive definite <code>Hermitian</code> matrix <span>$P$</span>, return the power  <span>$P^{r_1}, P^{r_2},...$</span>  for any number of exponents <span>$r_1, r_2,...$</span>.  It returns a tuple of as many elements as arguments passed after <span>$P$</span>.</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>Arguments</strong> <code>(P, arg1, arg2,...)</code></p><ul><li><span>$P$</span> is a positive matrix.</li><li><span>$arg1, arg2,...$</span> are real numbers.</li></ul><p><strong>See also</strong>: <a href="#PosDefManifold.invsqrt"><code>invsqrt</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
P=randP(5);     # use P=randP(ComplexF64, 5) for generating an Hermitian matrix
Q=pow(P, 0.5);            # =&gt;  QQ=P
Q, W=pow(P, 0.5, -0.5);
W*P*W â‰ˆ I ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
Q*Q â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)
R, S=pow(P, 0.3, 0.7);
R*S â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L722-L749">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.invsqrt" href="#PosDefManifold.invsqrt"><code>PosDefManifold.invsqrt</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">invsqrt(P::â„)</code></pre><p>Given a positive definite <code>Hermitian</code> matrix <span>$P$</span>,  compute the inverse of the principal  square root <span>$P^{-1/2}$</span>.</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.pow"><code>pow</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
P=randP(ComplexF64, 5);
Q=invsqrt(P);
Q*P*Q â‰ˆ I ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L760-L779">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.sqr" href="#PosDefManifold.sqr"><code>PosDefManifold.sqr</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sqr(P::â„)</code></pre><p>Given a positive definite <code>Hermitian</code> matrix <span>$P$</span>, compute its square <span>$P^{2}$</span>.</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.pow"><code>pow</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5);
PÂ²=sqr(P);  # =&gt;  PÂ²=PP
sqrt(PÂ²)â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L783-L798">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.powerIterations" href="#PosDefManifold.powerIterations"><code>PosDefManifold.powerIterations</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">powerIterations(H::Union{â„, ğ•„}, q::Int;
                &lt;evalues=false, tol::Real=0, maxiter=300, â°=false&gt;)

powerIterations(L::ğ•ƒ{T}, q::Int;
                &lt;evalues=false, tol::Real=0, maxiter=300, â°=false)&gt; where T&lt;:Real</code></pre><p><strong>alias</strong>: <code>powIter</code></p><p>(1) Compute the <span>$q$</span> eigenvectors associated to the <span>$q$</span> largest (real) eigenvalues  of real or complex <code>Hermitian</code> matrix or <code>Matrix</code> <span>$H$</span> using the  <a href="https://bit.ly/2JSo0pb">power iterations</a> +  <a href="https://bit.ly/2YE6zvy">Gram-Schmidt orthogonalization</a> as suggested by Strang.  The eigenvectors are returned with the same type as the elements of <span>$H$</span>.</p><p><span>$H$</span> must have real eigenvalues, that is, it must be a symmetric matrix if it is real  or an Hermitian matrix if it is complex.</p><p>(2) as in (1), but using only the <code>LowerTriangular</code> view <span>$L$</span> of a matrix.  This option is available only for real matrices (see below).</p><p>The following are <em>&lt;optional keyword arguments&gt;</em>:</p><ul><li><span>$tol$</span> is the tolerance for the convergence of the power method (see below),</li><li><span>$maxiter$</span> is the maximum number of iterations allowed for the power method,</li><li>if <span>$â°=true$</span>, the convergence of all iterations will be printed,</li><li>if <span>$evalues=true$</span>, return the 4-tuple <span>$(Î›, U, iterations, covergence)$</span>,</li><li>if <span>$evalues=false$</span> return the 3-tuple <span>$(U, iterations, covergence)$</span>.</li></ul><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>Differently from the <a href="#PosDefManifold.evd"><code>evd</code></a> function, the eigenvectors and eigenvalues are sorted by decreasing order of eigenvalues.</p><p>If <span>$H$</span> is real, only its lower triangular part is used like in (2). In this case a BLAS routine is used for computing the power iterations. See <a href="../MainModule/#BLAS-routines-1">BLAS routines</a>.</p><p><span>$tol$</span> defaults to the square root of <code>Base.eps</code> of the type of <span>$H$</span>. This corresponds to requiring equality for the convergence criterion over two successive iterations of about half the significant digits.</p></div></div><p><strong>See also</strong>: <a href="#PosDefManifold.mgs"><code>mgs</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
# Generate an Hermitian (complex) matrix
H=randP(ComplexF64, 10);
# 3 eigenvectors and eigenvalues
U, iterations, convergence=powIter(H, 3, â°=true)
# all eigenvectors
Î›, U, iterations, convergence=powIter(H, size(H, 2), evalues=true, â°=true);
U&#39;*U â‰ˆ I &amp;&amp; U*Î›*U&#39;â‰ˆH ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)

# passing a `Matrix` object
Î›, U, iterations, convergence=powIter(Matrix(H), 3, evalues=true)

# passing a `LowerTriangular` object (must be a real matrix in this case)
L=ğ•ƒ(randP(10))
Î›, U, iterations, convergence=powIter(L, 3, evalues=true)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L802-L862">source</a></section><h2><a class="nav-anchor" id="Decompositions-involving-triangular-matrices-1" href="#Decompositions-involving-triangular-matrices-1">Decompositions involving triangular matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.choL"><code>choL</code></a></td><td>Lower triangula factor of Cholesky decomposition</td></tr></table><p>â‹…</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.choL" href="#PosDefManifold.choL"><code>PosDefManifold.choL</code></a> â€” <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">choL(P::â„)</code></pre><p>Given a real or complex positive definite <code>Hermitian</code> matrix <span>$P$</span>,  return the <em>Cholesky lower triangular factor</em> <span>$L$</span>  such that <span>$LL^H=P$</span>. To obtain <span>$L^H$</span> or both <span>$L$</span> and <span>$L^H$</span>, use instead  julia function <a href="https://bit.ly/2u9Hw5P">cholesky(P)</a>.</p><p>On output, <span>$L$</span> is of type <a href="https://bit.ly/2U511f3"><code>LowerTriangular</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5);
L=choL(P);
L*L&#39;â‰ˆ P ? println(&quot; â­ &quot;) : println(&quot; â›” &quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/53393d7ffee6f99db03fc2027842cfe7033dac15/src/linearAlgebra.jl#L912-L928">source</a></section><footer><hr/><a class="previous" href="../riemannianGeometry/"><span class="direction">Previous</span><span class="title">riemannianGeometry.jl</span></a><a class="next" href="../signalProcessing/"><span class="direction">Next</span><span class="title">signalProcessing.jl</span></a></footer></article></body></html>
