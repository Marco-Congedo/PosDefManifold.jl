<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>riemannianGeometry.jl ¬∑ PosDefManifold</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PosDefManifold logo"/></a><div class="docs-package-name"><span class="docs-autofit">PosDefManifold</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">PosDefManifold Documentation</a></li><li><a class="tocitem" href="../introToRiemannianGeometry/">Intro to Riemannian Geometry</a></li><li><a class="tocitem" href="../MainModule/">MainModule (PosDefManifold.jl)</a></li><li class="is-active"><a class="tocitem" href>riemannianGeometry.jl</a><ul class="internal"><li><a class="tocitem" href="#Geodesic-equations-1"><span>Geodesic equations</span></a></li><li><a class="tocitem" href="#Distances-1"><span>Distances</span></a></li><li><a class="tocitem" href="#Graphs-and-Laplacians-1"><span>Graphs and Laplacians</span></a></li><li><a class="tocitem" href="#Means-1"><span>Means</span></a></li><li><a class="tocitem" href="#Tangent-Space-operations-1"><span>Tangent Space operations</span></a></li><li><a class="tocitem" href="#Procrustes-problems-1"><span>Procrustes problems</span></a></li></ul></li><li><a class="tocitem" href="../linearAlgebra/">linearAlgebra.jl</a></li><li><a class="tocitem" href="../statistics/">statistics.jl</a></li><li><a class="tocitem" href="../signalProcessing/">signalProcessing.jl</a></li><li><a class="tocitem" href="../test/">test.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>riemannianGeometry.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>riemannianGeometry.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/master/docs/src/riemannianGeometry.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="riemannianGeometry.jl-1"><a class="docs-heading-anchor" href="#riemannianGeometry.jl-1">riemannianGeometry.jl</a><a class="docs-heading-anchor-permalink" href="#riemannianGeometry.jl-1" title="Permalink"></a></h1><p>This is the fundamental unit of <strong>PosDefManifold</strong>. It contains functions for manipulating points in the Riemannian manifold of <em>Symmetric Positive Definite (SPD)</em> or <em>Hermitian Positive Definite (HPD)</em> matrices. In Julia those are <code>Hermitian</code> matrices, see <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The functions are divided in six categories:</p><table><tr><th style="text-align: left">Category</th><th style="text-align: left">Output</th></tr><tr><td style="text-align: left">1. <a href="#Geodesic-equations-1">Geodesic equations</a></td><td style="text-align: left">interpolation, extrapolation, weighted mean of two matrices, ...</td></tr><tr><td style="text-align: left">2. <a href="#Distances-1">Distances</a></td><td style="text-align: left">length of geodesics</td></tr><tr><td style="text-align: left">3. <a href="#Graphs-and-Laplacians-1">Graphs and Laplacians</a></td><td style="text-align: left">inter-distance matrices, spectral embedding, eigenmaps, ...</td></tr><tr><td style="text-align: left">4. <a href="#Means-1">Means</a></td><td style="text-align: left">mid-points of geodesics, Fr√©chet means of several points, midrange,...</td></tr><tr><td style="text-align: left">5. <a href="#Tangent-Space-operations-1">Tangent Space operations</a></td><td style="text-align: left">maps from the manifold to the tangent space and viceversa, parallel transport,...</td></tr><tr><td style="text-align: left">6. <a href="#Procrustes-problems-1">Procrustes problems</a></td><td style="text-align: left">data matching, transfer learning (domain adaptation), ...</td></tr></table><p>‚ãÖ</p><h2 id="Geodesic-equations-1"><a class="docs-heading-anchor" href="#Geodesic-equations-1">Geodesic equations</a><a class="docs-heading-anchor-permalink" href="#Geodesic-equations-1" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.geodesic"><code>geodesic</code></a></td><td style="text-align: left">Geodesic equations (weighted mean of two positive definite matrices) for any metric</td></tr></table><p>‚ãÖ</p><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.geodesic" href="#PosDefManifold.geodesic"><code>PosDefManifold.geodesic</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(1) geodesic(metric::Metric, P::‚Ñç{T}, Q::‚Ñç{T}, a::Real) where T&lt;:RealOrComplex
(2) geodesic(metric::Metric, D::ùîª{S}, E::ùîª{S}, a::Real) where S&lt;:Real</code></pre><p>(1) Move along the <a href="../introToRiemannianGeometry/#geodesic-1">geodesic</a> from point <span>$P$</span> to point <span>$Q$</span>  (two positive definite matrices) with <em>arclegth</em> <span>$0&lt;=a&lt;=1$</span>,  using the specified metric, of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.</p><p>For all metrics,</p><ul><li>with <span>$a=0$</span> we stay at <span>$P$</span>,</li><li>with <span>$a=1$</span> we move up to <span>$Q$</span>,</li><li>with <span>$a=1/2$</span> we move to the mid-point of <span>$P$</span> and <span>$Q$</span> (mean).</li></ul><p>Using the Fisher metric, argument <span>$a$</span> can be <em>any</em> real number, for instance:</p><ul><li>with <span>$0&lt;a&lt;1$</span> we move toward <span>$Q$</span> (<em>attraction</em>),</li><li>with <span>$a&gt;1$</span> we move over and beyond <span>$Q$</span> (<em>extrapolation</em>),</li><li>with <span>$a&lt;0$</span> we move back away from Q (<em>repulsion</em>).</li></ul><p><span>$P$</span> and <span>$Q$</span> must be flagged by julia as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The Fisher geodesic move is computed by the Cholesky-Schur algorithm  given in Eq. 4.2 by Iannazzo(2016)<a href="../introToRiemannianGeometry/#-1">üéì</a>. If <span>$Q=I$</span>,  the Fisher geodesic move is simply <span>$P^a$</span> (no need to call this funtion).</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>For the <a href="../introToRiemannianGeometry/#logdet-zero-1">logdet zero</a> and <a href="../introToRiemannianGeometry/#Jeffrey-1">Jeffrey</a> metric no closed form expression for the geodesic is available to the best of authors&#39; knowledge, so in this case the geodesic is found as the weighted mean using the <a href="#Statistics.mean"><code>mean</code></a> function. For the <a href="../introToRiemannianGeometry/#Von-Neumann-1">Von Neumann</a> not even an expression for the mean is available, so in this case the geodesic is not provided and a <em>warning</em> is printed.</p></div></div><p>(2) Like in (1), but for two real positive definite diagonal matrices  <span>$D$</span> and <span>$E$</span>.</p><p><strong>Maths</strong></p><p>For points <span>$P$</span>, <span>$Q$</span> and arclength <span>$a$</span>, letting <span>$b=1-a$</span>,  the geodesic equations for the supported metrics are:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">geodesic equation</th></tr><tr><td style="text-align: center">Euclidean</td><td style="text-align: left"><span>$bP + aQ$</span></td></tr><tr><td style="text-align: center">invEuclidean</td><td style="text-align: left"><span>$\big(bP^{-1} + aQ^{-1}\big)^{-1}$</span></td></tr><tr><td style="text-align: center">ChoEuclidean</td><td style="text-align: left"><span>$TT^*$</span>, where <span>$T=bL_P + aL_Q$</span></td></tr><tr><td style="text-align: center">logEuclidean</td><td style="text-align: left"><span>$\text{exp}\big(b\hspace{2pt}\text{log}(P) + a\hspace{2pt}\text{log}(Q)\big)$</span></td></tr><tr><td style="text-align: center">logCholesky</td><td style="text-align: left"><span>$TT^*$</span>, where <span>$T=S_P+a(S_Q-S_P)+D_P\hspace{2pt}\text{exp}\big(a(\text{log}D_Q-\text{log}D_P)\big)$</span></td></tr><tr><td style="text-align: center">Fisher</td><td style="text-align: left"><span>$P^{1/2} \big(P^{-1/2} Q P^{-1/2}\big)^a P^{1/2}$</span></td></tr><tr><td style="text-align: center">logdet0</td><td style="text-align: left">uses weighted mean algorithm <a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a></td></tr><tr><td style="text-align: center">Jeffrey</td><td style="text-align: left">uses weighted mean <a href="#Statistics.mean"><code>mean</code></a></td></tr><tr><td style="text-align: center">VonNeumann</td><td style="text-align: left">N.A.</td></tr><tr><td style="text-align: center">Wasserstein</td><td style="text-align: left"><span>$b^2P+a^2Q +ab\big[(PQ)^{1/2} +(QP)^{1/2}\big]$</span></td></tr></table><p><strong>legend:</strong> <span>$L_X$</span>, <span>$S_X$</span> and <span>$D_X$</span>    are the Cholesky lower triangle of <span>$X$</span>, its strictly lower triangular part    and diagonal part, respectively (hence, <span>$S_X+D_X=L_X$</span>,  <span>$L_XL_X^*=X$</span>).</p><p><strong>See also</strong>: <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(10)
Q=randP(10)
# Wasserstein mean
M=geodesic(Wasserstein, P, Q, 0.5)
# extrapolate suing the Fisher metric
E=geodesic(Fisher, P, Q, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L81-L150">source</a></section></article><h2 id="Distances-1"><a class="docs-heading-anchor" href="#Distances-1">Distances</a><a class="docs-heading-anchor-permalink" href="#Distances-1" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.distanceSqr"><code>distanceSqr</code></a>, <code>distance¬≤</code></td><td style="text-align: left">Squared distance between positive definite matrices</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.distance"><code>distance</code></a></td><td style="text-align: left">Distance between positive definite matrices</td></tr></table><p>‚ãÖ</p><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.distanceSqr" href="#PosDefManifold.distanceSqr"><code>PosDefManifold.distanceSqr</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(1) distanceSqr(metric::Metric, P::‚Ñç{T}) where T&lt;:RealOrComplex
(2) distanceSqr(metric::Metric, P::‚Ñç{T}, Q::‚Ñç{T}) where T&lt;:RealOrComplex
(3) distanceSqr(metric::Metric, D::ùîª{S}) where S&lt;:Real
(4) distanceSqr(metric::Metric, D::ùîª{S}, E::ùîª{S}) where S&lt;:Real</code></pre><p><strong>alias</strong>: <code>distance¬≤</code></p><p>(1) Return <span>$Œ¥^2(P, I)$</span>, the <em>square of the distance</em> (or <em>divergence</em>) of positive definite  matrix <span>$P$</span> from the the identity matrix. See <a href="../introToRiemannianGeometry/#distance-from-the-origin-1">distance from the origin</a>.</p><p>(2) Return <span>$Œ¥^2(P, Q)$</span>, the <em>square of the distance</em> (or <em>divergence</em>) between two  positive definite matrices <span>$P$</span> and <span>$Q$</span>. See <a href="../introToRiemannianGeometry/#distance-1">distance</a>.</p><p>In both cases the distance function <span>$Œ¥$</span> is induced by the argument <code>metric</code> of type  <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.</p><p><span>$P$</span> in (1) and <span>$P$</span>, <span>$Q$</span> in (2) must be flagged by julia as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>(3) and (4) are specialized methods of (1) and (2), respectively,  for real positive definite <code>Diagonal</code> matrices.  See <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a> and <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a>.</p><p><strong>Maths</strong></p><p>For point <span>$P$</span> the <em>squared distances from the identity</em>  for the supported metrics are:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">Squared Distance from the identity</th></tr><tr><td style="text-align: center">Euclidean</td><td style="text-align: left"><span>$‚à•P-I‚à•^2$</span></td></tr><tr><td style="text-align: center">invEuclidean</td><td style="text-align: left"><span>$‚à•P^{-1}-I‚à•^2$</span></td></tr><tr><td style="text-align: center">ChoEuclidean</td><td style="text-align: left"><span>$‚à•L_P-I‚à•^2$</span></td></tr><tr><td style="text-align: center">logEuclidean</td><td style="text-align: left"><span>$‚à•\textrm{log}P‚à•^2$</span></td></tr><tr><td style="text-align: center">logCholesky</td><td style="text-align: left"><span>$‚à•S_P‚à•^2+‚à•\textrm{log}D_P‚à•^2$</span></td></tr><tr><td style="text-align: center">Fisher</td><td style="text-align: left"><span>$‚à•\textrm{log}P‚à•^2$</span></td></tr><tr><td style="text-align: center">logdet0</td><td style="text-align: left"><span>$\textrm{logdet}\frac{1}{2}(P+I) - \frac{1}{2}\textrm{logdet}(P)$</span></td></tr><tr><td style="text-align: center">Jeffrey</td><td style="text-align: left"><span>$\frac{1}{2}\textrm{tr}(P+P^{-1})-n$</span></td></tr><tr><td style="text-align: center">VonNeumann</td><td style="text-align: left"><span>$\frac{1}{2}\textrm{tr}(P\textrm{log}P-\textrm{log}P)$</span></td></tr><tr><td style="text-align: center">Wasserstein</td><td style="text-align: left"><span>$\textrm{tr}(P+I) -2\textrm{tr}(P^{1/2})$</span></td></tr></table><p>For points <span>$P$</span> and <span>$Q$</span> their <em>squared distances</em> for the supported metrics are:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">Squared Distance</th></tr><tr><td style="text-align: center">Euclidean</td><td style="text-align: left"><span>$‚à•P-Q‚à•^2$</span></td></tr><tr><td style="text-align: center">invEuclidean</td><td style="text-align: left"><span>$‚à•P^{-1}-Q^{-1}‚à•^2$</span></td></tr><tr><td style="text-align: center">ChoEuclidean</td><td style="text-align: left"><span>$‚à• L_P - L_Q ‚à•^2$</span></td></tr><tr><td style="text-align: center">logEuclidean</td><td style="text-align: left"><span>$‚à•\textrm{log}P-\textrm{log}Q‚à•^2$</span></td></tr><tr><td style="text-align: center">logCholesky</td><td style="text-align: left"><span>$‚à•S_P-S_Q‚à•^2+‚à•\textrm{log}D_P-\textrm{log}D_Q‚à•^2$</span></td></tr><tr><td style="text-align: center">Fisher</td><td style="text-align: left"><span>$‚à•\textrm{log}(P^{-1/2}QP^{-1/2})‚à•^2$</span></td></tr><tr><td style="text-align: center">logdet0</td><td style="text-align: left"><span>$\textrm{logdet}\frac{1}{2}(P+Q) - \frac{1}{2}\textrm{logdet}(PQ)$</span></td></tr><tr><td style="text-align: center">Jeffrey</td><td style="text-align: left"><span>$\frac{1}{2}\textrm{tr}(Q^{-1}P+P^{-1}Q)-n$</span></td></tr><tr><td style="text-align: center">VonNeumann</td><td style="text-align: left"><span>$\frac{1}{2}\textrm{tr}(P\textrm{log}P-P\textrm{log}Q+Q\textrm{log}Q-Q\textrm{log}P)$</span></td></tr><tr><td style="text-align: center">Wasserstein</td><td style="text-align: left"><span>$\textrm{tr}(P+Q) -2\textrm{tr}(P^{1/2}QP^{1/2})^{1/2}$</span></td></tr></table><p><strong>legend:</strong> <span>$L_X$</span>, <span>$S_X$</span> and <span>$D_X$</span>   are the Cholesky lower triangle of <span>$X$</span>, its strictly lower triangular part   and diagonal part, respectively (hence, <span>$S_X+D_X=L_X$</span>,  <span>$L_XL_X^*=X$</span>).</p><p><strong>See also</strong>: <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>.</p><p><strong>Examples (1)</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(10)
d=distanceSqr(Wasserstein, P)
e=distanceSqr(Fisher, P)
metric=Metric(Int(logdet0)) # or metric=logdet0
s=string(metric) # check what is the current metric
f=distance¬≤(metric, P) #using the alias distance¬≤</code></pre><p><strong>Examples (2)</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(10)
Q=randP(10)
d=distanceSqr(logEuclidean, P, Q)
e=distance¬≤(Jeffrey, P, Q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L240-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.distance" href="#PosDefManifold.distance"><code>PosDefManifold.distance</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(1) distance(metric::Metric, P::‚Ñç{T}) where T&lt;:RealOrComplex
(2) distance(metric::Metric, P::‚Ñç{T}, Q::‚Ñç{T}) where T&lt;:RealOrComplex
(3) distance(metric::Metric, D::ùîª{S}) where S&lt;:Real
(4) distance(metric::Metric, D::ùîª{S}, E::ùîª{S}) where S&lt;:Real</code></pre><p>(1) Return <span>$Œ¥(P, I)$</span>, the <em>distance</em> between positive definite matrix <span>$P$</span> and  the identity matrix.</p><p>(2) Return <span>$Œ¥(P, Q)$</span>, the <em>distance</em> between positive definite  matrices <span>$P$</span> and <span>$Q$</span>.</p><p>(3) and (4) are specialized methods of (1) and (2), respectively,  for real positive definite <code>Diagonal</code> matrices.</p><p>This is the square root of <a href="#PosDefManifold.distanceSqr"><code>distanceSqr</code></a>  and is invoked with the same syntax therein.</p><p><strong>See also</strong>: <a href="#PosDefManifold.distanceMat"><code>distanceMat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L445-L464">source</a></section></article><h2 id="Graphs-and-Laplacians-1"><a class="docs-heading-anchor" href="#Graphs-and-Laplacians-1">Graphs and Laplacians</a><a class="docs-heading-anchor-permalink" href="#Graphs-and-Laplacians-1" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>, <code>distance¬≤Mat</code></td><td style="text-align: left">Lower triangular matrix of all squared inter-distances</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.distanceMat"><code>distanceMat</code></a></td><td style="text-align: left">Lower triangular matrix of all inter-distances</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.laplacian"><code>laplacian</code></a></td><td style="text-align: left">Laplacian of a squared inter-distances matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a>, <code>laplacianEM</code></td><td style="text-align: left">Eigen maps (eigenvectors) of a Laplacian</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.spectralEmbedding"><code>spectralEmbedding</code></a>, <code>spEmb</code></td><td style="text-align: left">Spectral Embedding (the above functions run in series)</td></tr></table><p>‚ãÖ</p><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.distanceSqrMat" href="#PosDefManifold.distanceSqrMat"><code>PosDefManifold.distanceSqrMat</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    (1) distanceSqrMat(metric::Metric, ùêè::‚ÑçVector;
    &lt;‚è©=true&gt;)

    (2) distanceSqrMat(type::Type{T}, metric::Metric, ùêè::‚ÑçVector;
    &lt;‚è©=true&gt;) where T&lt;:AbstractFloat</code></pre><p><strong>alias</strong>: <code>distance¬≤Mat</code></p><p>Given a 1d array <span>$ùêè$</span> of <span>$k$</span> positive definite matrices  <span>${P_1,...,P_k}$</span> of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>, create the <span>$k‚ãÖk$</span> real  <code>LowerTriangular</code> matrix comprising elements <span>$Œ¥^2(P_i, P_j)\textrm{, for all }i&gt;=j$</span>.</p><p>This is the lower triangular matrix holding all <em>squared inter-distances</em>  (zero on diagonal), using the  specified <code>metric</code>, of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>,  giving rise to distance function <span>$Œ¥$</span>. See <a href="#PosDefManifold.distanceSqr"><code>distanceSqr</code></a>.</p><p>Only the lower triangular part is computed in order to optimize memory use.</p><p>By default, the result matrix is of type <code>Float32</code>. The type can be changed  to another real <code>type</code> using method (2).</p><p>&lt;optional keyword arguments&gt;:</p><ul><li>if ‚è©=true (default) the computation of inter-distances is multi-threaded.</li></ul><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p></div></div><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#distance-1">distance</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.laplacian"><code>laplacian</code></a>, <a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a>, <a href="#PosDefManifold.spectralEmbedding"><code>spectralEmbedding</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 8 random 10x10 SPD matrices
Pset=randP(10, 8) # or, using unicode: ùêè=randP(10, 8)
# Compute the squared inter-distance matrix according to the log Euclidean metric.
# This is much faster as compared to the Fisher metric and in general
# it is a good approximation.
Œî¬≤=distanceSqrMat(logEuclidean, Pset)

# return a matrix of type Float64
Œî¬≤64=distanceSqrMat(Float64, logEuclidean, Pset)

# Get the full matrix of inter-distances
fullŒî¬≤=Hermitian(Œî¬≤, :L)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L477-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.distanceMat" href="#PosDefManifold.distanceMat"><code>PosDefManifold.distanceMat</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    (1) distanceMat(metric::Metric, ùêè::‚ÑçVector;
    &lt;‚è©=true&gt;)

    (2) distanceMat(type::Type{T}, metric::Metric, ùêè::‚ÑçVector;
    &lt;‚è©=true&gt;) where T&lt;:AbstractFloat</code></pre><p>Given a 1d array <span>$ùêè$</span> of <span>$k$</span> positive definite matrices  <span>${P_1,...,P_k}$</span> of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>, create the <span>$k‚ãÖk$</span> real  <code>LowerTriangular</code> matrix comprising elements  <span>$Œ¥(P_i, P_j)\textrm{, for all }i&gt;=j$</span>.</p><p>This is the lower triangular matrix holding all <em>inter-distances</em>  (zero on diagonal), using the  specified <code>metric</code>, of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>,  giving rise to distance <span>$Œ¥$</span>. See <a href="#PosDefManifold.distance"><code>distance</code></a>.</p><p>Only the lower triangular part is computed in order to optimize memory use.</p><p>By default, the result matrix is of type <code>Float32</code>. The type can be changed  to another real <code>type</code> using method (2).</p><p>The elements of this matrix are the square root of  <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>.</p><p>&lt;optional keyword arguments&gt;:</p><ul><li>if ‚è©=true the computation of inter-distances is multi-threaded.</li></ul><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p></div></div><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#distance-1">distance</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 4 random 10x10 SPD matrices
Pset=randP(10, 4) # or, using unicode: ùêè=randP(10, 4)
Œî=distanceMat(Fisher, Pset)

# return a matrix of type Float64
Œî64=distanceMat(Float64, Fisher, Pset)

# Get the full matrix of inter-distances
fullŒî=Hermitian(Œî, :L)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L634-L683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.laplacian" href="#PosDefManifold.laplacian"><code>PosDefManifold.laplacian</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">laplacian(Œî¬≤::ùïÉ{S}, epsilon::Real=0;
          &lt;densityInvariant=false&gt;) where S&lt;:Real</code></pre><p>Given a <code>LowerTriangular</code> matrix of squared inter-distances <span>$Œî^2$</span>,  return the lower triangular part of the so-called  <em>normalized Laplacian</em> or <em>density-invariant normalized Laplacian</em>,  which in both cases is a symmetric Laplacian.  The elements of the Laplacian are of the same type as the elements of <span>$Œî^2$</span>.  The result is a <code>LowerTriangular</code> matrix.</p><p>The definition of Laplacian given by Lafon (2004)<a href="../introToRiemannianGeometry/#-1">üéì</a> is implemented:</p><p>First, a <a href="https://bit.ly/1HVyf55">Gaussian radial basis functions</a>,  known as <em>Gaussian kernel</em> or <em>heat kernel</em>,  is applied to all elements of <span>$Œî^2$</span>, such as</p><p><span>$W_{ij} = exp\bigg(\frac{\displaystyle{-Œî^2_{ij}}}{\displaystyle{2Œµ}}\bigg)$</span>,</p><p>where <span>$Œµ$</span> is the <em>bandwidth</em> of the kernel.</p><p>If &lt;optional keyword argument&gt; <code>densityInvariant=true</code> is used,   then the density-invariant transformation is applied</p><p><span>$W &lt;- E^{-1}WE^{-1}$</span></p><p>where <span>$E$</span> is the diagonal matrix holding on the main diagonal   the sum of the rows (or columns) of <span>$W$</span>.</p><p>Finally, the normalized Laplacian (density-invariant or not) is defined as</p><p><span>$Œ© = D^{-1/2}WD^{-1/2}$</span>,</p><p>where <span>$D$</span> is the diagonal matrix holding on the main diagonal   the sum of the rows (or columns) of <span>$W$</span>.</p><p>If you do not provide argument <code>epsilon</code>, the bandwidth <span>$Œµ$</span> is set to the   median of the elements of squared distance matrix <span>$Œî^2_{ij}$</span>.   Another educated guess is the dimension of the original data, that is,   the data that has been used to compute the squared distance matrix.   For positive definite matrices this is <span>$n(n-1)/2$</span>, where <span>$n$</span> is the   dimension of the matrices. Still another is the dimension of the ensuing   <a href="#PosDefManifold.spectralEmbedding"><code>spectralEmbedding</code></a> space.   Keep in mind that by tuning the <code>epsilon</code> parameter   (which must be positive) you can control both the rate of compression of the   embedding space and the spread of points in the embedding space.   See Coifman et <em>al.</em> (2008)<a href="../introToRiemannianGeometry/#-1">üéì</a> for a discussion on <span>$Œµ$</span>.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>The Laplacian as here defined can be requested for any input matrix of squared inter-distances, for example, those obtained on scalars or on vectors using appropriate metrics. In any case, only the lower triangular part of the Laplacian is taken as input. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p></div></div><p><strong>See also</strong>: <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>, <a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a>, <a href="#PosDefManifold.spectralEmbedding"><code>spectralEmbedding</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 4 random 10x10 SPD matrices
Pset=randP(10, 4) # or, using unicode: ùêè=randP(10, 4)
Œî¬≤=distanceSqrMat(Fisher, Pset)
Œ©=laplacian(Œî¬≤)

# density-invariant Laplacian
Œ©=laplacian(Œî¬≤; densityInvariant=true)

# increase the bandwidth
r=size(Œî¬≤, 1)
myŒµFactor=0.1
med=Statistics.median([Œî¬≤[i, j] for j=1:r-1 for i=j+1:r])
Œµ=2*myŒµFactor*med
Œ©=laplacian(Œî¬≤, Œµ; densityInvariant=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L693-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.laplacianEigenMaps" href="#PosDefManifold.laplacianEigenMaps"><code>PosDefManifold.laplacianEigenMaps</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    laplacianEigenMaps(Œ©::ùïÉ{S}, q::Int;
    &lt;
    tol::Real=0.,
    maxiter::Int=300,
    verbose=false &gt;) where S&lt;:Real</code></pre><p><strong>alias</strong>: <code>laplacianEM</code></p><p>Given the lower triangular part of a Laplacian <span>$Œ©$</span>  (see <a href="#PosDefManifold.laplacian"><code>laplacian</code></a> ) return the <em>eigen maps</em> in <span>$q$</span> dimensions,  i.e., the <span>$q$</span> eigenvectors of the Laplacian associated with the largest <span>$q$</span>  eigenvalues, excluding the first (which is always equal to 1.0).  The eigenvectors are of the same type as <span>$Œ©$</span>. They are all divided  element-wise by the first eigenvector (see Lafon, 2004<a href="../introToRiemannianGeometry/#-1">üéì</a>).</p><p>The eigenvectors of the Laplacian are computed by the  power iterations+modified Gram-Schmidt method (see <a href="../linearAlgebra/#PosDefManifold.powerIterations"><code>powerIterations</code></a>),  allowing the execution of this function for Laplacian matrices of very large size.</p><p>Return the 4-tuple <span>$(Œõ, U, iterations, convergence)$</span>, where:</p><ul><li><span>$Œõ$</span> is a <span>$q‚ãÖq$</span> diagonal matrix holding on diagonal the eigenvalues corresponding to the <span>$q$</span> dimensions of the Laplacian eigen maps,</li><li><span>$U$</span> holds in columns the <span>$q$</span> eigenvectors holding the <span>$q$</span> coordinates of the points in the embedding space,</li><li><span>$iterations$</span> is the number of iterations executed by the power method,</li><li><span>$convergence$</span> is the convergence attained by the power method.</li></ul><p>Using the notion of Laplacian, spectral embedding seek a  low-dimension representation of the data emphasizing local neighbothood  information while neglecting long-distance information.  The embedding is non-linear, however the embedding space is Euclidean.  The eigenvectors of <span>$U$</span> holds the coordinates of the points in the  embedding space (typically two- or three-dimensional for plotting or more  for clustering). Spectral embedding is done for plotting data in low-dimension,  clustering, imaging, classification, following their trajectories over time  or other dimensions, and much more.  For examples of applications see Ridrigues et <em>al.</em> (2018) <a href="../introToRiemannianGeometry/#-1">üéì</a>  and references therein.</p><p><strong>Arguments</strong>:</p><ul><li><span>$Œ©$</span> is a real <code>LowerTriangular</code> normalized Laplacian obtained by the <a href="#PosDefManifold.laplacian"><code>laplacian</code></a> function,</li><li><span>$q$</span> is the dimension of the Laplacian eigen maps;</li><li>The following are <em>&lt;optional keyword arguments&gt;</em> for the power iterations:<ul><li><code>tol</code> is the tolerance for convergence (see below),</li><li><code>maxiter</code> is the maximum number of iterations allowed,</li><li>if <code>verbose</code> is true, the convergence at all iterations will be printed.</li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>The maximum value of <span>$q$</span> that can be requested is <span>$n-1$</span>, where <span>$n$</span> is the size of the Laplacian. In general, <span>$q=2$</span> or <span>$q=3$</span> is requested.</p><p><span>$tol$</span> defaults to the square root of <code>Base.eps</code> of the (real) type of <span>$Œ©$</span>. This corresponds to requiring equality for the convergence criterion over two successive power iterations of about half of the significant digits.</p></div></div><p><strong>See also</strong>: <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>, <a href="#PosDefManifold.laplacian"><code>laplacian</code></a>, <a href="#PosDefManifold.spectralEmbedding"><code>spectralEmbedding</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 4 random 10x10 SPD matrices
Pset=randP(10, 4)
Œî¬≤=distanceSqrMat(Fisher, Pset)
Œ©=laplacian(Œî¬≤)
evalues, maps, iterations, convergence=laplacianEM(Œ©, 2)
evalues, maps, iterations, convergence=laplacianEM(Œ©, 2; verbose=true)
evalues, maps, iterations, convergence=laplacianEM(Œ©, 2; verbose=true, maxiter=500)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L799-L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.spectralEmbedding" href="#PosDefManifold.spectralEmbedding"><code>PosDefManifold.spectralEmbedding</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    (1) spectralEmbedding(metric::Metric, ùêè::‚ÑçVector, q::Int, epsilon::Real=0;
    &lt;
    tol::Real=0.,
    maxiter::Int=300,
    densityInvariant=false,
    verbose=false,
    ‚è©=true &gt;)

    (2) spectralEmbedding(type::Type{T}, metric::Metric, ùêè::‚ÑçVector, q::Int, epsilon::Real=0;
    &lt; same optional keyword arguments as in (1) &gt;) where T&lt;:Real</code></pre><p><strong>alias</strong>: <code>spEmb</code></p><p>Given a 1d array <span>$ùêè$</span> of <span>$k$</span> positive definite matrices <span>${P_1,...,P_k}$</span>  (real or complex), compute its <em>eigen maps</em> in <span>$q$</span> dimensions.</p><p>This function runs one after the other the functions:</p><ul><li><a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a> (compute the squared inter-distance matrix),</li><li><a href="#PosDefManifold.laplacian"><code>laplacian</code></a> (compute the normalized Laplacian),</li><li><a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a> (get the eigen maps).</li></ul><p>By default all computations above are done with <code>Float32</code> precision.  Another real type can be requested using method (2), where the <code>type</code> argument  is defined.</p><p>Return the 4-tuple <code>(Œõ, U, iterations, convergence)</code>, where:</p><ul><li><span>$Œõ$</span> is a <span>$q‚ãÖq$</span> diagonal matrix holding on diagonal the eigenvalues corresponding to the <span>$q$</span> dimensions of the Laplacian eigen maps,</li><li><span>$U$</span> holds in columns the <span>$q$</span> eigenvectors holding the <span>$q$</span> coordinates of the points in the embedding space,</li><li><span>$iterations$</span> is the number of iterations executed by the power method,</li><li><span>$convergence$</span> is the convergence attained by the power method.</li></ul><p><strong>Arguments</strong>:</p><ul><li><code>metric</code> is the metric of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a> used for computing the inter-distances,</li><li><span>$ùêè$</span> is a 1d array of <span>$k$</span> positive matrices of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>,</li><li><span>$q$</span> is the dimension of the Laplacian eigen maps,</li><li><span>$epsilon$</span> is the bandwidth of the Laplacian (see <a href="#PosDefManifold.laplacian"><code>laplacian</code></a>);</li><li>The following <em>&lt;optional keyword argument&gt;</em> applyies for computing the inter-distances:<ul><li>if <code>‚è©=true</code> (default) the computation of inter-distances is multi-threaded.</li></ul></li><li>The following <em>&lt;optional keyword argument&gt;</em> applyies to the computation of the Laplacian by the <a href="#PosDefManifold.laplacian"><code>laplacian</code></a> function:<ul><li>if <code>densityInvariant=true</code> the density-invariant Laplacian is computed (see <a href="#PosDefManifold.laplacian"><code>laplacian</code></a>).</li></ul></li><li>The following are <em>&lt;optional keyword arguments&gt;</em> for the power method iterative algorithm invoked by <a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a>:<ul><li><code>tol</code> is the tolerance for convergence of the power method (see below),</li><li><code>maxiter</code> is the maximum number of iterations allowed for the power method,</li><li>if <code>verbose=true</code> the convergence at all iterations will be printed;</li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><span>$tol$</span> defaults to the square root of <code>Base.eps</code> of the <code>Float32</code> type (1) or of the <code>type</code> passed as argumant (2). This corresponds to requiring equality for the convergence criterion over two successive power iterations of about half of the significant digits.</p><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p></div></div><p><strong>See also</strong>: <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>, <a href="#PosDefManifold.laplacian"><code>laplacian</code></a>, <a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of k random 10x10 SPD matrices
k=10
Pset=randP(10, k)
evalues, maps, iter, conv=spectralEmbedding(Fisher, Pset, 2)

# show convergence information
evalues, maps, iter, conv=spectralEmbedding(Fisher, Pset, 2; verbose=true)

# use Float64 precision.
evalues, maps, iter, conv=spectralEmbedding(Float64, Fisher, Pset, 2)

using Plots
# check eigevalues and eigenvectors
plot(diag(evalues))
plot(maps[:, 1])
plot!(maps[:, 2])
plot!(maps[:, 3])

# plot the data in the embedded space
plot(maps[:, 1], maps[:, 2], seriestype=:scatter, title=&quot;Spectral Embedding&quot;, label=&quot;Pset&quot;)

# try a different value of epsilon
evalues, maps, iter, conv=spEmb(Fisher, Pset, k-1, 0.01; maxiter=1000)
plot(maps[:, 1], maps[:, 2], seriestype=:scatter, title=&quot;Spectral Embedding&quot;, label=&quot;Pset&quot;)
# see the example in `Laplacian` function for more on this</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L886-L975">source</a></section></article><h2 id="Means-1"><a class="docs-heading-anchor" href="#Means-1">Means</a><a class="docs-heading-anchor-permalink" href="#Means-1" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#Statistics.mean"><code>mean</code></a></td><td style="text-align: left">Weighted Fr√©chet mean (wFm) of a scalar or matrix set using any metric</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.means"><code>means</code></a></td><td style="text-align: left">As above for several sets at once</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.generalizedMean"><code>generalizedMean</code></a></td><td style="text-align: left">Generalized wFm of a matrix set</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.geometricMean"><code>geometricMean</code></a>, <code>gMean</code></td><td style="text-align: left">wFm of a matrix set minimizing the dispersion according to the Fisher metric (iterative)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.geometricpMean"><code>geometricpMean</code></a>, <code>gpMean</code></td><td style="text-align: left">robust wFm of a matrix set minimizing the p-dispersion according to the Fisher metric (iterative)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a>, <code>ld0Mean</code></td><td style="text-align: left">wFm of a matrix set according to the logdet0 metric (iterative)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.wasMean"><code>wasMean</code></a></td><td style="text-align: left">wFm of a matrix set according to the Wasserstein metric (iterative)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.powerMean"><code>powerMean</code></a></td><td style="text-align: left">Power wFm of a matrix set (iterative)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.inductiveMean"><code>inductiveMean</code></a>, <code>indMean</code></td><td style="text-align: left">Recursive Fr√©chet mean of a matrix set (constructive)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.midrange"><code>midrange</code></a></td><td style="text-align: left">Geometric midrange of two matrices</td></tr></table><p>‚ãÖ</p><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    (1) mean(metric::Metric, P::‚Ñç{T}, Q::‚Ñç{T}) where T&lt;:RealOrComplex

    (2) mean(metric::Metric, D::ùîª{T}, E::ùîª{T}) where T&lt;:Real

    (3) mean(metric::Metric, ùêè::‚ÑçVector;
        &lt;
        w::Vector=[],
        ‚úìw=true,
        init::Union{‚Ñç, Nothing}=nothing,
        tol::Real=0.,
        verbose=false,
        ‚è©=true &gt;)

    (4) mean(metric::Metric, ùêÉ::ùîªVector;
    &lt; same optional keyword arguments as in (3) &gt;)</code></pre><p>(1) Mean of two positive definite matrices, passed in arbitrary order as  arguments <span>$P$</span> and <span>$Q$</span>, using the specified <code>metric</code> of type  <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>. The order is arbitrary as all metrics  implemented in <strong>PosDefManifold</strong> are symmetric.  This is the midpoint of the geodesic.  For the weighted mean of two positive definite matrices use instead  the <a href="#PosDefManifold.geodesic"><code>geodesic</code></a> function.  <span>$P$</span> and <span>$Q$</span> must be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>(2) Like in (1), but for two real diagonal positive definite matrices  <span>$D$</span> and <span>$E$</span>.</p><p>(3) <a href="../introToRiemannianGeometry/#Fr√©chet-mean-1">Fr√©chet mean</a> of an 1d array <span>$ùêè$</span> of <span>$k$</span> positive definite  matrices <span>$ùêè={P_1,...,P_k}$</span> of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>,  with optional non-negative real weights <span>$w={w_1,...,w_k}$</span> and using the  specified <code>metric</code>as in (1).</p><p>(4) <a href="../introToRiemannianGeometry/#Fr√©chet-mean-1">Fr√©chet mean</a> of an 1d array <span>$ùêÉ$</span> of <span>$k$</span> positive definite  matrices <span>$ùêÉ={D_1,...,D_k}$</span> of <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a>,  with optional non-negative real weights <span>$w={w_1,...,w_k}$</span> and using the  specified <code>metric</code>as in (1).</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted mean</em>.</p><p>If <em>&lt;optional keyword argument&gt;</em> <code>‚úìw=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>Adopting the <code>Fisher</code>, <code>logdet0</code> and <code>Wasserstein</code> metric in (3) and the  <code>logdet0</code> metric in (4), the mean is computed by means of an iterative  algorithm. A particular initialization for these algorithms can be  provided passing an Hermitian matrix as <em>&lt;optional keyword argument&gt;</em> <code>init</code>.  The convergence for these algorithm is required with a tolerance  given by <em>&lt;optional keyword argument&gt;</em> <code>tol</code>.  if <code>verbose=true</code> the covergence attained at each iteration is printed.  Other information such as if the algorithm has diverged is also printed.  For more options in computing these means call directly  functions <a href="#PosDefManifold.geometricMean"><code>geometricMean</code></a>, <a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a>  and <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>, which are called hereby.  For the meaning of the <code>tol</code> default value see the documentation of  these functions. See also the robust mean function <a href="#PosDefManifold.geometricpMean"><code>geometricpMean</code></a>,  which cannot be called from here. Notice that arguments <code>init</code> and <code>tol</code>  have an effect only for the aferomentioned metrics in methods (3) and (4).</p><p>For (3) and (4), if <code>‚è©=true</code> (default),  the computation of the mean is multi-threaded for all metrics.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p></div></div><p><strong>Math</strong></p><p>The Fr√©chet mean of a set of <span>$k$</span> matrices <span>${P_1, P_2,..., P_k}$</span> weighted by  <span>${w_1, w_2,..., w_k}:\sum_{i=1}^{k}w_i=1$</span> for the supported metrics are,  for those with closed form expression:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">weighted Fr√©chet mean</th></tr><tr><td style="text-align: center">Euclidean</td><td style="text-align: left"><span>$\sum_{i=1}^{k}w_i P_i$</span></td></tr><tr><td style="text-align: center">invEuclidean</td><td style="text-align: left"><span>$\big(\sum_{i=1}^{k}w_i P_i^{-1}\big)^{-1}$</span></td></tr><tr><td style="text-align: center">ChoEuclidean</td><td style="text-align: left"><span>$TT^*$</span>, where <span>$T=bL_P + aL_Q$</span></td></tr><tr><td style="text-align: center">logEuclidean</td><td style="text-align: left"><span>$\textrm{exp}\big(\sum_{i=1}^{k}w_i\hspace{1pt} \textrm{log}P_i \big)$</span></td></tr><tr><td style="text-align: center">logCholesky</td><td style="text-align: left"><span>$TT^*$</span>, where <span>$T=\sum_{i=1}^{k}(w_kS_k)+\sum_{i=1}^{k}(w_k\textrm{log}D_k)$</span></td></tr><tr><td style="text-align: center">Jeffrey</td><td style="text-align: left"><span>$A^{1/2}\big(A^{-1/2}HA^{-1/2}\big)^{1/2}A^{1/2}$</span></td></tr></table><p>and for those that are found by an iterative algorithm and that verify an equation:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">equation verified by the weighted Fr√©chet mean</th></tr><tr><td style="text-align: center">Fisher</td><td style="text-align: left"><span>$\sum_{i=1}^{k}w_i\textrm{log}\big(G^{-1/2} P_k G^{-1/2}\big)=0.$</span></td></tr><tr><td style="text-align: center">logdet0</td><td style="text-align: left"><span>$\sum_{i=1}^{k}w_i\big(\frac{1}{2}P_i+\frac{1}{2}G\big)^{-1}=G^{-1}$</span></td></tr><tr><td style="text-align: center">VonNeumann</td><td style="text-align: left">N.A.</td></tr><tr><td style="text-align: center">Wasserstein</td><td style="text-align: left"><span>$G=\sum_{i=1}^{k}w_i\big( G^{1/2}  P_i G^{1/2}\big)^{1/2}$</span></td></tr></table><p><strong>legend:</strong> <span>$L_X$</span>, <span>$S_X$</span> and <span>$D_X$</span>   are the Cholesky lower triangle of <span>$X$</span>, its strictly lower triangular part   and diagonal part, respectively (hence, <span>$S_X+D_X=L_X$</span>,  <span>$L_XL_X^*=X$</span>).   <span>$A$</span> and <span>$H$</span> are the weighted arithmetic and weighted harmonic mean, respectively.</p><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#geodesic-1">geodesic</a>, <a href="../introToRiemannianGeometry/#mean-1">mean</a>, <a href="../introToRiemannianGeometry/#Fr√©chet-mean-1">Fr√©chet mean</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, Statistics, PosDefManifold
# Generate 2 random 3x3 SPD matrices
P=randP(3)
Q=randP(3)
M=mean(logdet0, P, Q) # (1)
M=mean(Euclidean, P, Q) # (1)

# passing several matrices and associated weights listing them
# weights vector, does not need to be normalized
R=randP(3)
mean(Fisher, ‚ÑçVector([P, Q, R]); w=[1, 2, 3])

# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4)
weights=[1, 2, 3, 1]
# passing a vector of Hermitian matrices (‚ÑçVector type)
M=mean(Euclidean, Pset; w=weights) # (2) weighted Euclidean mean
M=mean(Wasserstein, Pset)  # (2) unweighted Wassertein mean
# display convergence information when using an iterative algorithm
M=mean(Fisher, Pset; verbose=true)

# run multi-threaded when the number of matrices is high
using BenchmarkTools
Pset=randP(20, 160)
@benchmark(mean(logEuclidean, Pset; ‚è©=false)) # single-threaded
@benchmark(mean(logEuclidean, Pset)) # multi-threaded</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L1012-L1145">source</a></section><section><div><pre><code class="language-none">mean(metric::Metric, ŒΩ::Vector{T}) where T&lt;:RealOrComplex</code></pre><p>Mean of <span>$k$</span> real or complex scalars, using the specified <code>metric</code>  of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>. Note that using the Fisher,  logEuclidean and Jeffrey metric, the resulting mean  is the scalar geometric mean. Note also that the code of this method  is in unit <em>statistics.jl</em>, while the code for all the others is  in unit <em>riemannianGeometry.jl</em>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate 10 random numbers distributed as a chi-square with 2 df.
ŒΩ=[randœá¬≤(2) for i=1:10]
arithmetic_mean=mean(Euclidean, ŒΩ)
geometric_mean=mean(Fisher, ŒΩ)
harmonic_mean=mean(invEuclidean, ŒΩ)
harmonic_mean&lt;=geometric_mean&lt;=arithmetic_mean # AGH inequality</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/statistics.jl#L47-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.means" href="#PosDefManifold.means"><code>PosDefManifold.means</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    (1) means(metric::Metric, ùí´::‚ÑçVector‚ÇÇ;
    &lt;‚è©=true&gt;)

    (2) means(metric::Metric, ùíü::ùîªVector‚ÇÇ;
    &lt;‚è©=true&gt;)</code></pre><p>(1) Given a 2d array <span>$ùí´$</span> of positive definite matrices as an <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector‚ÇÇ type</a>  compute the <a href="../introToRiemannianGeometry/#Fr√©chet-mean-1">Fr√©chet mean</a> for as many <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a> objects  as hold in <span>$ùí´$</span>, using the specified <code>metric</code> of type  <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.  Return the means in a vector of <code>Hermitian</code> matrices, that is, as an <code>‚ÑçVector</code> type.</p><p>(2) Given a 2d array <span>$ùíü$</span> of real positive definite matrices as an <a href="../MainModule/#ùîªVector-type-1">ùîªVector‚ÇÇ type</a>  compute the <a href="../introToRiemannianGeometry/#Fr√©chet-mean-1">Fr√©chet mean</a> for as many <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a> objects  as hold in <span>$ùíü$</span>, using the specified <code>metric</code> of type  <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.  Return the means in a vector of <code>Diagonal</code> matrices, that is, as a <code>ùîªVector</code> type.</p><p>The weigted Fr√©chet mean is not supported in this function.</p><p>If <code>‚è©=true</code> (default) the computation of the means  is multi-threaded.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p></div></div><p><strong>See also</strong>: <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none"> using PosDefManifold
 # Generate a set of 4 random 3x3 SPD matrices
 Pset=randP(3, 4) # or, using unicode: ùêè=randP(3, 4)
 # Generate a set of 40 random 4x4 SPD matrices
 Qset=randP(3, 40) # or, using unicode: ùêê=randP(3, 40)
 # listing directly ‚ÑçVector objects
 means(logEuclidean, ‚ÑçVector‚ÇÇ([Pset, Qset])) # or: means(logEuclidean, ‚ÑçVector‚ÇÇ([ùêè, ùêê]))
 # note that [ùêè, ùêê] is actually a ‚ÑçVector‚ÇÇ type object

 # creating and passing an object of ‚ÑçVector‚ÇÇ type
 sets=‚ÑçVector‚ÇÇ(undef, 2) # or: ùí´=‚ÑçVector‚ÇÇ(undef, 2)
 sets[1]=Pset # or: ùí´[1]=ùêè
 sets[2]=Qset # or: ùí´[2]=ùêê
 means(logEuclidean, sets) # or: means(logEuclidean, ùí´)

 # going multi-threated

 # first, create 20 sets of 200 50x50 SPD matrices
 sets=‚ÑçVector‚ÇÇ([randP(50, 200) for i=1:20])

 # How much computing time we save ?
 # (example min time obtained with 4 threads &amp; 4 BLAS threads)
 using BenchmarkTools

 # non multi-threaded, mean with closed-form solution
 @benchmark(means(logEuclidean, sets; ‚è©=false)) # (6.196 s)

 # multi-threaded, mean with closed-form solution
 @benchmark(means(logEuclidean, sets)) # (1.897 s)

 sets=‚ÑçVector‚ÇÇ([randP(10, 200) for i=1:10])

 # non multi-threaded, mean with iterative solution
 # wait a bit
 @benchmark(means(Fisher, sets; ‚è©=false)) # (4.672 s )

 # multi-threaded, mean with iterative solution
 @benchmark(means(Fisher, sets)) # (1.510 s)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L1320-L1392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.generalizedMean" href="#PosDefManifold.generalizedMean"><code>PosDefManifold.generalizedMean</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    generalizedMean(ùêè::Union{‚ÑçVector, ùîªVector}, p::Real;
    &lt;
    w::Vector=[],
    ‚úìw=true,
    ‚è©=true &gt;)</code></pre><p>Given a 1d array <span>$ùêè={P_1,...,P_k}$</span> of <span>$k$</span> positive definite matrices of  <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a> or real positive definite diagonal matrices of  <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a> and optional non-negative real weights vector  <span>$w={w_1,...,w_k}$</span>, return the <em>weighted generalized means</em> <span>$G$</span>  with real parameter <span>$p$</span>, that is,</p><p><span>$G=\big(\sum_{i=1}^{k}w_iP_i^p\big)^{1/p}$</span>.</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted generalized mean</em></p><p><span>$G=\big(\sum_{i=1}^{k}P_i^p\big)^{1/p}$</span>.</p><p>If <em>&lt;optional keyword argument&gt;</em> <code>‚úìw=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the weights each time.</p><p>If <em>&lt;optional key argmuent&gt;</em> ‚è©=true the computation of the generalized mean  is multi-threaded.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p></div></div><p>The following special cases for parameter <span>$p$</span> are noteworthy:</p><ul><li>For <span>$p=\frac{1}{2}$</span> the generalized mean is the <a href="../introToRiemannianGeometry/#modified-Bhattacharyya-mean-1">modified Bhattacharyya mean</a>.</li><li>For <span>$p=1$</span> the generalized mean is the <a href="../introToRiemannianGeometry/#Euclidean-1">Euclidean</a> mean.</li><li>For <span>$p=-1$</span> the generalized mean is the <a href="../introToRiemannianGeometry/#inverse-Euclidean-1">inverse Euclidean</a> mean.</li><li>For (the limit of) <span>$p=0$</span> the generalized mean is the <a href="../introToRiemannianGeometry/#log-Euclidean-1">log Euclidean</a> mean, which is the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> mean when matrices in ùêè all pair-wise commute.</li></ul><p>Notice that when matrices in ùêè all pair-wise commute, for instance if the  matrices are diagonal,  the generalized means coincide with the <a href="../introToRiemannianGeometry/#power-means-1">power means</a>  for any <span>$p‚àà[-1, 1]$</span> and for <span>$p=0.5$</span> it coincides also with the  <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a> mean. For this reason the generalized means are used  as default initialization of both the <a href="#PosDefManifold.powerMean"><code>powerMean</code></a> and <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>  algorithm.</p><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.powerMean"><code>powerMean</code></a>, <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>, <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, Statistics, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: ùêè=randP(3, 4)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# unweighted mean
G = generalizedMean(Pset, 0.25) # or: G = generalizedMean(ùêè, 0.25)

# weighted mean
G = generalizedMean(Pset, 0.5; w=weights)

# with weights previously normalized we can set ‚úìw=false
weights=weights./sum(weights)
G = generalizedMean(Pset, 0.5; w=weights, ‚úìw=false)

# run multi-threaded when the number of matrices is high
using BenchmarkTools
Pset=randP(20, 160)
@benchmark(generalizedMean(Pset; ‚è©=false)) # single-threaded
@benchmark(generalizedMean(Pset)) # multi-threaded</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L1401-L1480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.geometricMean" href="#PosDefManifold.geometricMean"><code>PosDefManifold.geometricMean</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    geometricMean(ùêè::Union{‚ÑçVector, ùîªVector};
    &lt;
    w::Vector=[],
    ‚úìw=true,
    init=nothing,
    tol::Real=0.,
    maxiter::Int=500,
    adaptStepSize::Bool=true,
    verbose=false,
    ‚è©=true &gt;)</code></pre><p><strong>alias</strong>: <code>gmean</code></p><p>Given a 1d array <span>$ùêè={P_1,...,P_k}$</span> of <span>$k$</span> positive definite matrices of  <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a> or diagonal matrices of <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a>  and optional non-negative real weights vector <span>$w={w_1,...,w_k}$</span>,  return the 3-tuple <span>$(G, iter, conv)$</span>, where <span>$G$</span> is the mean according  to the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric and <span>$iter$</span>, <span>$conv$</span> are the number of iterations  and convergence attained by the algorithm.  Mean <span>$G$</span> is the unique positive definite matrix satisfying</p><p><span>$\sum_{i=1}^{k}w_i\textrm{log}\big(G^{-1/2} P_i G^{-1/2}\big)=0.$</span></p><p>For estimating it, this function implements the well-known gradient descent  algorithm, but with an exponential decaying step size <span>$œÇ$</span>, yielding iterations</p><p><span>$G ‚ÜêG^{1/2}\textrm{exp}\big(œÇ\sum_{i=1}^{k}w_i\textrm{log}(G^{-1/2} P_i G^{-1/2})\big)G^{1/2}.$</span></p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted geometric mean</em>.</p><p>If <em>&lt;optional keyword argument&gt;</em> <code>‚úìw=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>The following are more <em>&lt;optional keyword arguments</em>&gt;:</p><ul><li><code>init</code> is a matrix to be used as initialization for the mean. If no matrix is provided, the <a href="../introToRiemannianGeometry/#log-Euclidean-1">log Euclidean</a> mean will be used,</li><li><code>tol</code> is the tolerance for the convergence (see below).</li><li><code>maxiter</code> is the maximum number of iterations allowed</li><li>if <code>verbose</code>=true, the convergence attained at each iteration and the step size <span>$œÇ$</span> is printed. Also, a <em>warning</em> is printed if convergence is not attained.</li><li>if ‚è©=true the iterations are multi-threaded (see below).</li><li>if <code>adaptStepSize</code>=false the step size <code>œÇ</code> is fixed to 1 at all iterations.</li></ul><p>If the input is a 1d array of <span>$k$</span> real positive definite diagonal matrices  the solution is available in closed-form as the log Euclidean  mean, hence the <em>&lt;optional keyword arguments</em>&gt; <code>init</code>, <code>tol</code> and <code>verbose</code>  have no effect and return the 3-tuple <span>$(G, 1, 0)$</span>.  See the <a href="../introToRiemannianGeometry/#log-Euclidean-1">log Euclidean</a> metric.</p><p>!!! note &quot;Nota Bene&quot;      <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a>      is automatically disabled if Julia is instructed to use only one thread.      See <a href="../MainModule/#Threads-1">Threads</a>.</p><pre><code class="language-none">In normal circumstances this algorithm converges monothonically.
If the algorithm diverges and `verbose` is true a **warning** is printed
indicating the iteration when this happened.

The exponential decaying step size features a faster convergence rate
as compared to the fixed step size ``œÇ=1`` that is usually adopted.
The decaying rate is inversely proportional to `maxiter`, thus,
increase/decrease `maxiter` in order to set a slower/faster
decaying rate. `maxiter` should not be set too low though.

``tol`` defaults to the square root of `Base.eps` of the nearest
real type of data input ``ùêè``. This corresponds to requiring the
norm of the satisfying matrix equation divided by the number of elements
to vanish for about half the significant digits.</code></pre><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric.</p><p><strong>See also</strong>: <a href="#PosDefManifold.geometricpMean"><code>geometricpMean</code></a>, <a href="#PosDefManifold.powerMean"><code>powerMean</code></a>,  <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>, <a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a>, <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: ùêè=randP(3, 4)

# unweighted mean
G, iter, conv = geometricMean(Pset) # or G, iter, conv = geometricMean(ùêè)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# weighted mean
G, iter, conv = geometricMean(Pset, w=weights)

# print the convergence at all iterations
G, iter, conv = geometricMean(Pset; verbose=true)

# now suppose Pset has changed a bit, initialize with G to hasten convergence
Pset[1]=‚Ñç(Pset[1]+(randP(3)/100))
G, iter, conv = geometricMean(Pset; w=weights, ‚úìw=true, verbose=true, init=G)

# run multi-threaded when the number of matrices is high
using BenchmarkTools
Pset=randP(20, 120)
@benchmark(geometricMean(Pset; ‚è©=false)) # single-threaded
@benchmark(geometricMean(Pset)) # multi-threaded

# show the mean and the input points using spectral embedding
using Plots
k=80
Pset=randP(20, k)
G, iter, conv = geometricMean(Pset)
push!(Pset, G)
Œõ, U, iter, conv=spectralEmbedding(Fisher, Pset, 2; verbose=true)
plot(U[1:k, 1], U[1:k, 2], seriestype=:scatter, title=&quot;Spectral Embedding&quot;, label=&quot;Pset&quot;)
plot!(U[k+1:k+1, 1], U[k+1:k+1, 2], seriestype=:scatter, label=&quot;mean&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L1506-L1622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.geometricpMean" href="#PosDefManifold.geometricpMean"><code>PosDefManifold.geometricpMean</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    geometricpMean(ùêè::‚ÑçVector, p::Real=0.5;
    &lt;
    w::Vector=[],
    ‚úìw=true,
    init=nothing,
    tol::Real=0.,
    maxiter::Int=500,
    adaptStepSize=true,
    verbose=false,
    ‚è©=true &gt;)</code></pre><p><strong>alias</strong>: <code>gpmean</code></p><p>Given a 1d array <span>$ùêè={P_1,...,P_k}$</span> of <span>$k$</span> positive definite matrices of  <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>, a real parameter <span>$0&lt;p&lt;=1$</span> and optional non-negative real  weights vector <span>$w={w_1,...,w_k}$</span>, return the 3-tuple <span>$(G, iter, conv)$</span>,  where <span>$G$</span> is the <em>p-mean</em>, i.e., the mean according to the  <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric minimizing the <em>p-dispersion</em> (see below) and  <span>$iter$</span>, <span>$conv$</span> are the number of  iterations and convergence attained by the algorithm.</p><p>This function implements the p-dispersion gradient descent  algorithm with step-size <span>$œÇ$</span> (to be published), yielding iterations</p><p><span>$G ‚ÜêG^{1/2}\textrm{exp}\big(œÇ\sum_{i=1}^{k}pŒ¥^2(G, P_i)^{p-1}w_i\textrm{log}(G^{-1/2} P_i G^{-1/2})\big)G^{1/2}.$</span></p><ul><li>if <span>$p=1$</span> this yields the geometric mean (implemented specifically in <a href="#PosDefManifold.geometricMean"><code>geometricMean</code></a>).</li><li>if <span>$p=0.5$</span> this yields the geometric median (default).</li></ul><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted geometric-p mean</em>.</p><p>If <em>&lt;optional keyword argument&gt;</em> <code>‚úìw=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>The following are more <em>&lt;optional keyword arguments</em>&gt;:</p><ul><li><code>init</code> is a matrix to be used as initialization for the mean. If no matrix is provided, the <a href="../introToRiemannianGeometry/#log-Euclidean-1">log Euclidean</a> mean will be used,</li><li><code>tol</code> is the tolerance for the convergence (see below).</li><li><code>maxiter</code> is the maximum number of iterations allowed.</li><li>if <code>adaptStepSize</code>=true (default) the step size <span>$œÇ$</span> for the gradient descent is adapted at each iteration (see below).</li><li>if <code>verbose</code>=true, the step-size and convergence attained at each iteration is printed. Also, a <em>warning</em> is printed if convergence is not attained.</li><li>if ‚è©=true the iterations are multi-threaded (see below).</li></ul><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>If the algorithm diverges and <code>verbose</code> is true a <strong>warning</strong> is printed indicating the iteration when this happened. This algorithm may temporary diverge, still reach convergence. Overall, while all other iterative algorithms implemented in <strong>PosDefMaifold</strong> are very stable, this is not.</p><p>The smaller the parameter <span>$p$</span> is, the slower and less likely the convergence is. If the algorithm does not converge, try increasing <span>$p$</span>, initializing the algorithm with the output of <a href="#PosDefManifold.geometricMean"><code>geometricMean</code></a> and/or eliminating the otliers from the input set <span>$ùêè$</span>.</p><p>If <code>adaptStepSize</code> is true (default) the step-size <span>$œÇ$</span> is adapted at each iteration, otherwise a fixed step size <span>$œÇ=1$</span> is used. Adapting the step size in general hastens convergence and improves the convergence behavior.</p><p><span>$tol$</span> defaults to the square root of <code>Base.eps</code> of the nearest real type of data input <span>$ùêè$</span>. This corresponds to requiring the norm of the satisfying matrix equation divided by the number of elements to vanish for about half the significant digits.</p></div></div><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric.</p><p><strong>See also</strong>: <a href="#PosDefManifold.geometricMean"><code>geometricMean</code></a>, <a href="#PosDefManifold.powerMean"><code>powerMean</code></a>,  <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>, <a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a>, <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold, Plots

# This examples show that this algorithm is more robust to outliers
# as compared to the standard geometric mean algorithm

# Generate a set of 100 random 10x10 SPD matrices
Pset=randP(10, 100)

# Get the usual geometric mean for comparison
G, iter1, conv1 = geometricMean(Pset, verbose=true)

# change p to observe how the convergence behavior changes accordingly
# Get the median (default)
H, iter2, conv2 = geometricpMean(Pset, verbose=true)
# Get the p-mean for p=0.25
H, iter2, conv2 = geometricpMean(Pset, 0.25, verbose=true)

println(iter1, &quot; &quot;, iter2); println(conv1, &quot; &quot;, conv2)

# move the first matrix in Pset to possibly create an otlier
Pset[1]=geodesic(Fisher, G, Pset[1], 3)
G1, iter1, conv1 = geometricMean(Pset, verbose=true)
H1, iter2, conv2 = geometricpMean(Pset, 0.25, verbose=true)
println(iter1, &quot; &quot;, iter2); println(conv1, &quot; &quot;, conv2)

# collect the geometric and p-means, before and after the
# introduction of the outier in vector of Hermitian matrices `S`.
S=HermitianVector([G, G1, H, H1])

# check the interdistance matrix Œî¬≤ to verify that the geometric mean
# after the introduction of the outlier (``G1``) is farther away from
# the geometric mean as compared to how much ``H1`` is further away
# from ``H``, i.e., that element (4,3) is much smaller than element (2,1).
Œî¬≤=distance¬≤Mat(Float64, Fisher, S)

# how far are all these matrices from all the others?
fullŒî¬≤=Hermitian(Œî¬≤, :L)
dist=[sum(fullŒî¬≤[:, i]) for i=1:size(fullŒî¬≤, 1)]

# plot the matrices in `S` using spectral embedding.
using Plots
Œõ, U, iter, conv = laplacianEM(laplacian(Œî¬≤), 3;  verbose=true)
plot([U[1, 1]], [U[1, 2]], seriestype=:scatter, label=&quot;g-mean&quot;)
plot!([U[2, 1]], [U[2, 2]], seriestype=:scatter, label=&quot;g-mean outlier&quot;)
plot!([U[3, 1]], [U[3, 2]], seriestype=:scatter, label=&quot;p-mean&quot;)
plot!([U[4, 1]], [U[4, 2]], seriestype=:scatter, label=&quot;p-mean outlier&quot;)

# estimate how much you gain running the algorithm in multi-threaded mode
using BenchmarkTools
Pset=randP(20, 120)
@benchmark(geometricpMean(Pset; ‚è©=true)) # single-threaded
@benchmark(geometricpMean(Pset)) # multi-threaded</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L1678-L1811">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.logdet0Mean" href="#PosDefManifold.logdet0Mean"><code>PosDefManifold.logdet0Mean</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    logdet0Mean(ùêè::Union{‚ÑçVector, ùîªVector};
    &lt;
    w::Vector=[],
    ‚úìw=true,
    init=nothing,
    tol::Real=0.,
    maxiter::Int=500,
    verbose=false,
    ‚è©=true &gt;)</code></pre><p><strong>alias</strong>: <code>ld0Mean</code></p><p>Given a 1d array <span>$ùêè={P_1,...,P_k}$</span> of <span>$k$</span> positive definite matrices of  <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a> or real positive definite diagonal matrices of  <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a> and optional  non-negative real weights vector <span>$w={w_1,...,w_k}$</span>,  return the 3-tuple <span>$(G, iter, conv)$</span>, where <span>$G$</span> is the mean according  to the <a href="../introToRiemannianGeometry/#logdet-zero-1">logdet zero</a> metric and <span>$iter$</span>, <span>$conv$</span> are the number of iterations  and convergence attained by the algorithm.  Mean <span>$G$</span> is the unique positive definite matrix satisfying</p><p><span>$\sum_{i=1}^{k}w_i\big(\frac{1}{2}P_i+\frac{1}{2}G\big)^{-1}-G^{-1}=0$</span>.</p><p>For estimating it, this function implements the fixed-point iteration algorithm  suggested by (Moakher, 2012, p315)<a href="../introToRiemannianGeometry/#-1">üéì</a>, yielding iterations</p><p><span>$G ‚Üê \frac{1}{2}\big(\sum_{i=1}^{k}w_i(P_i+G)^{-1}\big)^{-1}$</span>.</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted logdet zero mean</em>.</p><p>If <em>&lt;optional keyword argument&gt;</em> <code>‚úìw=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>The following are more <em>&lt;optional keyword arguments</em>&gt;:</p><ul><li><code>init</code> is a matrix to be used as initialization for the mean. If no matrix is provided, the <a href="../introToRiemannianGeometry/#log-Euclidean-1">log Euclidean</a> mean will be used,</li><li><code>tol</code> is the tolerance for the convergence (see below).</li><li><code>maxiter</code> is the maximum number of iterations allowed.</li><li>if <code>verbose</code>=true, the convergence attained at each iteration is printed and a <em>warning</em> is printed if convergence is not attained.</li><li>if ‚è©=true the iterations are multi-threaded (see below).</li></ul><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>In normal circumstances this algorithm converges monothonically. If the algorithm diverges and <code>verbose</code> is true a <strong>warning</strong> is printed indicating the iteration when this happened.</p><p><span>$tol$</span> defaults to 100 times the square root of <code>Base.eps</code> of the nearest real type of data input <span>$ùêè$</span>. This corresponds to requiring the square root of the relative convergence criterion over two successive iterations to vanish for about half the significant digits minus 2.</p></div></div><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#logdet-zero-1">logdet zero</a> metric, <a href="../introToRiemannianGeometry/#modified-Bhattacharyya-mean-1">modified Bhattacharyya mean</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.powerMean"><code>powerMean</code></a>, <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>, <a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a>,  <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: ùêè=randP(3, 4)

# unweighted mean
G, iter, conv = logdet0Mean(Pset) # or G, iter, conv = logdet0Mean(ùêè)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# weighted mean
G, iter, conv = logdet0Mean(Pset, w=weights)

# print the convergence at all iterations
G, iter, conv = logdet0Mean(Pset; w=weights, verbose=true)

# suppose Pset has changed a bit; initialize with G to hasten convergence
Pset[1]=‚Ñç(Pset[1]+(randP(3)/100))
G, iter, conv = logdet0Mean(Pset; w=weights, ‚úìw=false, verbose=true, init=G)

# estimate how much you gain running the algorithm in multi-threaded mode
using BenchmarkTools
Pset=randP(20, 120)
@benchmark(logdet0Mean(Pset; ‚è©=false)) # single-threaded
@benchmark(logdet0Mean(Pset)) # multi-threaded</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L1882-L1975">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.wasMean" href="#PosDefManifold.wasMean"><code>PosDefManifold.wasMean</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    wasMean(ùêè::Union{‚ÑçVector, ùîªVector};
    &lt;
    w::Vector=[],
    ‚úìw=true,
    init=nothing,
    tol::Real=0.,
    maxiter::Int=500,
    verbose=false,
    ‚è©=true &gt;)</code></pre><p>Given a 1d array <span>$ùêè={P_1,...,P_k}$</span> of <span>$k$</span> positive definite matrices  of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a> or real positive definite diagonal matrices of  <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a> and optional non-negative real weights vector  <span>$w={w_1,...,w_k}$</span>,  return the 3-tuple <span>$(G, iter, conv)$</span>, where <span>$G$</span> is the mean according  to the <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a> metric and <span>$iter$</span>, <span>$conv$</span> are the number of iterations  and convergence attained by the algorithm.  Mean <span>$G$</span> is the unique positive definite matrix satisfying</p><p><span>$G=\sum_{i=1}^{k}w_i\big( G^{1/2}  P_i G^{1/2}\big)^{1/2}$</span>.</p><p>For estimating it, this function implements the fixed-point iterative algorithm  proposed by (√Ålvarez-Esteban et <em>al.</em>, 2016)<a href="../introToRiemannianGeometry/#-1">üéì</a>:</p><p><span>$G ‚Üê G^{-1/2}\big(\sum_{i=1}^{k} w_i(G^{1/2}P_i G^{1/2})^{1/2}\big)^2 G^{-1/2}$</span>.</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted Wassertein mean</em>.</p><p>If <em>&lt;optional keyword argument&gt;</em> <code>‚úìw=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and they should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>The following are more <em>&lt;optional keyword arguments</em>&gt;:</p><ul><li><code>init</code> is a matrix to be used as initialization for the mean. If no matrix is provided, the instance of <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a> with <span>$p=0.5$</span> will be used,</li><li><code>tol</code> is the tolerance for the convergence (see below).</li><li><code>maxiter</code> is the maximum number of iterations allowed.</li><li>if <code>verbose</code>=true, the convergence attained at each iteration is printed and a <em>warning</em> is printed if convergence is not attained.</li><li>if ‚è©=true the iterations are multi-threaded (see below).</li></ul><p>If the input is a 1d array of <span>$k$</span> real positive definite diagonal matrices  the solution is available in closed-form as the modified Bhattacharyya mean,  hence the <em>&lt;optional keyword arguments</em>&gt; <code>init</code>, <code>tol</code> and <code>verbose</code>  have no effect and return the 3-tuple <span>$(G, 1, 0)$</span>.  See <a href="../introToRiemannianGeometry/#modified-Bhattacharyya-mean-1">modified Bhattacharyya mean</a>.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>In normal circumstances this algorithm converges monothonically. If the algorithm diverges and <code>verbose</code> is true a <strong>warning</strong> is printed indicating the iteration when this happened.</p><p><span>$tol$</span> defaults to the square root of <code>Base.eps</code> of the nearest real type of data input <span>$ùêè$</span>. This corresponds to requiring the norm of the satisfying matrix equation divided by the number of elements to vanish for about half the significant digits.</p></div></div><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a> metric.</p><p><strong>See also</strong>: <a href="#PosDefManifold.powerMean"><code>powerMean</code></a>, <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>, <a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a>,  <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: ùêè=randP(3, 4)

# unweighted mean
G, iter, conv = wasMean(Pset) # or: G, iter, conv = wasMean(ùêè)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# weighted mean
G, iter, conv = wasMean(Pset; w=weights)

# print the convergence at all iterations
G, iter, conv = wasMean(Pset; w=weights, verbose=true)

# suppose ùêè has changed a bit; initialize with G to hasten convergence
Pset[1]=‚Ñç(Pset[1]+(randP(3)/100))
G, iter, conv = wasMean(Pset; w=weights, verbose=true, init=G)

# estimate how much you gain running the algorithm in multi-threaded mode
using BenchmarkTools
Pset=randP(20, 120)
@benchmark(wasMean(Pset; ‚è©=false)) # single-threaded
@benchmark(wasMean(Pset)) # multi-threaded</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2026-L2123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.powerMean" href="#PosDefManifold.powerMean"><code>PosDefManifold.powerMean</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    powerMean(ùêè::Union{‚ÑçVector, ùîªVector}, p::Real;
    &lt;
    w::Vector=[],
    ‚úìw=true,
    init=nothing,
    tol::Real=0.,
    maxiter::Int=500,
    verbose=false,
    ‚è©=true &gt;)</code></pre><p>Given a 1d array <span>$ùêè={P_1,...,P_k}$</span> of <span>$k$</span> positive definite matrices  of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a> or real positive definite diagonal matrices of  <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a>, an optional non-negative real weights vector  <span>$w={w_1,...,w_k}$</span> and a real parameter <code>p</code> <span>$\in[-1, 1]$</span>, return the  3-tuple <span>$(G, iter, conv)$</span>, where <span>$G$</span> is  Lim and Palfia (2012)&#39;s <a href="../introToRiemannianGeometry/#power-means-1">power means</a>  of order <span>$p$</span> and  <span>$iter$</span>, <span>$conv$</span> are the number of iterations  and convergence attained by the algorithm, respectively.  Mean <span>$G$</span> is the unique positive definite matrix satisfying</p><p><span>$G=\sum_{i=1}^{k}(w_iG\textrm{#}_pP_i)$</span>,</p><p>where <span>$G\textrm{#}_pP_i$</span> is the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> <a href="../introToRiemannianGeometry/#geodesic-1">geodesic</a> equation.  In particular:</p><ul><li>with <span>$p=-1$</span> this is the <em>harmonic mean</em> (see the <a href="../introToRiemannianGeometry/#inverse-Euclidean-1">inverse Euclidean</a> metric),</li><li>with <span>$p=+1$</span> this is the <em>arithmetic mean</em> (see the <a href="../introToRiemannianGeometry/#Euclidean-1">Euclidean</a> metric),</li><li>at the limit of <span>$p$</span> evaluated at zero from both side this is the <em>geometric mean</em> (see <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric).</li></ul><p>For estimating power means for <span>$p\in(-1, 1)$</span>, this function implements  the  fixed-point iterative algorithm of (Congedo et <em>al.</em>, 2017b)<a href="../introToRiemannianGeometry/#-1">üéì</a>.  For <span>$p=0$</span> (geometric mean)  this algorithm is run two times with a small positive and negative value  of <span>$p$</span> and the geometric mean of the two  resulting means is returned, as suggested in (Congedo et <em>al.</em>, 2017b)<a href="../introToRiemannianGeometry/#-1">üéì</a>.  This way of estimating the geometric mean of  a set of matrices is faster as compared to the usual gradient descent algorithm.</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted power mean</em>.</p><p>If <em>&lt;optional keyword argument&gt;</em> <code>‚úìw=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>The following are more <em>&lt;optional keyword arguments</em>&gt;:</p><ul><li><code>init</code> is a matrix to be used as initialization for the mean. If no matrix is provided, the instance of <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a> with parameter <span>$p$</span> will be used.</li><li><code>tol</code> is the tolerance for the convergence (see below).</li><li><code>maxiter</code> is the maximum number of iterations allowed.</li><li>if <code>verbose</code>=true, the convergence attained at each iteration is printed and a <em>warning</em> is printed if convergence is not attained.</li><li>if ‚è©=true the iterations are multi-threaded.</li></ul><p>If the input is a 1d array of <span>$k$</span> real positive definite diagonal matrices  the solution is available in closed-form as the generalized  mean of order <code>p</code>, hence the <em>&lt;optional keyword arguments</em>&gt;  <code>init</code>, <code>tol</code> and <code>verbose</code>  have no effect and return the 3-tuple <span>$(G, 1, 0)$</span>.  See <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a>.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p><a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Multi-Threading-(Experimental)-1">Multi-threading</a> is automatically disabled if Julia is instructed to use only one thread. See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>In normal circumstances this algorithm converges monothonically. If the algorithm diverges and <code>verbose</code> is true a <strong>warning</strong> is printed indicating the iteration when this happened.</p><p><span>$tol$</span> defaults to the square root of <code>Base.eps</code> of the nearest real type of data input <span>$ùêè$</span>. This corresponds to requiring the norm of the difference of the matrix solution over two successive iterations divided by the number of elements in the matrix to vanish for about half the significant digits.</p></div></div><p>(2) Like in (1), but for a 1d array <span>$ùêÉ={D_1,...,D_k}$</span> of <span>$k$</span>  real positive definite diagonal matrices of <a href="../MainModule/#ùîªVector-type-1">ùîªVector type</a>.  In this case the solution is available in closed-form, hence the  <em>&lt;optional keyword arguments</em>&gt; <code>init</code>, <code>tol</code> and <code>verbose</code> have no effect and return  the 3-tuple <span>$(G, 1, 0)$</span>. See <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a>.</p><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#power-means-1">power means</a>, <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a>, <a href="../introToRiemannianGeometry/#modified-Bhattacharyya-mean-1">modified Bhattacharyya mean</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.generalizedMean"><code>generalizedMean</code></a>, <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>, <a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a>,  <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: ùêè=randP(3, 4)

# unweighted mean
G, iter, conv = powerMean(Pset, 0.5) # or G, iter, conv = powerMean(ùêè, 0.5)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# weighted mean
G, iter, conv = powerMean(Pset, 0.5; w=weights)

# print the convergence at all iterations
G, iter, conv = powerMean(Pset, 0.5; w=weights, verbose=true)

# suppose ùêè has changed a bit; initialize with G to hasten convergence
Pset[1]=‚Ñç(Pset[1]+(randP(3)/100))
G, iter, conv = powerMean(Pset, 0.5; w=weights, verbose=true, init=G)

# estimate how much you gain running the algorithm in multi-threaded mode
using BenchmarkTools
Pset=randP(20, 120)
@benchmark(powerMean(Pset, 0.5; ‚è©=false)) # single-threaded
@benchmark(powerMean(Pset, 0.5)) # multi-threaded</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2176-L2293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.inductiveMean" href="#PosDefManifold.inductiveMean"><code>PosDefManifold.inductiveMean</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(1) inductiveMean(metric::Metric, ùêè::‚ÑçVector)

(2) inductiveMean(metric::Metric, ùêè::‚ÑçVector, q::Int, Q::‚Ñç)</code></pre><p><strong>alias</strong>: <code>indMean</code></p><p>(1) Compute the Fr√©chet mean of 1d array <span>$ùêè={P_1,...,P_k}$</span> of <span>$k$</span>  positive definite matrices of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a> with a law of large  number inductive procedure (Ho et <em>al.,</em> 2013; Massart et <em>al.</em>, 2018),  such as <a href="../introToRiemannianGeometry/#-1">üéì</a></p><p><span>$G_1=P_1,$</span></p><p><span>$G_i=Œ≥(i^{-1}, G_{(i-1)}, P_i), i=2,...,k,$</span></p><p>where <span>$Œ≥(i^{-1}, G_{(i-1)}, P_i)$</span> is a step on the <a href="../introToRiemannianGeometry/#geodesic-1">geodesic</a> relying  <span>$G_{(i-1)}$</span> to <span>$P_i$</span> with arclength <span>$i^{-1}$</span>  using the specified <code>metric</code>, of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.</p><p>(2) Like (1), but for the set of matrices <span>$ùêê ‚à™ ùêè$</span>,  where it is assumed knowledge only of the set <span>$ùêè$</span>,  the mean of <span>$ùêê$</span> (Hermitian matrix argument <code>Q</code>) and the number of  matrices in <span>$ùêê$</span> (integer argument <code>q</code>).  This method can be used, for example, for updating a block on-line algorithm,  where <span>$ùêè$</span> is the incoming block, <code>Q</code> the previous mean estimation  and <code>q</code> the cumulative number of matrices on which the mean has been  computed on-line.</p><p>For Fr√©chet means that do not have a closed form expression,  this procedure features a computational complexity amounting to less than  two iterations of gradient descent or fixed-point algorithms. This comes at  the price of an approximation.  In fact, the solution is not invariant to permutations of the matrices  in array ùêè and convergence to the Fr√©chet mean with the  implemented procedure is not ensured  (see Massart et <em>al.</em>, 2018)<a href="../introToRiemannianGeometry/#-1">üéì</a>.</p><p>Since the inductive mean uses the <a href="#PosDefManifold.geodesic"><code>geodesic</code></a> function,  it is not available for the Von Neumann metric.</p><p><strong>Examples</strong></p><pre><code class="language-none"># A set of 100 matrices for which we want to compute the mean
ùêè=randP(10, 100)

ùêè1=‚ÑçVector(collect(ùêè[i] for i=1:50)) # first 50
ùêè2=‚ÑçVector(collect(ùêè[i] for i=51:100)) # last 50

# inductive mean of the whole set ùêè
G=inductiveMean(Fisher, ùêè)

# mean using the usual gradient descent algorithm
H, iter, conv=geometricMean(ùêè)

# inductive mean of ùêè given only ùêè2,
# the number of matrices in ùêè1 and the mean of ùêè1
G2=inductiveMean(Fisher, ùêè2, length(ùêè1), mean(Fisher, ùêè1))

# average error
norm(G-H)/(dim(G, 1)^2)
norm(G2-H)/(dim(G, 1)^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2373-L2434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.midrange" href="#PosDefManifold.midrange"><code>PosDefManifold.midrange</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">midrange(metric::Metric, P::‚Ñç{T}, Q::‚Ñç{T}) where T&lt;:RealOrComplex</code></pre><p>Midrange (average of extremal values) of positive definite matrices  <span>$P$</span> and <span>$Q$</span>. Only the Fisher metric is supported, allowing the so-called  <em>geometric midrange</em>. This has been defined in Mostajeran et <em>al.</em> (2019)  <a href="../introToRiemannianGeometry/#-1">üéì</a> as</p><p><span>$P * Q = \frac{1}{\sqrt{\lambda_(min)}+\sqrt{\lambda_(max)}}\Big(Q+\sqrt{\lambda_(min)*\lambda_(max)}P\Big)$</span>,</p><p>where <span>$\lambda_(min)$</span> and <span>$\lambda_(max)$</span> are the extremal generalized  eigenvalues of <span>$P$</span> and <span>$Q$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-none">P=randP(3)
Q=randP(3)
M=midrange(Fisher, P, Q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2446-L2464">source</a></section></article><h2 id="Tangent-Space-operations-1"><a class="docs-heading-anchor" href="#Tangent-Space-operations-1">Tangent Space operations</a><a class="docs-heading-anchor-permalink" href="#Tangent-Space-operations-1" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.logMap"><code>logMap</code></a></td><td style="text-align: left">Logarithmic map (from manifold to tangent space)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.expMap"><code>expMap</code></a></td><td style="text-align: left">Exponential map (from tangent space to manifold)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.vecP"><code>vecP</code></a></td><td style="text-align: left">vectorization of matrices in the tangent space</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.matP"><code>matP</code></a></td><td style="text-align: left">matrization of matrices in the tangent space (inverse of <code>vecp</code>)</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.parallelTransport"><code>parallelTransport</code></a>, pt</td><td style="text-align: left">Parallel transport of tangent vectors and matrices</td></tr></table><p>‚ãÖ</p><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.logMap" href="#PosDefManifold.logMap"><code>PosDefManifold.logMap</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(1) logMap(metric::Metric, P::‚Ñç{T}, G::‚Ñç{T})

(2) logMap(metric::Metric, ùêè::‚ÑçVector, G::‚Ñç{T})
for all the above: where T&lt;:RealOrComplex</code></pre><p>(1) <em>Logaritmic Map:</em> map a positive definite matrix <span>$P$</span> from the SPD or  Hermitian manifold into the tangent space at base-point <span>$G$</span>  using the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric.</p><p><span>$P$</span> and <span>$G$</span> must be flagged as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The map is defined as</p><p><span>$Log_G(P)=S=G^{1/2}\textrm{log}\big(G^{-1/2}PG^{-1/2}\big)G^{1/2}$</span>.</p><p><code>metric</code> is a metric of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.</p><p>The result is an <code>Hermitian</code> matrix.</p><p>(2) <em>Logarithmic map</em> (1) at base-point <span>$G$</span> at once for <span>$k$</span> positive definite  matrices in 1d array <span>$ùêè={P_1,...,P_k}$</span> of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>.</p><p>The result is an <code>‚ÑçVector</code>.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>Currently only the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric is supported for tangent space operations.</p></div></div><p>The inverse operation is <a href="#PosDefManifold.expMap"><code>expMap</code></a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.vecP"><code>vecP</code></a>, <a href="#PosDefManifold.parallelTransport"><code>parallelTransport</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
(1)
P=randP(3)
Q=randP(3)
metric=Fisher
G=mean(metric, P, Q)
# projecting P at the base point given by the geometric mean of P and Q
S=logMap(metric, P, G)

(2)
Pset=randP(3, 4)
# projecting all matrices in Pset at the base point given by their geometric mean.
Sset=logMap(Fisher, Pset, mean(Fisher, Pset))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2492-L2541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.expMap" href="#PosDefManifold.expMap"><code>PosDefManifold.expMap</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(1) expMap(metric::Metric, S::‚Ñç{T}, G::‚Ñç{T})

(2) expMap(metric::Metric, ùêí::‚ÑçVector, G::‚Ñç{T})
for all the above: where T&lt;:RealOrComplex</code></pre><p>(1) <em>Exponential Map:</em> map a tangent vector (a matrix) <span>$S$</span> from the tangent  space at base-point <span>$G$</span> into the SPD or Hermitian manifold  (using the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric).</p><p><span>$S$</span> and <span>$G$</span> must be flagged as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The map is defined as</p><p><span>$Exp_G(S)=P=G^{1/2}\textrm{exp}\big(G^{-1/2}SG^{-1/2}\big)G^{1/2}$</span>.</p><p><code>metric</code> is a metric of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.</p><p>The result is an <code>Hermitian</code> matrix.</p><p>(2) <em>Exponential map</em> (1) at base-point <span>$G$</span> at once for <span>$k$</span> tangent vectors  (matrices) in 1d array <span>$ùêí={S_1,...,S_k}$</span> of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>.</p><p>The result is an <code>‚ÑçVector</code>.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>Currently only the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric is supported for tangent space operations.</p></div></div><p>The inverse operation is <a href="#PosDefManifold.logMap"><code>logMap</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">(1)
using PosDefManifold, LinearAlgebra
P=randP(3)
Q=randP(3)
G=mean(Fisher, P, Q)
# projecting P on the tangent space at the Fisher mean base point G
S=logMap(Fisher, P, G)
# projecting back onto the manifold
P2=expMap(Fisher, S, G)

(2)
Pset=randP(3, 4)
# projecting all matrices in Pset at the base point given by their geometric mean.
G=mean(Fisher, Pset)
Sset=logMap(Fisher, Pset, G)
# projecting back onto the manifold
Pset2=expMap(Fisher, Sset, G)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2561-L2611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.vecP" href="#PosDefManifold.vecP"><code>PosDefManifold.vecP</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vecP(S::Union{‚Ñç{T}, Symmetric{R}};
     range::UnitRange=1:size(S, 2)) where T&lt;:RealOrComplex where R&lt;:Real =</code></pre><p><em>Vectorize</em> a tangent vector (which is an <code>Hermitian</code> or <code>Symmetric</code> matrix)  <span>$S$</span>:  mat ‚Ü¶ vec.</p><p>It gives weight <span>$1$</span> to diagonal elements and <span>$‚àö2$</span> to off-diagonal elements  so as to preserve the norm (Barachant et <em>al.</em>, 201E)<a href="../introToRiemannianGeometry/#-1">üéì</a>, such as</p><p><span>$‚à•S‚à•_F=‚à•vecP(S)‚à•_F$</span>.</p><p>The result is a vector holding <span>$n(n+1)/2$</span> elements, where <span>$n$</span>  is the size of <span>$S$</span>.</p><p><span>$S$</span> must be flagged as <code>Hermitian</code> or <code>Symmetric</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The reverse operation is provided by <a href="#PosDefManifold.matP"><code>matP</code></a>,  which always return an <code>Hermitian</code> matrix.</p><p>If an optional keyword argument <code>range</code> is provided,  the vectorization concerns only the rows (or columns,  since the input matrix is symmetric or Hermitian)  in the range. Note that in this case the operation  cannot be reverted by the <a href="#PosDefManifold.matP"><code>matP</code></a>, that is,  in this case the matrix is &#39;stuck&#39; in the tangent space.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(3)
Q=randP(3)
G=mean(Fisher, P, Q)
# projecting P at the base point given by the geometric mean of P and Q
S=logMap(Fisher, P, G)
# vectorize S
v=vecP(S)
# vectorize onlt the first two columns of S
v=vecP(S; range=1:2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2634-L2673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.matP" href="#PosDefManifold.matP"><code>PosDefManifold.matP</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">matP(œÇ::Vector{T}) where T&lt;:RealOrComplex</code></pre><p><em>Matrizize</em> a tangent vector (vector) œÇ :  vec -&gt; mat.</p><p>This is the function reversing the <a href="#PosDefManifold.vecP"><code>vecP</code></a> function,  thus the weighting applied therein is reversed as well.</p><p>If <span>$œÇ=vecP(S)$</span> and <span>$S$</span> is a <span>$n‚ãÖn$</span> Hermitian or Symmetric matrix,  <span>$œÇ$</span>  is a tangent vector of size <span>$n(n+1)/2$</span>.  The result of calling <code>matP(œÇ)</code> is then <span>$n‚ãÖn$</span> matrix <span>$S$</span>.  <span>$S$</span> is always returned flagged as <code>Hermitian</code>.</p><p><strong>To Do</strong>: This function may be rewritten more efficiently.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(3)
Q=randP(3)
G=mean(Fishr, P, Q)
# projecting P at onto the tangent space at the Fisher mean base point
S=logMap(Fisher, P, G)
# vectorize S
v=vecP(S)
# Rotate the vector by an orthogonal matrix
n=Int(size(S, 1)*(size(S, 1)+1)/2)
U=randP(n)
z=U*v
# Get the point in the tangent space
S=matP(z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2679-L2710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.parallelTransport" href="#PosDefManifold.parallelTransport"><code>PosDefManifold.parallelTransport</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(1) parallelTransport(S::‚Ñç{T}, P::‚Ñç{T}, Q::‚Ñç{T})

(2) parallelTransport(S::‚Ñç{T}, P::‚Ñç{T})

(3) parallelTransport(ùêí::‚ÑçVector, P::‚Ñç{T}, Q::‚Ñç{T})

(4) parallelTransport(ùêí::‚ÑçVector, P::‚Ñç{T})
for all the above: where T&lt;:RealOrComplex</code></pre><p><strong>alias</strong>: <code>pt</code></p><p>(1) <em>Parallel transport</em> of tangent vector <span>$S$</span> (a matrix) lying on  the tangent space at base-point <span>$P$</span> to the tangent space at base-point <span>$Q$</span>.</p><p><span>$S$</span>, <span>$P$</span> and <span>$Q$</span> must all be <code>Hermitian</code> matrices.  Return an <code>Hermitian</code> matrix.  The transport is defined as:</p><p><span>$‚à•_{(P‚ÜíQ)}(S)=\big(QP^{-1}\big)^{1/2}S\big(QP^{-1}\big)^{H/2}$</span>.</p><p>If <span>$S$</span> is a positive definite matrix in the manifold (and not a tangent vector)  it will be &#39;trasported&#39; from <span>$P$</span> to <span>$Q$</span>, amounting to (Yair et <em>al.</em>, 2019<a href="../introToRiemannianGeometry/#-1">üéì</a>)</p><ul><li>project <span>$S$</span> onto the tangent space at base-point <span>$P$</span>,</li><li>parallel transport it to the tangent space at base-point <span>$Q$</span>,</li><li>project it back onto the manifold at base-point <span>$Q$</span>.</li></ul><p>(2) <em>Parallel transport</em> as in (1), but to the tangent space at base-point the <em>identity matrix</em>.</p><p>The transport reduces in this case to:</p><p><span>$‚à•_{(P‚ÜíI)}(S)=P^{-1/2}SP^{-1/2}$</span>.</p><p>(3) <em>Parallel transport</em> as in (1) at once for <span>$k$</span> tangent vectors (matrices) in 1d array <span>$ùêí={S_1,...,S_k}$</span> of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>.</p><p>(4) <em>Parallel transport</em> as in (2) at once for <span>$k$</span> tangent vectors (matrices) in 1d array <span>$ùêí={S_1,...,S_k}$</span> of <a href="../MainModule/#‚ÑçVector-type-1">‚ÑçVector type</a>.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>Currently only the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric is supported for parallel transport.</p></div></div><p><strong>See also</strong>: <a href="#PosDefManifold.logMap"><code>logMap</code></a>, <a href="#PosDefManifold.expMap"><code>expMap</code></a>, <a href="#PosDefManifold.vecP"><code>vecP</code></a>, <a href="#PosDefManifold.matP"><code>matP</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold

(1)
P=randP(3)
Q=randP(3)
G=mean(Fisher, P, Q)

# i. projecting P onto the tangent space at base-point G
S=logMap(Fisher, P, G)
# ii. parallel transport S to the tangent space at base-point Q
S_=parallelTransport(S, G, Q)
# iii. projecting back into the manifold at base-point Q
P_=expMap(Fisher, S_, Q)

# i., ii. and iii. can be done simply by
PP_=parallelTransport(P, G, Q)
# check
P_‚âàPP_ ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)

(2)
P=randP(3)
Q=randP(3)
G=mean(Fisher, P, Q)
# transport to the tangent space at base-point the identity
PP_=parallelTransport(P, G)

(3)
Pset=randP(3, 4)
Q=randP(3)
G=mean(Fisher, Pset)
# trasport at once all matrices in Pset
Pset2=parallelTransport(Pset, G, Q)

(4)
Pset=randP(3, 4)
G=mean(Fisher, Pset)
# recenter all matrices so to have mean=I
Pset2=parallelTransport(Pset, G)
# check
mean(Fisher, Pset2) ‚âà I ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2727-L2814">source</a></section></article><h2 id="Procrustes-problems-1"><a class="docs-heading-anchor" href="#Procrustes-problems-1">Procrustes problems</a><a class="docs-heading-anchor-permalink" href="#Procrustes-problems-1" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.procrustes"><code>procrustes</code></a></td><td style="text-align: left">Solution to the Procrustes problem in the manifold of positive definite matrices</td></tr></table><p>‚ãÖ</p><article class="docstring"><header><a class="docstring-binding" id="PosDefManifold.procrustes" href="#PosDefManifold.procrustes"><code>PosDefManifold.procrustes</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">procrustes(P::‚Ñç{T}, Q::‚Ñç{T}, extremum=&quot;min&quot;) where T&lt;:RealOrComplex</code></pre><p>Given two positive definite matrices <span>$P$</span> and <span>$Q$</span>,  return by default the solution of problem</p><p><span>$\textrm{argmin}_UŒ¥(P,U^HQU)$</span>,</p><p>where <span>$U$</span> varies over the set of unitary matrices and <span>$Œ¥(.,.)$</span> is a  distance or divergence function.</p><p><span>$U^HQU$</span> is named in physics the <em>unitary orbit</em> of <span>$Q$</span>.</p><p>If the argument <code>extremum</code> is passed as &quot;max&quot;, it returns instead the solution of</p><p><span>$\textrm{argmax}_UŒ¥(P,U^HQU)$</span>.</p><p><span>$P$</span> and <span>$Q$</span> must be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>As it has been shown in Bhatia and Congedo (2019)<a href="../introToRiemannianGeometry/#-1">üéì</a>,  using each of the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a>, <a href="../introToRiemannianGeometry/#logdet-zero-1">logdet zero</a>, <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a>  and the Kullback-Leibler divergence (see <a href="../introToRiemannianGeometry/#logdet-Œ±-1">logdet Œ±</a>),  the best approximant to <span>$P$</span> from the unitary orbit of <span>$Q$</span>  commutes with <span>$P$</span> and, surprisingly, has the same closed-form expression, namely</p><p><span>$U_Q^‚ÜìU_P^{‚ÜìH}$</span> for the argmin and <span>$U_Q^‚ÜëU_P^{‚ÜìH}$</span> for the argmax,</p><p>where <span>$U^‚Üì$</span> denotes the eigenvector matrix of the subscript argument with  eigenvectors in columns sorted by <em>decreasing</em> order of corresponding eigenvalues and  <span>$U^‚Üë$</span> denotes the eigenvector matrix of the subscript argument with  eigenvectors in columns sorted by <em>increasing</em> order of corresponding eigenvalues.</p><p>The same solutions are known since a long time also by solving the extremal  problem here above using the <a href="../introToRiemannianGeometry/#Euclidean-1">Euclidean</a> metric (Umeyama, 1988).</p><p>The generalized Procrustes problem</p><p><span>$\textrm{argmin}_Usum_{i=1}^{k}Œ¥(P_i,U^HQ_iU)$</span></p><p>can be solved using Julia package <a href="https://github.com/kellertuer/Manopt.jl">Manopt</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(3)
Q=randP(3)
# argmin problem
U=procrustes(P, Q)
# argmax problem
V=procrustes(P, Q, &quot;max&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/8d5f48ff399bffc9faef4ad0d2be087193e72b23/src/riemannianGeometry.jl#L2846-L2895">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MainModule/">¬´ MainModule (PosDefManifold.jl)</a><a class="docs-footer-nextpage" href="../linearAlgebra/">linearAlgebra.jl ¬ª</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 11 December 2019 19:11">Wednesday 11 December 2019</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
