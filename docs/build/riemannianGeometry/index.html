<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>riemannianGeometry.jl · PosDefManifold</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PosDefManifold logo"/></a><h1>PosDefManifold</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../MainModule/">MainModule (PosDefManifold.jl)</a></li><li><a class="toctext" href="../">PosDefManifold Documentation</a></li><li><a class="toctext" href="../introToRiemannianGeometry/">Intro to Riemannian Geometry</a></li><li><a class="toctext" href="../linearAlgebra/">linearAlgebra.jl</a></li><li class="current"><a class="toctext" href>riemannianGeometry.jl</a><ul class="internal"><li><a class="toctext" href="#Geodesic-equations-1">Geodesic equations</a></li><li><a class="toctext" href="#Distances-1">Distances</a></li><li><a class="toctext" href="#Graphs-and-Laplacians-1">Graphs and Laplacians</a></li><li><a class="toctext" href="#Means-1">Means</a></li><li><a class="toctext" href="#Tangent-Space-operations-1">Tangent Space operations</a></li><li><a class="toctext" href="#Procrustes-problems-1">Procrustes problems</a></li></ul></li><li><a class="toctext" href="../signalProcessing/">signalProcessing.jl</a></li><li><a class="toctext" href="../test/">test.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>riemannianGeometry.jl</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/master/docs/src/riemannianGeometry.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>riemannianGeometry.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="riemannianGeometry.jl-1" href="#riemannianGeometry.jl-1">riemannianGeometry.jl</a></h1><p>This is the fundamental unit of <strong>PosDefManifold</strong>. It contains functions for manipulating points in the Riemannian manifold of <em>Symmetric Positive Definite (SPD)</em> or <em>Hermitian Positive Definite (HPD)</em> matrices. In Julia those are <code>Hermitian</code> matrices, see <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The functions are divided in six categories:</p><table><tr><th style="text-align: center">Category</th><th style="text-align: right">Output</th></tr><tr><td style="text-align: center">1. <a href="#Geodesic-equations-1">Geodesic equations</a></td><td style="text-align: right">interpolation, extrapolation,...</td></tr><tr><td style="text-align: center">2. <a href="#Distances-1">Distances</a></td><td style="text-align: right">length of geodesics</td></tr><tr><td style="text-align: center">3. <a href="#Graphs-and-Laplacians-1">Graphs and Laplacians</a></td><td style="text-align: right">for spectral embedding, eigenmaps, system dynamics,...</td></tr><tr><td style="text-align: center">4. <a href="#Means-1">Means</a></td><td style="text-align: right">mid-points of geodesics, centers of mass of several points</td></tr><tr><td style="text-align: center">5. <a href="#Tangent-Space-operations-1">Tangent Space operations</a></td><td style="text-align: right">maps from the manifold to the tangent space and viceversa</td></tr><tr><td style="text-align: center">6. <a href="#Procrustes-problems-1">Procrustes problems</a></td><td style="text-align: right">for data matching, transfer learning,...</td></tr></table><p>⋅</p><h2><a class="nav-anchor" id="Geodesic-equations-1" href="#Geodesic-equations-1">Geodesic equations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.geodesic" href="#PosDefManifold.geodesic"><code>PosDefManifold.geodesic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">geodesic(metric::Metric, P::ℍ, Q::ℍ, a::Real)</code></pre><p>Move along the <a href="../introToRiemannianGeometry/#geodesic-1">geodesic</a> from point <span>$P$</span> to point <span>$Q$</span>  (two positive definite matrices) with <em>arclegth</em> <span>$0&lt;=a&lt;=1$</span>,  using the specified metric, of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.</p><p>For all metrics,</p><ul><li>with <span>$a=0$</span> we stay at <span>$P$</span>,</li><li>with <span>$a=1$</span> we move up to <span>$Q$</span>,</li><li>with <span>$a=1/2$</span> we move to the mid-point of <span>$P$</span> and <span>$Q$</span> (mean).</li></ul><p>Using the Fisher metric argument <code>a</code> can be <em>any</em> real number, for instance:</p><ul><li>with <span>$0&lt;a&lt;1$</span> we move toward <span>$Q$</span> (<em>attraction</em>),</li><li>with <span>$a&gt;1$</span> we move over and beyond <span>$Q$</span> (<em>extrapolation</em>),</li><li>with <span>$a&lt;0$</span> we move back away from Q (<em>repulsion</em>).</li></ul><p>Note that if <span>$Q=I$</span>, the Fisher geodesic move is simply <span>$P^a$</span>  (no need to call this funtion then).</p><p>For the <a href="../introToRiemannianGeometry/#logdet-zero-1">logdet zero</a> and <a href="../introToRiemannianGeometry/#Jeffrey-1">Jeffrey</a> metric no closed form expression  for the geodesic is available (to the best of authors&#39; knowledge),  so in this case the geodesic is found as the weighted mean using [<code>mean(@ref)</code>].  For the <a href="../introToRiemannianGeometry/#Von-Neumann-1">Von Neumann</a> not even an expression for the mean is available,  so in this case the geodesic is not provided and a <em>warning</em> is printed.</p><p><span>$P$</span> and <span>$Q$</span> must be flagged by julia as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>Maths</strong></p><p>For points <span>$P$</span>, <span>$Q$</span> and arclength <span>$a$</span>, letting <span>$b=1-a$</span>,  the geodesic equations for the supported metrics are:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">geodesic equation</th></tr><tr><td style="text-align: center">Euclidean</td><td style="text-align: left"><span>$bP + aQ$</span></td></tr><tr><td style="text-align: center">invEuclidean</td><td style="text-align: left"><span>$\big(bP^{-1} + aQ^{-1}\big)^{-1}$</span></td></tr><tr><td style="text-align: center">ChoEuclidean</td><td style="text-align: left"><span>$TT^*$</span>, where <span>$T=bL_P + aL_Q$</span></td></tr><tr><td style="text-align: center">logEuclidean</td><td style="text-align: left"><span>$\text{exp}\big(b\text{log}(P) + a\text{log}(Q)\big)$</span></td></tr><tr><td style="text-align: center">logCholesky</td><td style="text-align: left"><span>$TT^*$</span>, where <span>$T=S_P+a(S_Q-S_P)+D_P\hspace{2pt}\text{exp}\big(a(\text{log}D_Q-\text{log}D_P)\big)$</span></td></tr><tr><td style="text-align: center">Fisher</td><td style="text-align: left"><span>$P^{1/2} \big(P^{-1/2} Q P^{-1/2}\big)^a P^{1/2}$</span></td></tr><tr><td style="text-align: center">logdet0</td><td style="text-align: left">uses weighted mean algorithm <a href="#PosDefManifold.logdet0Mean"><code>logdet0Mean</code></a></td></tr><tr><td style="text-align: center">Jeffrey</td><td style="text-align: left">uses weighted mean <a href="#Statistics.mean"><code>mean</code></a></td></tr><tr><td style="text-align: center">VonNeumann</td><td style="text-align: left">N.A.</td></tr><tr><td style="text-align: center">Wasserstein</td><td style="text-align: left"><span>$b^2P+a^2Q +ab\big[(PQ)^{1/2} +(QP)^{1/2}\big]$</span></td></tr></table><p><strong>legend:</strong> <span>$L_X$</span>, <span>$S_X$</span> and <span>$D_X$</span>    are the Cholesky lower triangle of <span>$X$</span>, its strictly lower triangular part    and diagonal part, respectively (hence, <span>$S_X+D_X=L_X$</span>,  <span>$L_XL_X^*=X$</span>).</p><p><strong>See also</strong>: <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(10)
Q=randP(10)
# Wasserstein mean
M=geodesic(Wasserstein, P, Q, 0.5)
# extrapolate suing the Fisher metric
E=geodesic(Fisher, P, Q, 2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L45-L107">source</a></section><h2><a class="nav-anchor" id="Distances-1" href="#Distances-1">Distances</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.distanceSqr" href="#PosDefManifold.distanceSqr"><code>PosDefManifold.distanceSqr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1) distanceSqr(metric::Metric, P::ℍ)
(2) distanceSqr(metric::Metric, P::ℍ, Q::ℍ)</code></pre><p><strong>alias</strong>: <code>distance²</code></p><p>(1) Return <span>$δ^2(P, I)$</span>, the <em>square of the distance</em> (or <em>divergence</em>) of positive definite  matrix <span>$P$</span> from the the identity matrix. See <a href="../introToRiemannianGeometry/#distance-from-the-origin-1">distance from the origin</a>.</p><p>(2) Return <span>$δ^2(P, Q)$</span>, the <em>square of the distance</em> (or <em>divergence</em>) between two  positive definite matrices <span>$P$</span> and <span>$Q$</span>. See <a href="../introToRiemannianGeometry/#distance-1">distance</a>.</p><p>In both cases the distance function <span>$δ$</span> is induced by the argument <code>metric</code> of type  <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.</p><p><span>$P$</span> in (1) and <span>$P$</span>, <span>$Q$</span> in (2) must be flagged by julia as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>Maths</strong></p><p>For point <span>$P$</span> the <em>squared distances from the identity</em>  for the supported metrics are:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">Squared Distance from the identity</th></tr><tr><td style="text-align: center">Euclidean</td><td style="text-align: left"><span>$∥P-I∥^2$</span></td></tr><tr><td style="text-align: center">invEuclidean</td><td style="text-align: left"><span>$∥P^{-1}-I∥^2$</span></td></tr><tr><td style="text-align: center">ChoEuclidean</td><td style="text-align: left"><span>$∥L_P-I∥^2$</span></td></tr><tr><td style="text-align: center">logEuclidean</td><td style="text-align: left"><span>$∥\textrm{log}P∥^2$</span></td></tr><tr><td style="text-align: center">logCholesky</td><td style="text-align: left"><span>$∥S_P∥^2+∥\textrm{log}D_P∥^2$</span></td></tr><tr><td style="text-align: center">Fisher</td><td style="text-align: left"><span>$∥\textrm{log}P∥^2$</span></td></tr><tr><td style="text-align: center">logdet0</td><td style="text-align: left"><span>$\textrm{logdet}\frac{1}{2}(P+I) - \frac{1}{2}\textrm{logdet}(P)$</span></td></tr><tr><td style="text-align: center">Jeffrey</td><td style="text-align: left"><span>$\frac{1}{2}\textrm{tr}(P+P^{-1})-n$</span></td></tr><tr><td style="text-align: center">VonNeumann</td><td style="text-align: left"><span>$\frac{1}{2}\textrm{tr}(P\textrm{log}P-\textrm{log}P)$</span></td></tr><tr><td style="text-align: center">Wasserstein</td><td style="text-align: left"><span>$\textrm{tr}(P+I) -2\textrm{tr}(P^{1/2})$</span></td></tr></table><p>For points <span>$P$</span> and <span>$Q$</span> their <em>squared distances</em> for the supported metrics are:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">Squared Distance</th></tr><tr><td style="text-align: center">Euclidean</td><td style="text-align: left"><span>$∥P-Q∥^2$</span></td></tr><tr><td style="text-align: center">invEuclidean</td><td style="text-align: left"><span>$∥P^{-1}-Q^{-1}∥^2$</span></td></tr><tr><td style="text-align: center">ChoEuclidean</td><td style="text-align: left"><span>$∥ L_P - L_Q ∥^2$</span></td></tr><tr><td style="text-align: center">logEuclidean</td><td style="text-align: left"><span>$∥\textrm{log}P-\textrm{log}Q∥^2$</span></td></tr><tr><td style="text-align: center">logCholesky</td><td style="text-align: left"><span>$∥S_P-S_Q∥^2+∥\textrm{log}D_P-\textrm{log}D_Q∥^2$</span></td></tr><tr><td style="text-align: center">Fisher</td><td style="text-align: left"><span>$∥\textrm{log}(P^{-1/2}QP^{-1/2})∥^2$</span></td></tr><tr><td style="text-align: center">logdet0</td><td style="text-align: left"><span>$\textrm{logdet}\frac{1}{2}(P+Q) - \frac{1}{2}\textrm{logdet}(PQ)$</span></td></tr><tr><td style="text-align: center">Jeffrey</td><td style="text-align: left"><span>$\frac{1}{2}\textrm{tr}(Q^{-1}P+P^{-1}Q)-n$</span></td></tr><tr><td style="text-align: center">VonNeumann</td><td style="text-align: left"><span>$\frac{1}{2}\textrm{tr}(P\textrm{log}P-P\textrm{log}Q+Q\textrm{log}Q-Q\textrm{log}P)$</span></td></tr><tr><td style="text-align: center">Wasserstein</td><td style="text-align: left"><span>$\textrm{tr}(P+Q) -2\textrm{tr}(P^{1/2}QP^{1/2})^{1/2}$</span></td></tr></table><p><strong>legend:</strong> <span>$L_X$</span>, <span>$S_X$</span> and <span>$D_X$</span>   are the Cholesky lower triangle of <span>$X$</span>, its strictly lower triangular part   and diagonal part, respectively (hence, <span>$S_X+D_X=L_X$</span>,  <span>$L_XL_X^*=X$</span>).</p><p><strong>See also</strong>: <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>.</p><p><strong>Examples (1)</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(10)
d=distanceSqr(Wasserstein, P)
e=distanceSqr(Fisher, P)
metric=Metric(Int(logdet0)) # or metric=logdet0
s=string(metric) # check what is the current metric
f=distance²(metric, P) #using the alias distance²</code></pre><p><strong>Examples (2)</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(10)
Q=randP(10)
d=distanceSqr(logEuclidean, P, Q)
e=distance²(Jeffrey, P, Q)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L160-L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.distance" href="#PosDefManifold.distance"><code>PosDefManifold.distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1) distance(metric::Metric, P::ℍ)
(2) distance(metric::Metric, P::ℍ, Q::ℍ)</code></pre><p>(1) Return <span>$δ(P, I)$</span>, the <em>distance</em> between positive definite matrix <span>$P$</span> and  the identity matrix.</p><p>(2) Return <span>$δ(P, Q)$</span>, the <em>distance</em> between positive definite  matrices <span>$P$</span> and <span>$Q$</span>.</p><p>This is the square root of <a href="#PosDefManifold.distanceSqr"><code>distanceSqr</code></a>  and is invoked with the same syntax therein.</p><p><strong>See also</strong>: <a href="#PosDefManifold.distanceMat"><code>distanceMat</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L316-L330">source</a></section><h2><a class="nav-anchor" id="Graphs-and-Laplacians-1" href="#Graphs-and-Laplacians-1">Graphs and Laplacians</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.distanceSqrMat" href="#PosDefManifold.distanceSqrMat"><code>PosDefManifold.distanceSqrMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distanceSqrMat(metric::Metric, 𝐏::ℍVector)</code></pre><p><strong>alias</strong>: <code>distance²Mat</code></p><p>Given a 1d array <code>𝐏</code> of <span>$k$</span> positive definite matrices  <span>${P_1,...,P_k}$</span> of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a>, create the <span>$k⋅k$</span> real <code>Hermitian</code>  matrix comprising elements <span>$δ^2(P_i, P_j)\textrm{, for all }i≠j$</span>.</p><p>This is the matrix of all <em>squared inter-distances</em> (zero on diagonal), using the  specified <code>metric</code>, of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>,  giving rise to distance function <span>$δ$</span>. See <a href="#PosDefManifold.distanceSqr"><code>distanceSqr</code></a>.</p><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#distance-1">distance</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.laplacian"><code>laplacian</code></a>, <a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a>, <a href="#PosDefManifold.spectralEmbedding"><code>spectralEmbedding</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 4 random 10x10 SPD matrices
Pset=randP(10, 4) # or, using unicode: 𝐏=randP(10, 4)
# Compute the squared inter-distance matrix according to the log Euclidean metric.
# This is much faster as compared to the Fisher metric and in general
# it is a good approximation.
Dsqr=distanceSqrMat(logEuclidean, Pset)
# or, using unicode: Δ²=distanceSqrMat(logEuclidean, 𝐏)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L398-L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.distanceMat" href="#PosDefManifold.distanceMat"><code>PosDefManifold.distanceMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distanceMat(metric::Metric, 𝐏::ℍVector)</code></pre><p>Given a 1d array <code>𝐏</code> of <span>$k$</span> positive definite matrices  <span>${P_1,...,P_k}$</span> of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a>, create the <span>$k⋅k$</span> real <code>Hermitian</code>  matrix comprising elements  <span>$δ(P_i, P_j)\textrm{, for all }i≠j$</span>.</p><p>This is the matrix of all <em>inter-distances</em> (zero on diagonal), using the  specified <code>metric</code>, of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>,  giving rise to distance <span>$δ$</span>. See <a href="#PosDefManifold.distance"><code>distance</code></a>.</p><p>The elements of this matrix are the square root of  <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>.</p><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#distance-1">distance</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 4 random 10x10 SPD matrices
Pset=randP(10, 4) # or, using unicode: 𝐏=randP(10, 4)
D=distanceMat(Fisher, Pset)
# or, using unicode: Δ=distanceMat(Fisher, 𝐏)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L430-L453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.laplacian" href="#PosDefManifold.laplacian"><code>PosDefManifold.laplacian</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">laplacian(Δ²)</code></pre><p>Given a matrix of squared inter-distances <span>$Δ^2$</span>,  computed for examples by function <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>,  return the <em>normalized Laplacian</em>.</p><p>First, a <a href="https://bit.ly/1HVyf55">Gaussian radial basis functions</a>  is applied to all elements of <span>$Δ^2$</span>, such as</p><p><span>$W_{ij} = exp(\frac{\displaystyle{-Δ^2_{ij}}}{\displaystyle{ε}})$</span>,</p><p>where <span>$ε$</span> is the Gaussian scale parameter chosen automatically   as the median of the elements <span>$Δ^2_{ij}$</span>.</p><p>Finally, the normalized Laplacian is defined as</p><p><span>$Ω = D^{-1/2}WD^{-1/2}$</span>,</p><p>where <span>$D$</span> is the diagonal matrix holding on the main diagonal   the sum of the rows (or columns) of <span>$W$</span>.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The normalized Laplacian as here defined can be requested for any input matrix of squared inter-distances, for example, those obtained on scalars or on vectors using appropriate metrics.</p></div></div><p><strong>See also</strong>: <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>, <a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a>, <a href="#PosDefManifold.spectralEmbedding"><code>spectralEmbedding</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 4 random 10x10 SPD matrices
Pset=randP(10, 4) # or, using unicode: 𝐏=randP(10, 4)
Dsqr=distanceSqrMat(Fisher, Pset) # or: Δ²=distanceSqrMat(Fisher, 𝐏)
lap=laplacian(Dsqr) # or: Ω=laplacian(Δ²)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L457-L493">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.laplacianEigenMaps" href="#PosDefManifold.laplacianEigenMaps"><code>PosDefManifold.laplacianEigenMaps</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">laplacianEigenMaps(Ω, q::Int;
                  &lt;tol=1e-9, maxiter=300, ⍰=false&gt;)</code></pre><p><strong>alias</strong>: <code>laplacianEM</code></p><p>Given a normalized Laplacian <span>$Ω$</span> (see <a href="#PosDefManifold.laplacian"><code>laplacian</code></a> ) return  the <em>eigen maps</em> in <span>$q$</span> dimensions, i.e., the <span>$q$</span> eigenvectors of  the normalized Laplacian associated with the largest <span>$q$</span>  eigenvalues, excluding the first (which is always equal to 1.0).</p><p>The eigenvectors of the normalized Laplacian are computed by the  power iterations+modified Gram-Schmidt method,  allowing calling this function even for big Laplacian matrices.</p><p>Return the 4-tuple <span>$(Λ, U, iterations, convergence)$</span>, where:</p><ul><li><span>$Λ$</span> is a <span>$q⋅q$</span> diagonal matrix holding on diagonal the eigenvalues corresponding to the <span>$q$</span> dimensions of the Laplacian eigen maps,</li><li><span>$U$</span> holds in columns the eigen maps, that is, the <span>$q$</span> eigenvectors,</li><li><span>$iterations$</span> is the number of iterations executed by the power method,</li><li><span>$convergence$</span> is the convergence attained by the power method.</li></ul><p>The eigenvectors of <span>$U$</span> holds the coordinates of the points in a  low-dimension Euclidean space (typically two or three).  This is done for, among other purposes, classifying them and  following their trajectories over time or other dimensions.  For examples of applications see Ridrigues et <em>al.</em> (2018) <a href="../introToRiemannianGeometry/#-1">🎓</a>  and references therein.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The maximum value of <span>$q$</span> that can be requested is <span>$n-1$</span>, where <span>$n$</span> is the size of the Laplacian. In general, <span>$q=2$</span> or <span>$q=3$</span> is requested.</p></div></div><p><strong>Arguments</strong>: <code>(Ω, q; &lt;tol=1e-9, maxiter=300, ⍰=false&gt;)</code>:</p><ul><li><span>$Ω$</span> is a normalized Laplacian obtained by the <a href="#PosDefManifold.laplacian"><code>laplacian</code></a> function,</li><li><span>$q$</span> is the dimension of the Laplacian eigen maps;</li><li>The following are <em>&lt;optional keyword arguments&gt;</em> for the power method iterative algorithm:<ul><li><code>tol</code> is the tolerance for convergence,</li><li><code>maxiter</code> is the maximum number of iterations allowed,</li><li>if <code>⍰</code> is true, the convergence at all iterations will be printed.</li></ul></li></ul><p><strong>See also</strong>: <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>, <a href="#PosDefManifold.laplacian"><code>laplacian</code></a>, <a href="#PosDefManifold.spectralEmbedding"><code>spectralEmbedding</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 4 random 10x10 SPD matrices
Pset=randP(10, 4) # or, using unicode: 𝐏=randP(10, 4)
Dsqr=distanceSqrMat(Fisher, Pset) #or: Δ²=distanceSqrMat(Fisher, 𝐏)
lap= laplacian(Dsqr) # or: Ω=laplacian(Δ²)
evalues, maps, iterations, convergence=laplacianEM(lap, 2)
evalues, maps, iterations, convergence=laplacianEM(lap, 2; maxiter=500)
evalues, maps, iterations, convergence=laplacianEM(lap, 2; ⍰=true)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L506-L560">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.spectralEmbedding" href="#PosDefManifold.spectralEmbedding"><code>PosDefManifold.spectralEmbedding</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spectralEmbedding(metric::Metric, 𝐏::ℍVector, q::Int;
                 &lt;tol=1e-9, maxiter=300, ⍰=false&gt;)</code></pre><p>Given a 1d array <code>𝐏</code> of <span>$k$</span> positive definite matrices <span>${P_1,...,P_k}$</span>,  compute its <em>eigen maps</em> in <span>$q$</span> dimensions.</p><p>This function runs one after the other the functions:</p><ul><li><a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a> (compute the squared inter-distance matrix),</li><li><a href="#PosDefManifold.laplacian"><code>laplacian</code></a> (compute the normalized Laplacian),</li><li><a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a> (get the eigen maps).</li></ul><p>Return the 4-tuple <code>(Λ, U, iterations, convergence)</code>, where:</p><ul><li><span>$Λ$</span> is a <span>$q⋅q$</span> diagonal matrix holding on diagonal the eigenvalues corresponding to the <span>$q$</span> dimensions of the Laplacian eigen maps,</li><li><span>$U$</span> holds in columns the <span>$q$</span> eigenvectors, i.e., the <span>$q$</span> coordinates of the points in the embedded space,</li><li><span>$iterations$</span> is the number of iterations executed by the power method,</li><li><span>$convergence$</span> is the convergence attained by the power method.</li></ul><p><strong>Arguments</strong> <code>(metric, 𝐏, q, &lt;tol=1e-9, maxiter=300, ⍰=false&gt;)</code>:</p><ul><li><code>metric</code> is the metric of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a> used for computing the inter-distances,</li><li><code>𝐏</code> is a 1d array of <span>$k$</span> positive matrices of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a>,</li><li><span>$q$</span> is the dimension of the Laplacian eigen maps;</li><li>The following are <em>&lt;optional keyword arguments&gt;</em> for the power method iterative algorithm:<ul><li><code>tol</code> is the tolerance for convergence of the power method,</li><li><code>maxiter</code> is the maximum number of iterations allowed for the power method,</li><li>if <code>⍰</code> is true the convergence at all iterations will be printed.</li></ul></li></ul><p><strong>See also</strong>: <a href="#PosDefManifold.distanceSqrMat"><code>distanceSqrMat</code></a>, <a href="#PosDefManifold.laplacian"><code>laplacian</code></a>, <a href="#PosDefManifold.laplacianEigenMaps"><code>laplacianEigenMaps</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# Generate a set of 4 random 10x10 SPD matrices
Pset=randP(10, 4) # or, using unicode: 𝐏=randP(10, 4)
evalues, maps, iterations, convergence=spectralEmbedding(logEuclidean, Pset, 2)
evalues, maps, iterations, convergence=spectralEmbedding(logEuclidean, Pset, 2; ⍰=true)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L570-L606">source</a></section><h2><a class="nav-anchor" id="Means-1" href="#Means-1">Means</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1) mean(metric::Metric, P::ℍ, Q::ℍ)

(2) mean(metric::Metric, 𝐏::ℍVector;
        &lt;w::Vector=[], ✓w=true&gt;)</code></pre><p>(1) Mean of two positive definite matrices, passed in arbitrary order as  arguments <span>$P$</span> and <span>$Q$</span>, using the specified <code>metric</code> of type  <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.  The order is arbitrary as all metrics implemented in <strong>PosDefManifold</strong> are symmetric.  This is the midpoint of the geodesic.  For the weighted mean of two positive definite matrices use instead  the <a href="#PosDefManifold.geodesic"><code>geodesic</code></a> function.  <span>$P$</span> and <span>$Q$</span> must be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>(2) <a href="../introToRiemannianGeometry/#Fréchet-mean-1">Fréchet mean</a> of an 1d array <span>$𝐏$</span> of <span>$k$</span> positive definite  matrices <span>$𝐏={P_1,...,P_k}$</span> of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a>,  with optional non-negative real weights <span>$w={w_1,...,w_k}$</span> and using the  specified <code>metric</code>as in (1).</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted mean</em>.</p><p>If <em>&lt;optional keword argument&gt;</em> <code>✓w=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p><strong>Math</strong></p><p>The Fréchet mean of a set of <span>$k$</span> matrices <span>${P_1, P_2,..., P_k}$</span> weighted by  <span>${w_1, w_2,..., w_k}:\sum_{i=1}^{k}w_i=1$</span> for the supported metrics are,  for those with closed form expression:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">weighted Fréchet mean</th></tr><tr><td style="text-align: center">Euclidean</td><td style="text-align: left"><span>$\sum_{i=1}^{k}w_i P_i$</span></td></tr><tr><td style="text-align: center">invEuclidean</td><td style="text-align: left"><span>$\big(\sum_{i=1}^{k}w_i P_i^{-1}\big)^{-1}$</span></td></tr><tr><td style="text-align: center">ChoEuclidean</td><td style="text-align: left"><span>$TT^*$</span>, where <span>$T=bL_P + aL_Q$</span></td></tr><tr><td style="text-align: center">logEuclidean</td><td style="text-align: left"><span>$\textrm{exp}\big(\sum_{i=1}^{k}w_i\hspace{1pt} \textrm{log}P_i \big)$</span></td></tr><tr><td style="text-align: center">logCholesky</td><td style="text-align: left"><span>$TT^*$</span>, where <span>$T=\sum_{i=1}^{k}(w_kS_k)+\sum_{i=1}^{k}(w_k\textrm{log}D_k)$</span></td></tr><tr><td style="text-align: center">Jeffrey</td><td style="text-align: left"><span>$A^{1/2}\big(A^{-1/2}HA^{-1/2}\big)^{1/2}A^{1/2}$</span></td></tr></table><p>and for those that verify an equation:</p><table><tr><th style="text-align: center">Metric</th><th style="text-align: left">equation verified by the weighted Fréchet mean</th></tr><tr><td style="text-align: center">Fisher</td><td style="text-align: left"><span>$\sum_{i=1}^{k}w_i\textrm{log}\big(G^{-1/2} P_k G^{-1/2}\big)=0.$</span></td></tr><tr><td style="text-align: center">logdet0</td><td style="text-align: left"><span>$\sum_{i=1}^{k}w_i\big(\frac{1}{2}P_i+\frac{1}{2}G\big)^{-1}=G^{-1}$</span></td></tr><tr><td style="text-align: center">VonNeumann</td><td style="text-align: left">N.A.</td></tr><tr><td style="text-align: center">Wasserstein</td><td style="text-align: left"><span>$G=\sum_{i=1}^{k}w_i\big( G^{1/2}  P_i G^{1/2}\big)^{1/2}$</span></td></tr></table><p><strong>legend:</strong> <span>$L_X$</span>, <span>$S_X$</span> and <span>$D_X$</span>   are the Cholesky lower triangle of <span>$X$</span>, its strictly lower triangular part   and diagonal part, respectively (hence, <span>$S_X+D_X=L_X$</span>,  <span>$L_XL_X^*=X$</span>).   <span>$A$</span> and <span>$H$</span> are the weighted arithmetic and weighted harmonic mean, respectively.</p><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#geodesic-1">geodesic</a>, <a href="../introToRiemannianGeometry/#mean-1">mean</a>, <a href="../introToRiemannianGeometry/#Fréchet-mean-1">Fréchet mean</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, Statistics, PosDefManifold
# Generate 2 random 3x3 SPD matrices
P=randP(3)
Q=randP(3)
M=mean(logdet0, P, Q) # (1)
M=mean(logdet0, P, Q) # (1)

R=randP(3)
# passing several matrices and associated weights listing them
# weights vector, does not need to be normalized
mean(Fisher, ℍVector([P, Q, R]); w=[1, 2, 3])

# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: 𝐏=randP(3, 4)
weights=[1, 2, 3, 1]
# passing a vector of Hermitian matrices (ℍVector type)
M=mean(Euclidean, Pset; w=weights) # (2) weighted Euclidean mean
M=mean(Wasserstein, Pset)  # (2) unweighted Wassertein mean
# using unicode: M=mean(Wasserstein, 𝐏)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L619-L699">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.means" href="#PosDefManifold.means"><code>PosDefManifold.means</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">means(metric::Metric, ℘::ℍVector₂)</code></pre><p>Given a 2d array <code>℘</code> of positive definite matrices as an <a href="../MainModule/#ℍVector-type-1">ℍVector₂ type</a>  compute the <a href="../introToRiemannianGeometry/#Fréchet-mean-1">Fréchet mean</a> for as many <a href="../MainModule/#ℍVector-type-1">ℍVector type</a> object  as hold in <code>℘</code>, using the specified <code>metric</code> of type  <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.   Return the means in a vector of Hermitian matrices, that is, as an <code>ℍVector</code> type.</p><p>The weigted Fréchet mean is not supported in this function.</p><p><strong>See also</strong>: <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none"> using PosDefManifold
 # Generate a set of 4 random 3x3 SPD matrices
 Pset=randP(3, 4) # or, using unicode: 𝐏=randP(3, 4)
 # Generate a set of 40 random 4x4 SPD matrices
 Qset=randP(3, 4) # or, using unicode: 𝐐=randP(3, 4)
 # listing directly ℍVector objects
 means(logEuclidean, ℍVector₂([Pset, Qset])) # or: means(logEuclidean, ℍVector₂([𝐏, 𝐐]))
 # note that [𝐏, 𝐐] is actually a ℍVector₂ type object

 # creating and passing an object of ℍVector₂ type
 sets=ℍVector₂(undef, 2) # or: ℘=ℍVector₂(undef, 2)
 sets[1]=Pset # or: ℘[1]=𝐏
 sets[2]=Qset # or: ℘[2]=𝐐
 means(logEuclidean, sets) # or: means(logEuclidean, ℘)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L765-L794">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.generalizedMean" href="#PosDefManifold.generalizedMean"><code>PosDefManifold.generalizedMean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">generalizedMean(𝐏::ℍVector, p::Real;
               &lt;w::Vector=[], ✓w=true&gt;)</code></pre><p>Given a 1d array <code>𝐏</code> of <span>$k$</span> positive definite matrices <span>$𝐏={P_1,...,P_k}$</span>  of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a> and optional non-negative real weights vector <span>$w={w_1,...,w_k}$</span>,  return the <em>weighted generalized mean</em> <span>$G$</span> with real parameter <span>$p$</span>, that is,</p><p><span>$G=\big(\sum_{i=1}^{k}w_iP_i^p\big)^{1/p}$</span>.</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted generalized mean</em>.</p><p><span>$G=\big(\sum_{i=1}^{k}P_i^p\big)^{1/p}$</span>.</p><p>If <em>&lt;optional keword argument&gt;</em> <code>✓w=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed.  This option is provided to allow  calling this function repeatedly without normalizing the weights each time.</p><p>The following special cases for parameter <span>$p$</span> are noteworthy:</p><ul><li>For <span>$p=\frac{1}{2}$</span> the generalized mean is the <a href="../introToRiemannianGeometry/#modified-Bhattacharyya-mean-1">modified Bhattacharyya mean</a>.</li><li>For <span>$p=1$</span> the generalized mean is the <a href="../introToRiemannianGeometry/#Euclidean-1">Euclidean</a> mean.</li><li>For <span>$p=-1$</span> the generalized mean is the <a href="../introToRiemannianGeometry/#inverse-Euclidean-1">inverse Euclidean</a> mean.</li><li>For <span>$p=0$</span> the generalized mean is the <a href="../introToRiemannianGeometry/#log-Euclidean-1">log Euclidean</a> mean, which is the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> mean when matrices in 𝐏 all pair-wise commute.</li></ul><p>Notice that when matrices in 𝐏 all pair-wise commute,  the generalized means coincide with the <a href="../introToRiemannianGeometry/#power-means-1">power means</a>  for any <span>$p∈[-1, 1]$</span> and for <span>$p=0.5$</span> it coincides also with the  <em>Wasserstein</em> mean. For this reason the generalized means are used  as default initialization of both the <a href="#PosDefManifold.powerMean"><code>powerMean</code></a> and <a href="#PosDefManifold.wasMean"><code>wasMean</code></a>  algorithm.</p><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.powerMean"><code>powerMean</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, Statistics, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: 𝐏=randP(3, 4)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# unweighted mean
G = generalizedMean(Pset, 0.25) # or: G = generalizedMean(𝐏, 0.25)

# weighted mean
G = generalizedMean(Pset, 0.5; w=weights)

# with weights previously normalized we can set ✓w=false
weights=weights./sum(weights)
G = generalizedMean(Pset, 0.5; w=weights, ✓w=false)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L798-L853">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.logdet0Mean" href="#PosDefManifold.logdet0Mean"><code>PosDefManifold.logdet0Mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logdet0Mean(𝐏::ℍVector;
           &lt;w::Vector=[], ✓w=true, init=nothing, tol=1e-9, ⍰=false&gt;)</code></pre><p>Given a 1d array <span>$𝐏$</span> of <span>$k$</span> positive definite matrices <span>$𝐏={P_1,...,P_k}$</span>  of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a> and optional non-negative real weights vector <span>$w={w_1,...,w_k}$</span>,  return the 3-tuple <span>$(G, iter, conv)$</span>, where <span>$G$</span> is the mean according  to the <a href="../introToRiemannianGeometry/#logdet-zero-1">logdet zero</a> metric and <span>$iter$</span>, <span>$conv$</span> are the number of iterations  and convergence attained by the algorithm.  Mean <span>$G$</span> is the unique positive definite matrix satisfying</p><p><span>$\sum_{i=1}^{k}w_i\big(\frac{1}{2}P_i+\frac{1}{2}G\big)^{-1}=G^{-1}$</span>.</p><p>For estimating it, this function implements the fixed-point iteration algorithm suggested by (Moakher, 2012, p315)<a href="../introToRiemannianGeometry/#-1">🎓</a>, yielding iterations</p><p><span>$G ← \frac{1}{2}\big(\sum_{i=1}^{k}w_i(P_i+G)^{-1}\big)^{-1}$</span>.</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted logdet zero mean</em>.</p><p>If <em>&lt;optional keword argument&gt;</em> <code>✓w=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>The following are more <em>&lt;optional keyword arguments</em>&gt;:</p><ul><li><code>init</code> is a matrix to be used as initialization for the mean. If no matrix is provided, the <a href="../introToRiemannianGeometry/#log-Euclidean-1">log Euclidean</a> mean will be used,</li><li><code>tol</code> is the tolerance for the convergence. The smaller this number (it must be positive) the closer the algorithm gets to the saddle point,</li><li>if <code>⍰</code> is true, the convergence attained at each iteration is printed.</li></ul><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>In normal circumstances this algorithm converges monothonically. If the algorithm diverges a <strong>warning</strong> is printed indicating the iteration when this happened.</p></div></div><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#logdet-zero-1">logdet zero</a> metric, <a href="../introToRiemannianGeometry/#modified-Bhattacharyya-mean-1">modified Bhattacharyya mean</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: 𝐏=randP(3, 4)

# unweighted mean
G, iter, conv = logdet0Mean(Pset) # or G, iter, conv = logdet0Mean(𝐏)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# weighted mean
G, iter, conv = logdet0Mean(Pset, w=weights)

# print the convergence at all iterations
G, iter, conv = logdet0Mean(Pset; w=weights, ⍰=true)

# now suppose Pset has changed a bit, initialize with G to hasten convergence
Pset[1]=ℍ(Pset[1]+(randP(3)/100))
G, iter, conv = logdet0Mean(Pset; w=weights, ✓w=false, ⍰=true, init=G)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L871-L932">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.wasMean" href="#PosDefManifold.wasMean"><code>PosDefManifold.wasMean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wasMean(𝐏::ℍVector;
       &lt;w::Vector=[], ✓w=true, init=nothing, tol=1e-9, ⍰=false&gt;)</code></pre><p>Given a 1d array <code>𝐏</code> of <span>$k$</span> positive definite matrices <span>$𝐏={P_1,...,P_k}$</span>  of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a> and optional non-negative real weights vector <span>$w={w_1,...,w_k}$</span>,  return the 3-tuple <span>$(G, iter, conv)$</span>, where <span>$G$</span> is the mean according  to the <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a> metric and <span>$iter$</span>, <span>$conv$</span> are the number of iterations  and convergence attained by the algorithm.  Mean <span>$G$</span> is the unique positive definite matrix satisfying</p><p><span>$G=\sum_{i=1}^{k}w_i\big( G^{1/2}  P_i G^{1/2}\big)^{1/2}$</span>.</p><p>For estimating it, this function implements the fixed-point iterative algorithm  proposed by (Álvarez-Esteban et <em>al.</em>, 2016)<a href="../introToRiemannianGeometry/#-1">🎓</a>:</p><p><span>$G ← G^{-1/2}\big(\sum_{i=1}^{k} w_i(G^{1/2}P_i G^{1/2})^{1/2}\big)^2 G^{-1/2}$</span>.</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted Wassertein mean</em>.</p><p>If <em>&lt;optional keword argument&gt;</em> <code>✓w=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and they should be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>The following are more <em>&lt;optional keyword arguments</em>&gt;:</p><ul><li><code>init</code> is a matrix to be used as initialization for the mean. If no matrix is provided, the instance of <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a> with <span>$p=0.5$</span> will be used,</li><li><code>tol</code> is the tolerance for the convergence. The smaller this number (it must be positive) the closer the algorithm gets to the true solution,</li><li>if <code>⍰</code> is true, the convergence attained at each iteration is printed.</li></ul><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>In normal circumstances this algorithm converges monothonically. If the algorithm diverges a <strong>warning</strong> is printed indicating the iteration when this happened.</p></div></div><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a> metric.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: 𝐏=randP(3, 4)

# unweighted mean
G, iter, conv = wasMean(Pset) # or: G, iter, conv = wasMean(𝐏)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# weighted mean
G, iter, conv = wasMean(Pset; w=weights)

# print the convergence at all iterations
G, iter, conv = wasMean(Pset; w=weights, ⍰=true)

# now suppose 𝐏 has changed a bit, initialize with G to hasten convergence
Pset[1]=ℍ(Pset[1]+(randP(3)/100))
G, iter, conv = wasMean(Pset; w=weights, ⍰=true, init=G)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L962-L1022">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.powerMean" href="#PosDefManifold.powerMean"><code>PosDefManifold.powerMean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">powerMean(𝐏::ℍVector, p::Real;
         &lt;w::Vector=[], ✓w=true, init=nothing, tol=1e-9, ⍰=false&gt;)</code></pre><p>Given a 1d array <code>𝐏</code> of <span>$k$</span> positive definite matrices <span>$𝐏={P_1,...,P_k}$</span>  of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a>,  an optional non-negative real weights vector <span>$w={w_1,...,w_k}$</span> and  a real parameter <code>p</code> <span>$\in[-1, 1]$</span>, return the  3-tuple <span>$(G, iter, conv)$</span>, where <span>$G$</span> is  Lim and Palfia (2012)&#39;s <a href="../introToRiemannianGeometry/#power-means-1">power means</a>  of order <span>$p$</span> and  <span>$iter$</span>, <span>$conv$</span> are the number of iterations  and convergence attained by the algorithm, respectively.  Mean <span>$G$</span> is the unique positive definite matrix satisfying</p><p><span>$G=\sum_{i=1}^{k}(w_iG\textrm{#}_pP_i)$</span>,</p><p>where <span>$G\textrm{#}_pP_i$</span> is the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> geodesic equation.  In particular:</p><ul><li>with <span>$p=-1$</span> this is the <em>harmonic mean</em> (see the <a href="../introToRiemannianGeometry/#inverse-Euclidean-1">inverse Euclidean</a>)</li><li>with <span>$p=+1$</span> this is the <em>arithmetic mean</em> (see the <a href="../introToRiemannianGeometry/#Euclidean-1">Euclidean</a>)</li><li>at the limit of <span>$p$</span> evaluated at zero from both side this is the <em>geometric mean</em> (see the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric).</li></ul><p>For estimating power means for <span>$p\in(-1, 1)$</span>, this function implements  the  fixed-point iterative algorithm of (Congedo et <em>al.</em>, 2017b)<a href="../introToRiemannianGeometry/#-1">🎓</a>.  For <span>$p=0$</span> (geometric mean)  this algorithm is run two times with a small positive and negative value  of <span>$p$</span> and the geometric mean of the two  resulting means is returned, as suggested in (Congedo et <em>al.</em>, 2017b)<a href="../introToRiemannianGeometry/#-1">🎓</a>.  This way of estimating the geometric mean of  a set of matrices is faster as compared to the usual gradient descent algorithm.</p><p>If you don&#39;t pass a weight vector with <em>&lt;optional keyword argument&gt;</em> <span>$w$</span>,  return the <em>unweighted power mean</em>.</p><p>If <em>&lt;optional keword argument&gt;</em> <code>✓w=true</code> (default), the weights are  normalized so as to sum up to 1, otherwise they are used as they are passed  and should type be already normalized.  This option is provided to allow  calling this function repeatedly without normalizing the same weights  vector each time.</p><p>The following are more <em>&lt;optional keyword arguments</em>&gt;:</p><ul><li><code>init</code> is a matrix to be used as initialization for the mean. If no matrix is provided, the instance of <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a> with parameter <span>$p$</span> will be used.</li><li><code>tol</code> is the tolerance for the convergence. The smaller this number (it must be positive) the closer the algorithm gets to the true solution;</li><li>if <code>⍰</code> is true, the convergence attained at each iteration is printed.</li></ul><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>In normal circumstances this algorithm converges monothonically. If the algorithm diverges a <strong>warning</strong> is printed indicating the iteration when this happened.</p></div></div><p><strong>See</strong>: <a href="../introToRiemannianGeometry/#power-means-1">power means</a>, <a href="../introToRiemannianGeometry/#generalized-means-1">generalized means</a>, <a href="../introToRiemannianGeometry/#modified-Bhattacharyya-mean-1">modified Bhattacharyya mean</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
# Generate a set of 4 random 3x3 SPD matrices
Pset=randP(3, 4) # or, using unicode: 𝐏=randP(3, 4)

# unweighted mean
G, iter, conv = powerMean(Pset, 0.5) # or G, iter, conv = powerMean(𝐏, 0.5)

# weights vector, does not need to be normalized
weights=[1, 2, 3, 1]

# weighted mean
G, iter, conv = powerMean(Pset, 0.5; w=weights)

# print the convergence at all iterations
G, iter, conv = powerMean(Pset, 0.5; w=weights, ⍰=true)

# now suppose 𝐏 has changed a bit, initialize with G to hasten convergence
Pset[1]=ℍ(Pset[1]+(randP(3)/100))
G, iter, conv = powerMean(Pset, 0.5; w=weights, ⍰=true, init=G)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L1052-L1126">source</a></section><h2><a class="nav-anchor" id="Tangent-Space-operations-1" href="#Tangent-Space-operations-1">Tangent Space operations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.logMap" href="#PosDefManifold.logMap"><code>PosDefManifold.logMap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logMap(metric::Metric, P::ℍ, G::ℍ)</code></pre><p><em>Logaritmic Map:</em> map a positive definite matrix <span>$P$</span> from the SPD or  Hermitian manifold into the tangent space at base-point <span>$G$</span> using the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric.</p><p><span>$P$</span> and <span>$G$</span> must be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The map is defined as</p><p><span>$Log_G(P)=S=G^{1/2}\textrm{log}\big(G^{-1/2}PG^{-1/2}\big)G^{1/2}$</span>.</p><p>The result is an <code>Hermitian</code> matrix.  The inverse operation is <a href="#PosDefManifold.expMap"><code>expMap</code></a>.</p><p><strong>Arguments</strong> <code>(metric, P, G)</code>:</p><ul><li><code>metric</code> is a metric of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>.</li><li><span>$P$</span> is the positive definite matrix to be projected onto the tangent space,</li><li><span>$G$</span> is the tangent space base point,</li></ul><p>Currently only the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric is supported for tangent space operations.</p><p><strong>See also</strong>: <a href="#PosDefManifold.vecP"><code>vecP</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(3)
Q=randP(3)
metric=Fisher
G=mean(metric, P, Q)
# projecting P at the base point given by the geometric mean of P and Q
S=logMap(metric, P, G)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L1180-L1212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.expMap" href="#PosDefManifold.expMap"><code>PosDefManifold.expMap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">expMap(metric::Metric, S::ℍ, G::ℍ)</code></pre><p><em>Exponential Map:</em> map an <code>Hermitian</code> matrix <span>$S$</span> from the tangent space at base  point <span>$G$</span> into the SPD or Hermitian manifold (using the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a> metric).</p><p><span>$S$</span> and <span>$G$</span> must be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The map is defined as</p><p><span>$Exp_G(S)=P=G^{1/2}\textrm{exp}\big(G^{-1/2}SG^{-1/2}\big)G^{1/2}$</span>.</p><p>The result is a positive definite matrix.  The inverse operation is <a href="#PosDefManifold.logMap"><code>logMap</code></a>.</p><p><strong>Arguments</strong> <code>(metric, S, G)</code>:</p><ul><li><code>metric</code> is a metric of type <a href="../MainModule/#Metric::Enumerated-type-1">Metric::Enumerated type</a>,</li><li><span>$S$</span> is a Hermitian matrix, real or complex, to be projected on the SPD or Hermitian manifold,</li><li><span>$G$</span> is the tangent space base point.</li></ul><p>Currently only the Fisher metric is supported for tangent space operations.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold, LinearAlgebra
P=randP(3)
Q=randP(3)
G=mean(Fisher, P, Q)
# projecting P on the tangent space at the Fisher mean base point G
S=logMap(Fisher, P, G)
# adding the identity in the tangent space and reprojecting back onto the manifold
H=expMap(Fisher, ℍ(S+I), G)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L1222-L1254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.vecP" href="#PosDefManifold.vecP"><code>PosDefManifold.vecP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">vecP(S::ℍ)</code></pre><p><em>Vectorize</em> a tangent vector (matrix) <span>$S$</span> (<em>i.e.</em>, an <code>Hermitian</code> matrix):  mat -&gt; vec.</p><p>It gives weight <span>$1$</span> to diagonal elements and √2 to off-diagonal elements  (Barachant et <em>al.</em>, 2012)<a href="../introToRiemannianGeometry/#-1">🎓</a>.</p><p>The result is a vector holding <span>$n(n+1)/2$</span> elements, where <span>$n$</span>  is the size of <span>$S$</span>.</p><p><span>$S$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>The inverse operation is provided by <a href="#PosDefManifold.matP"><code>matP</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(3)
Q=randP(3)
G=mean(Fisher, P, Q)
# projecting P at the base point given by the geometric mean of P and Q
S=logMap(Fisher, P, G)
# vectorize S
v=vecP(S)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L1265-L1289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.matP" href="#PosDefManifold.matP"><code>PosDefManifold.matP</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">matP(ς::Vector)</code></pre><p><em>Matrizize</em> a tangent vector (vector) ς :  vec -&gt; mat.</p><p>This is the function reversing the <a href="#PosDefManifold.vecP"><code>vecP</code></a> function,  thus the weighting applied therein is reversed as well.</p><p>If <span>$ς=vecP(S)$</span> and <span>$S$</span> is a <span>$n⋅n$</span> Hermitian matrix,  <span>$ς$</span>  is a tangent vector of size <span>$n(n+1)/2$</span>.  The result of calling <span>$matP(ς)$</span> is then <span>$n⋅n$</span> matrix <span>$S$</span>.</p><p>P.S.: This function needs to be rewritten more efficiently</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(3)
Q=randP(3)
G=mean(Fishr, P, Q)
# projecting P at onto the tangent space at the Fisher mean base point
S=logMap(Fisher, P, G)
# vectorize S
v=vecP(S)
# Rotate the vector by an orthogonal matrix
n=Int(size(S, 1)*(size(S, 1)+1)/2)
U=randP(n)
z=U*v
# Get the point in the tangent space
S=matP(z)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L1293-L1322">source</a></section><h2><a class="nav-anchor" id="Procrustes-problems-1" href="#Procrustes-problems-1">Procrustes problems</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.procrustes" href="#PosDefManifold.procrustes"><code>PosDefManifold.procrustes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">procrustes(P::ℍ, Q::ℍ, extremum=&quot;min&quot;)</code></pre><p>Given two positive definite matrices <span>$P$</span> and <span>$Q$</span>,  return by default the solution of problem</p><p><span>$\textrm{argmin}_Uδ(P,U^*QU)$</span>,</p><p>where <span>$U$</span> varies over the set of unitary matrices <span>$𝐔$</span> and <span>$δ(.,.)$</span> is a  distance or divergence function.  <span>$U^*QU$</span> is named in physics the <em>unitary orbit</em> of <span>$Q$</span>.</p><p>If the argument &#39;extremum&#39; is passed as &quot;max&quot;, it returns instead the solution of</p><p><span>$\textrm{argmax}_Uδ(P,U^*QU)$</span>.</p><p><span>$P$</span> and <span>$Q$</span> must be flagged as <code>Hermitian</code>. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>As it has been shown in Bhatia and Congedo (2019)<a href="../introToRiemannianGeometry/#-1">🎓</a>,  using each of the <a href="../introToRiemannianGeometry/#Fisher-1">Fisher</a>, <a href="../introToRiemannianGeometry/#logdet-zero-1">logdet zero</a>, <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a>  and the Kullback-Leibler divergence (see <a href="../introToRiemannianGeometry/#logdet-α-1">logdet α</a>),  the best approximant to <span>$P$</span> from the unitary orbit of <span>$Q$</span>  commutes with <span>$P$</span> and, surprisingly, has the same closed-form expression, namely</p><p><span>$U_Q^↓U_P^{↓*}$</span> for the argmin and <span>$U_Q^↑U_P^{↓*}$</span> for the argmax,</p><p>where <span>$U^↓$</span> denotes the eigenvector matrix of the subscript argument with  eigenvectors in columns sorted by <em>decreasing</em> order of corresponding eigenvalues and  <span>$U^↑$</span> denotes the eigenvector matrix of the subscript argument with  eigenvectors in columns sorted by <em>increasing</em> order of corresponding eigenvalues.</p><p>The same solutions are known since a long time also by solving the extremal  problem here above using the <a href="../introToRiemannianGeometry/#Euclidean-1">Euclidean</a> metric (Umeyama, 1988).</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(3)
Q=randP(3)
# argmin problem
U=procrustes(P, Q)
# argmax problem
V=procrustes(P, Q, &quot;max&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/900c445fdb432ae0730c9908b6e54c2e253fd7d5/src/riemannianGeometry.jl#L1345-L1387">source</a></section><footer><hr/><a class="previous" href="../linearAlgebra/"><span class="direction">Previous</span><span class="title">linearAlgebra.jl</span></a><a class="next" href="../signalProcessing/"><span class="direction">Next</span><span class="title">signalProcessing.jl</span></a></footer></article></body></html>
