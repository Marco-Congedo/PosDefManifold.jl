<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>linearAlgebra.jl ¬∑ PosDefManifold</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PosDefManifold logo"/></a><h1>PosDefManifold</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifold Documentation</a></li><li><a class="toctext" href="../introToRiemannianGeometry/">Intro to Riemannian Geometry</a></li><li><a class="toctext" href="../MainModule/">MainModule (PosDefManifold.jl)</a></li><li><a class="toctext" href="../riemannianGeometry/">riemannianGeometry.jl</a></li><li class="current"><a class="toctext" href>linearAlgebra.jl</a><ul class="internal"><li><a class="toctext" href="#Matrix-normalizations-1">Matrix normalizations</a></li><li><a class="toctext" href="#Boolean-functions-of-matrices-1">Boolean functions of matrices</a></li><li><a class="toctext" href="#Scalar-functions-of-matrices-1">Scalar functions of matrices</a></li><li><a class="toctext" href="#Diagonal-functions-of-matrices-1">Diagonal functions of matrices</a></li><li><a class="toctext" href="#Unitary-functions-of-matrices-1">Unitary functions of matrices</a></li><li><a class="toctext" href="#Matrix-function-of-matrices-1">Matrix function of matrices</a></li><li><a class="toctext" href="#Spectral-decompositions-of-positive-matrices-1">Spectral decompositions of positive matrices</a></li><li><a class="toctext" href="#Decompositions-involving-triangular-matrices-1">Decompositions involving triangular matrices</a></li></ul></li><li><a class="toctext" href="../signalProcessing/">signalProcessing.jl</a></li><li><a class="toctext" href="../test/">test.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>linearAlgebra.jl</a></li></ul></nav><hr/><div id="topbar"><span>linearAlgebra.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="linearAlgebra.jl-1" href="#linearAlgebra.jl-1">linearAlgebra.jl</a></h1><p>This unit contains linear algebra functions useful in relation to the Riemannian  geometry of the manifold of <em>Symmetric Positive Definite (SPD)</em> or  <em>Hermitian Positive Definite (HPD)</em> matrices. In Julia those are <code>Hermitian</code> matrices, see <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p>In general they take a matrix as input (some may take other arrays as input) and are divided in seven categories depending on what kind of functions thay are and what they give as output:</p><table><tr><th>Category</th><th>Output</th></tr><tr><td>1. <a href="#Matrix-normalizations-1">Matrix normalizations</a></td><td>matrix</td></tr><tr><td>2. <a href="#Boolean-functions-of-matrices-1">Boolean functions of matrices</a></td><td>matrix</td></tr><tr><td>3. <a href="#Scalar-functions-of-matrices-1">Scalar functions of matrices</a></td><td>scalar</td></tr><tr><td>4. <a href="#Diagonal-functions-of-matrices-1">Diagonal functions of matrices</a></td><td>diagonal matrix</td></tr><tr><td>5. <a href="#Unitary-functions-of-matrices-1">Unitary functions of matrices</a></td><td>orthogonal/unitary matrix</td></tr><tr><td>6. <a href="#Matrix-function-of-matrices-1">Matrix function of matrices</a></td><td>matrix</td></tr><tr><td>7. <a href="#Spectral-decompositions-of-positive-matrices-1">Spectral decompositions of positive matrices</a></td><td>spectral function of input</td></tr><tr><td>8. <a href="#Decompositions-involving-triangular-matrices-1">Decompositions involving triangular matrices</a></td><td>triangular matrix</td></tr></table><p>‚ãÖ</p><h2><a class="nav-anchor" id="Matrix-normalizations-1" href="#Matrix-normalizations-1">Matrix normalizations</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.det1"><code>det1</code></a></td><td>Normalize the determinant</td></tr><tr><td><a href="#PosDefManifold.tr1"><code>tr1</code></a></td><td>Normalize the trace</td></tr><tr><td><a href="#PosDefManifold.normalizeCol!"><code>normalizeCol!</code></a></td><td>Normalize one or more columns</td></tr></table><p>‚ãÖ</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.det1" href="#PosDefManifold.det1"><code>PosDefManifold.det1</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">det1!(P::‚Ñç)</code></pre><p>Given a positive definite matrix <span>$P$</span>, return the best approximant to  <span>$P$</span> from the set of matrices in the <a href="https://bit.ly/2W5jDZ6">special linear group</a>,  i.e., the closer matrix having det=1. See Bhatia and Jain (2014)[üéì].</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>,  however a catch-all method is defined.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
P=randP(5) # generate a random real positive definite matrix 5x5
Q=det1(P)
det(Q) # must be 1</code></pre><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.tr1"><code>tr1</code></a>, <a href="https://bit.ly/2Y4MnTF">det</a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.tr1" href="#PosDefManifold.tr1"><code>PosDefManifold.tr1</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tr1(P::‚Ñç)</code></pre><p>Given a positive definite matrix <code>P</code><code>, return the trace-normalized</code><code>P</code>`  (trace=1).</p><p><span>$P$</span> must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>,  however a catch-all method is defined.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
P=randP(5) # generate a random real positive definite matrix 5x5
Q=tr1(P)
tr(Q)  # must be 1</code></pre><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.det1"><code>det1</code></a>, <a href="https://bit.ly/2HoOLiM">tr</a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.normalizeCol!" href="#PosDefManifold.normalizeCol!"><code>PosDefManifold.normalizeCol!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) normalizeCol!(X::Matrix, j::Int)
(2) normalizeCol!(X::Matrix, j::Int, by::Number)
(3) normalizeCol!(X::Matrix, range::UnitRange)
(4) normalizeCol!(X::Matrix, range::UnitRange, by::Number)</code></pre><p>Given a general matrix <span>$X$</span> comprised of real or complex elements,</p><ul><li>(1) normalize the <span>$j^{th}$</span>column</li><li>(2) divide the elements of the <span>$j^{th}$</span> column by number <span>$by$</span></li><li>(3) normalize the columns in <span>$range$</span></li><li>(4) divide the elements of columns in <span>$range$</span>  by number <span>$by$</span>.</li></ul><p><span>$by$</span> is a number of abstract supertype <a href="https://bit.ly/2JwXjGr">Number</a>.  It should be an integer, real or complex number.</p><p><span>$range$</span> is a <a href="https://bit.ly/2HSfK5J">UnitRange</a> type.</p><p>No range check nor type check is performed. A catch-all method is defined.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(10, 20)
normalizeCol!(X, 2)                 # (1) normalize columns 2
normalizeCol!(X, 2, 10.0)           # (2) divide columns 2 by 10.0
normalizeCol!(X, 2:4)               # (3) normalize columns 2 to 4
X=randn(ComplexF64, 10, 20)
normalizeCol!(X, 3)                 # (1) normalize columns 3
normalizeCol!(X, 3:6, (2.0 + 0.5im))# (4) divide columns 3 to 5 by (2.0 + 0.5im)</code></pre><p><strong>See also</strong>: <a href="#PosDefManifold.colNorm"><code>colNorm</code></a>, <a href="https://bit.ly/2TaAkR0">norm</a>, <a href="https://bit.ly/2I1Vgrg">randn</a></p></div></div></section><h2><a class="nav-anchor" id="Boolean-functions-of-matrices-1" href="#Boolean-functions-of-matrices-1">Boolean functions of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.ispos"><code>ispos</code></a></td><td>Check whether the argument is comprised of all positive elements</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.ispos" href="#PosDefManifold.ispos"><code>PosDefManifold.ispos</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) ispos(  Œª::Vector; &lt;tol::Real=minpos, rev::Bool=true,
            bell::Bool=true, msg::String=&quot;&quot;&gt;)
(2) ispos(  Œõ::Diagonal; &lt;tol::Real=minpos, rev::Bool=true,
            bell::Bool=true, msg::String=&quot;&quot;&gt;)</code></pre><p>Return <span>$true$</span> if all numbers in (1) real vector <span>$Œª$</span> or in (2) real diagonal  matrix <span>$Œõ$</span> are not inferior to <span>$tol$</span>, otherwise return <span>$false$</span>. This may be used,  for example, in spectral functions to check that all eigenvalues are positive.  The default value for <span>$tol$</span> is constant <span>$minpos$</span> declared in the main module  <a href="../MainModule/#constants-1">constants</a>.</p><p>The following are <em>&lt;optional keyword arguments&gt;</em>:</p><ul><li>If <span>$rev=true$</span> the (1) elements in <span>$Œª$</span> or (2) the diagonal elements in <span>$Œõ$</span> will be chacked in reverse order.</li></ul><p>This is done for allowing a very fast  check when the elements are sorted where to start checking.</p><p>If the result is <span>$false$</span>:</p><ul><li>if <span>$bell=true$</span> a bell character will be printed. In most systems this will ring a bell on the computer.</li><li>if string <span>$msg$</span> is provided, a warning will print <span>$msg$</span> followed by:</li></ul><p>&quot;at position <em>pos</em>&quot;, where <em>pos</em> is the position where the  first non-positive element has been found.</p><pre><code class="language-none"> ## Examples
 using PosDefManifold
 a=[1, 0, 2, 8];
 ispos(a, msg=&quot;non-positive element found&quot;)

 # it will print:
 # ‚îå Warning: non-positive element found at position 2
 # ‚îî @ [here julie will point to the line of code issuing the warning]</code></pre><pre><code class="language-none"></code></pre></div></div></section><h2><a class="nav-anchor" id="Scalar-functions-of-matrices-1" href="#Scalar-functions-of-matrices-1">Scalar functions of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.colProd"><code>colProd</code></a></td><td>Sum of products of the elements in two columns</td></tr><tr><td><a href="#PosDefManifold.sumOfSqr"><code>sumOfSqr</code></a></td><td>Sum of squares of all elements or of specified columns</td></tr><tr><td><a href="#PosDefManifold.sumOfSqrDiag"><code>sumOfSqrDiag</code></a></td><td>Sum of squares of the diagonal elements</td></tr><tr><td><a href="#PosDefManifold.colNorm"><code>colNorm</code></a></td><td>Eucliden norm of a column</td></tr><tr><td><a href="#PosDefManifold.sumOfSqrTril"><code>sumOfSqrTril</code></a></td><td>Sum of squares of the lower triangle elements up to a given underdiagonal</td></tr><tr><td><a href="#PosDefManifold.fidelity"><code>fidelity</code></a></td><td>(Quantum) Fidelity of two positive matrices</td></tr></table><p>‚ãÖ</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.colProd" href="#PosDefManifold.colProd"><code>PosDefManifold.colProd</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">colProd(X::Matrix, j::Int, l::Int)</code></pre><p>Given a general matrix <span>$X$</span>, comprised of real or complex elements,  return the dot product of the <span>$j^{th}$</span> and <span>$l^{th}$</span> columns, defined as,</p><p><span>$\sum_{i=1}^{r} \big(x_{ij}^*x_{il}\big),$</span></p><p>where <span>$r$</span> is the number of rows of <span>$X$</span> and <span>$^*$</span> the complex conjugate.</p><p>No range check nor type check is performed. A catch-all method is defined.</p><p>Arguments <span>$j$</span> and <span>$l$</span> must be positive integers in range <code>1:size(X, 2)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(10, 20)
p=colProd(X, 1, 3)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.sumOfSqr" href="#PosDefManifold.sumOfSqr"><code>PosDefManifold.sumOfSqr</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) sumOfSqr(A::Array)
(2) sumOfSqr(X::Matrix, j::Int)
(3) sumOfSqr(X::Matrix, range::UnitRange)</code></pre><p>Return</p><ul><li>(1) the sum of square of the elements in an array <span>$A$</span> of any dimensions.</li><li>(2) the sum of square of the <span>$j^{th}$</span> column of a matrix <span>$X$</span>.</li><li>(3) the sum of square of the columns of <span>$X$</span> in a given range.</li></ul><p>No range check nor type check is performed. A catch-all method is defined.</p><p>Note that only (1) works for arrays of any dimensions and that  if <span>$A$</span> is a matrix (1) returns the square of the <a href="https://bit.ly/2Fi10eH">Frobenius norm</a>:  <span>$\sum |a_{ij}|^2.$</span></p><p><strong>Arguments</strong></p><p>(1)  <code>(A)</code>:</p><ul><li><span>$A$</span> is an array of any dimensions (e.g., a vector, matrix or tensor), real or complex.</li></ul><p>(2) <code>(X, j)</code>:</p><ul><li><span>$X$</span> is a generic matrix, real or complex;</li><li><span>$j$</span> is a positive integer in range <code>1:size(X, 2)</code>.</li></ul><p>(3) <code>(X, range)</code>:</p><ul><li><span>$X$</span> is a generic matrix, real or complex;;</li><li><span>$range$</span> is a <a href="https://bit.ly/2HDoFbk">UnitRange type</a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(10, 20)
sum¬≤=sumOfSqr(X)        # (1) sum of squares of all elements
sum¬≤=sumOfSqr(X, 1)     # (2) sum of squares of elements in column 1
sum¬≤=sumOfSqr(X, 2:4)   # (3) sum of squares of elements in column 2 to 4</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.sumOfSqrDiag" href="#PosDefManifold.sumOfSqrDiag"><code>PosDefManifold.sumOfSqrDiag</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(1) sumOfSqrDiag(X::Matrix)
(2) sumOfSqrDiag(D::Diagonal)</code></pre><p>Return (1) the sum of squares of the diagonal elements in general matrix <span>$X$</span>  comprised of real or complex numbers.  If <span>$X$</span> is rectangular, the main diagonal is considered.</p><p>It also return (2) the sum of squares of real diagonal matrix <span>$Œõ$</span>.</p><p>No range check nor type check is performed. A catch-all method is defined.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
X=randn(10, 20)
sumDiag¬≤=sumOfSqrDiag(X) # (1)
sumDiag¬≤=sumOfSqrDiag(Diagonal(X)) # (2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.colNorm" href="#PosDefManifold.colNorm"><code>PosDefManifold.colNorm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">colNorm(X::Matrix, j::Int)</code></pre><p>Return the Euclidean norm of the <span>$j^{th}$</span> column of general matrix <span>$X$</span>.  No range check nor type check is performed. A catch-all method is defined.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(10, 20)
normOfSecondColumn=colNorm(X, 2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.sumOfSqrTril" href="#PosDefManifold.sumOfSqrTril"><code>PosDefManifold.sumOfSqrTril</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sumOfSqrTril(X::Matrix, k::Int=0)</code></pre><p>Given a general matrix <span>$X$</span>, return the sum of squares of the elements  in the lower triangle <span>$X$</span> up to the <span>$k^{th}$</span> underdiagonal.</p><p><span>$X$</span> may be rectangular. <span>$k$</span> must be in range <code>1-size(X, 1):0</code>.</p><p>See julia <a href="https://bit.ly/2Tbx8o7">tril(M, k::Integer)</a> function  for numbering of diagonals.   No range check nor type check is performed. A catch-all method is defined.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
A=[4. 3.; 2. 5.; 1. 2.]
#3√ó2 Array{Float64,2}:
# 4.0  3.0
# 2.0  5.0
# 1.0  2.0

s=sumOfSqrTril(A, -1)
# 9.0 = 1¬≤+2¬≤+2¬≤

s=sumOfSqrTril(A, 0)
# 50.0 = 1¬≤+2¬≤+2¬≤+4¬≤+5¬≤</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.fidelity" href="#PosDefManifold.fidelity"><code>PosDefManifold.fidelity</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fidelity(P::‚Ñç, Q::‚Ñç)</code></pre><p>Given two positive definte matrices <span>$P$</span> and <span>$Q$</span>, return their <em>fidelity</em>:</p><p><span>$tr\big(P^{1/2}QP^{1/2}\big)^{1/2}.$</span></p><p>This is used in quantum physics and is related to the  <a href="../introToRiemannianGeometry/#Wasserstein-1">Wasserstein</a> metric. See for example Bhatia, Jain and Lim (2019b)<a href="../introToRiemannianGeometry/#-1">üéì</a>.</p><p><span>$P$</span> and <span>$Q$</span> must be flagged as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>,  however a catch-all method is defined.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5);
Q=randP(5);
f=fidelity(P, Q)</code></pre><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a></p></div></div></section><h2><a class="nav-anchor" id="Diagonal-functions-of-matrices-1" href="#Diagonal-functions-of-matrices-1">Diagonal functions of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.fDiagonal"><code>fDiagonal</code></a></td><td>Elemen-wise functions of matrix diagonals</td></tr></table><p>‚ãÖ</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.fDiagonal" href="#PosDefManifold.fDiagonal"><code>PosDefManifold.fDiagonal</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fDiagonal(X::Matrix, func::Function, k::Int=0)</code></pre><p>Applies function <code>func</code> element-wise to the elements of the <span>$k^{th}$</span> diagonal  of generic matrix <span>$X$</span> (real or complex) of dimension <em>r‚ãÖc</em>  and return a diagonal matrix with these elements.  Note that the dimension of the result depends on the size of <span>$X$</span>  and the chosen diagonal.</p><p>For example,</p><ul><li><em>r ‚â† c</em> and <span>$k$</span>=0 (main diagonal), the result will be of dimension min<em>(r,c)</em>‚ãÖ<em>min(r,c)</em>,</li><li><span>$X$</span> <em>3‚ãÖ4</em> and <span>$k=-1$</span>, the result will be <em>2‚ãÖ2</em>,</li><li><span>$X$</span> <em>3‚ãÖ4</em> and <span>$k=1$</span>, the result will be <em>3‚ãÖ3</em>, etc.</li></ul><p>See julia <a href="https://bit.ly/2Tbx8o7">tril(M, k::Integer)</a> function  for numbering of diagonals.</p><p><strong>Arguments</strong> <code>(X, func, k)</code></p><ul><li><span>$X$</span> is a generic matrix of real or complex elements;</li><li><code>func</code> is a function;</li><li><span>$k$</span> is the chosen diagonal (by default <code>k</code>=0, which is the main diagonal).</li></ul><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The function <code>func</code> must support the <code>func.</code> syntax and therefore must be able to apply element-wise to the elements of the chosen diagonal (this includes anonymous functions). If <code>X</code> is complex, the function <code>func</code> must be able to support complex arguments.</p></div></div><p>A catch-all method is defined.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5) # use P=randP(ComplexF64, 5) for generating an Hermitian matrix
(Œõ, U) = evd(P)         # Œõ holds the eigenvalues of P, see evd
Œî=fDiagonal(Œõ, log)     # diagonal matrix with the log of the eigenvalues
Œî=fDiagonal(Œõ, x-&gt;x^2)  # using an anonymous function for the square of the eigenvalues</code></pre></div></div></section><h2><a class="nav-anchor" id="Unitary-functions-of-matrices-1" href="#Unitary-functions-of-matrices-1">Unitary functions of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.mgs"><code>mgs</code></a></td><td>Modified Gram-Schmidt orthogonalization</td></tr></table><p>‚ãÖ</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.mgs" href="#PosDefManifold.mgs"><code>PosDefManifold.mgs</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mgs(T::Matrix, numCol::Int=0)</code></pre><p>Modified (stabilized) <a href="https://bit.ly/2YE6zvy">Gram-Schmidt orthogonalization</a>  of the columns of square or tall matrix <span>$T$</span>, which can be comprised of real  or complex elements.  The orthogonalized <span>$T$</span> is returned by the function.</p><p><span>$T$</span> is not changed.</p><p>All columns are orthogonalized by default. If instead argument <code>numCol</code> is provided,  then only the first <code>numCol</code> columns of <span>$T$</span> are orthogonalized.  In this case only the firt `numCol columns will be returned.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
X=randn(10, 10);
U=mgs(X)        # result is 10‚ãÖ10
U=mgs(X, 3)     # result is 10‚ãÖ3
U&#39;*U ‚âà I ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)
# julia undertands also:
U&#39;U ‚âà I ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)</code></pre></div></div></section><h2><a class="nav-anchor" id="Matrix-function-of-matrices-1" href="#Matrix-function-of-matrices-1">Matrix function of matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td>none for now</td><td>ipse lorem...</td></tr></table><p>‚ãÖ</p><h2><a class="nav-anchor" id="Spectral-decompositions-of-positive-matrices-1" href="#Spectral-decompositions-of-positive-matrices-1">Spectral decompositions of positive matrices</a></h2><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="#PosDefManifold.evd"><code>evd</code></a></td><td>Eigenvalue-Eigenvector decomposition of a matrix in <span>$UŒõU&#39;=P$</span> form</td></tr><tr><td><a href="#PosDefManifold.spectralFunctions"><code>spectralFunctions</code></a></td><td>Mother function for creating spectral functions of eigenvalues</td></tr><tr><td><a href="#PosDefManifold.pow"><code>pow</code></a></td><td>Power of a positive matrix for any number of exponents in one pass</td></tr><tr><td><a href="#PosDefManifold.invsqrt"><code>invsqrt</code></a></td><td>Principal square root inverse (whitening) of a positive matrix</td></tr><tr><td><a href="#PosDefManifold.sqr"><code>sqr</code></a></td><td>Square of a positive matrix</td></tr><tr><td><a href="#PosDefManifold.powerIterations"><code>powerIterations</code></a>, <code>powIter</code></td><td>Power method for estimating any number of eigenvectors and associated eigenvalues</td></tr><tr><td><a href="#PosDefManifold.choL"><code>choL</code></a></td><td>Lower triangula factor of Cholesky decomposition</td></tr></table><p>‚ãÖ</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.evd" href="#PosDefManifold.evd"><code>PosDefManifold.evd</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">evd(S::‚Ñç)</code></pre><p>Given a positive semi-definite matrix <span>$S$</span>,  returns a 2-tuple <span>$(Œõ, U)$</span>, where <span>$U$</span> is the matrix holding in columns  the eigenvectors and <span>$Œõ$</span> is the matrix holding the eigenvalues on the diagonal.  This is the output of Julia <code>eigen</code> function in <span>$UŒõU&#39;=S$</span> form.</p><p>As for the <code>eigen</code> function, the eigenvalues and associated  eigenvectors are sorted by increasing values of eigenvalues.</p><p><span>$S$</span> must be flagged by julia as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a> and <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
A=randn(3, 3);
S=‚Ñç(A+A&#39;);
Œõ, U=evd(S); # which is equivalent to (Œõ, U)=evd(P)
(U*Œõ*U&#39;) ‚âà S ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)
# =&gt; UŒõU&#39;=S, UŒõ=SU, ŒõU&#39;=U&#39;S</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.spectralFunctions" href="#PosDefManifold.spectralFunctions"><code>PosDefManifold.spectralFunctions</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">spectralFunctions(P::‚Ñç, func)</code></pre><p>This is the <em>mother function</em> for all spectral functions of eigenvalues implemented  in this library, which are:</p><ul><li><code>pow</code>     (power),</li><li><code>isqrt</code>   (inverse square root).</li></ul><p>The function <code>sqr</code> (square) does not use it, as it can be obtained more  efficiently by simple multiplication.</p><p>You can use this function if you need another spectral function of eigenvalues  besides those and those already implemented in the standard package <code>LinearAlgebra</code>.  In general, you won&#39;t call it directly.</p><p>The definition of spectral functions for a positive definite matrix <span>$P$</span>  is at it follows:</p><p><span>$f\big(P\big)=Uf\big(Œõ\big)U&#39;,$</span></p><p>where <span>$U$</span> is the matrix holding in columns the eigenvectors of <span>$P$</span>,  <span>$Œõ$</span> is the matrix holding on diagonal its eigenvalues and <span>$f$</span> is  a function applying element-wise to the eigenvalues.</p><p><strong>Arguments</strong> <code>(P, func)</code>;</p><ul><li><span>$P$</span> is a positive matrix.</li><li>`func is the function that will be applied on the eigenvalues</li></ul><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The function <code>func</code> must support the <code>func.</code> syntax and therefore must be able to apply element-wise to the eigenvalues (those include anonymous functions).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
n=5
P=randP(n) # P=randP(ComplexF64, 5) to generate an Hermitian complex matrix
noise=0.1;
Q=spectralFunctions(P, x-&gt;x+noise) # add white noise to the eigenvalues
tr(Q)-tr(P) ‚âà noise*n ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)</code></pre><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.evd"><code>evd</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.pow" href="#PosDefManifold.pow"><code>PosDefManifold.pow</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pow(P::‚Ñç, p)        # one argument
pow(P::‚Ñç, args...)  # several arguments</code></pre><p>Given a positive definite matrix <span>$P$</span>, return the power  <span>$P^{r_1}, P^{r_2},...$</span>  for any number of exponents <span>$r_1, r_2,...$</span>.  It returns a tuple of as many elements as arguments passed after <span>$P$</span>.</p><p><strong>Arguments</strong> <code>(P, arg1, arg2,...)</code></p><ul><li><span>$P$</span> is a positive matrix.</li><li><span>$arg1, arg2,...$</span> are real numbers.</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
P=randP(5);     # use P=randP(ComplexF64, 5) for generating an Hermitian matrix
Q=pow(P, 0.5);            # =&gt;  QQ=P
Q, W=pow(P, 0.5, -0.5);
W*P*W ‚âà I ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)
Q*Q ‚âà P ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)
R, S=pow(P, 0.3, 0.7);
R*S ‚âà P ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)</code></pre><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.invsqrt"><code>invsqrt</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.invsqrt" href="#PosDefManifold.invsqrt"><code>PosDefManifold.invsqrt</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">invsqrt(P::‚Ñç)</code></pre><p>Given a positive definite matrix <span>$P$</span>, compute the inverse of the principal  square root <span>$P^{-1/2}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
P=randP(ComplexF64, 5);
Q=invsqrt(P);
Q*P*Q ‚âà I ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)</code></pre><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>See also</strong>: <a href="#PosDefManifold.pow"><code>pow</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.sqr" href="#PosDefManifold.sqr"><code>PosDefManifold.sqr</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sqr(P::‚Ñç)</code></pre><p>Given a positive definite matrix <span>$P$</span>, compute its square <span>$P^{2}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5);
P¬≤=sqr(P);  # =&gt;  P¬≤=PP
sqrt(P¬≤)‚âà P ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)</code></pre><p><strong>See</strong>: <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.powerIterations" href="#PosDefManifold.powerIterations"><code>PosDefManifold.powerIterations</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">powerIterations(S::‚Ñç, q;
        &lt;evalues=false, tol=1e-9, maxiter=300, ‚ç∞=false&gt;)</code></pre><p><strong>alias</strong>: <code>powIter</code></p><p>Compute the <span>$q$</span> eigenvectors associated to the <span>$q$</span> largest (real) eigenvalues  of matrix <span>$S$</span> using the <a href="https://bit.ly/2JSo0pb">power iterations</a> +  <a href="https://bit.ly/2YE6zvy">Gram-Schmidt orthogonalization</a> as suggested by Strang.</p><p><span>$S$</span> must be flagged by julia as Hermitian.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>Differently from the <a href="#PosDefManifold.evd"><code>evd</code></a> function, the eigenvectors and eigenvalues are sorted by decreasing order of eigenvalues.</p></div></div><p><strong>Arguments</strong> <code>(S, q; evalues=false, tol=1e-9, maxiter=300, ‚ç∞=false)</code>:</p><ul><li><span>$S$</span> is an Hermitian matrix (real, complex, positive definite or not).</li><li><span>$q$</span> is the number of eigenvectors to be found (thus the number of columns of the output).</li></ul><p>The following are <em>&lt;optional keyword arguments&gt;</em>:</p><ul><li><span>$tol$</span> is the tolerance for the convergence of the power method.</li><li><span>$maxiter$</span> is the maximum number of iterations allowed for the power method</li><li>if <span>$‚ç∞=true$</span>, the convergence of all iterations will be printed.</li><li>if <span>$evalues=true$</span>, return the 4-tuple <span>$(Œõ, U, iterations, covergence)$</span></li><li>if <span>$evalues=false$</span> return the 3-tuple <span>$(U, iterations, covergence)$</span></li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using LinearAlgebra, PosDefManifold
S=randP(10);
# all eigenvectors
U, iterations, covergence=powIter(S, size(P, 2), ‚ç∞=true)
# 3 eigenvectors and eigenvalues
Œõ, U, iterations, covergence=powIter(S, 3, evalues=true);
U&#39;*U‚âà I ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)</code></pre><p><strong>See also</strong>: <a href="#PosDefManifold.mgs"><code>mgs</code></a></p></div></div></section><h2><a class="nav-anchor" id="Decompositions-involving-triangular-matrices-1" href="#Decompositions-involving-triangular-matrices-1">Decompositions involving triangular matrices</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.choL" href="#PosDefManifold.choL"><code>PosDefManifold.choL</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">choL(P::‚Ñç)
choL(P::Matrix)</code></pre><p>Given a positive matrix <span>$P$</span>, return the <em>Cholesky lower triangular factor</em> <span>$L$</span>  such that <span>$LL&#39;=P$</span>. To obtain <span>$L&#39;$</span> or both <span>$L$</span> and <span>$L&#39;$</span>, use instead  julia function <a href="https://bit.ly/2u9Hw5P">cholesky(P)</a>.</p><p><span>$P$</span> sould be flagged as <code>Hermitian</code> - see  <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a> - but a method for generic matrices  is also provided.</p><p>On output, <span>$L$</span> is of type <a href="https://bit.ly/2U511f3"><code>LowerTriangular</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(5);
L=choL(P);
L*L&#39;‚âà P ? println(&quot; ‚≠ê &quot;) : println(&quot; ‚õî &quot;)</code></pre></div></div></section><footer><hr/><a class="previous" href="../riemannianGeometry/"><span class="direction">Previous</span><span class="title">riemannianGeometry.jl</span></a><a class="next" href="../signalProcessing/"><span class="direction">Next</span><span class="title">signalProcessing.jl</span></a></footer></article></body></html>
