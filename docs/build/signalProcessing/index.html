<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>signalProcessing.jl · PosDefManifold</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PosDefManifold logo"/></a><h1>PosDefManifold</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../MainModule/">MainModule (PosDefManifold.jl)</a></li><li><a class="toctext" href="../">PosDefManifold Documentation</a></li><li><a class="toctext" href="../introToRiemannianGeometry/">Intro to Riemannian Geometry</a></li><li><a class="toctext" href="../linearAlgebra/">linearAlgebra.jl</a></li><li><a class="toctext" href="../riemannianGeometry/">riemannianGeometry.jl</a></li><li class="current"><a class="toctext" href>signalProcessing.jl</a><ul class="internal"></ul></li><li><a class="toctext" href="../statistics/">statistics.jl</a></li><li><a class="toctext" href="../test/">test.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>signalProcessing.jl</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/master/docs/src/signalProcessing.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>signalProcessing.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="signalProcessing.jl-1" href="#signalProcessing.jl-1">signalProcessing.jl</a></h1><p>This unit contains miscellaneous signal processing functions useful in relation to the Riemannian geometry of the manifold of <em>Symmetric Positive Definite (SPD)</em> or <em>Hermitian Positive Definite (HPD)</em> matrices. In Julia those are <code>Hermitian</code> matrices, see <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifold.randChi²"><code>randChi²</code></a>, randχ²</td><td style="text-align: left">Generate a random variable distributed as a chi-squared</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.randEigvals"><code>randEigvals</code></a>, <code>randλ</code></td><td style="text-align: left">Generate a random vectors of real positive eigenvalues</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.randEigvalsMat"><code>randEigvalsMat</code></a>, <code>randΛ</code></td><td style="text-align: left">Generate a random diagonal matrix of real positive eigenvalues</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.randUnitaryMat"><code>randUnitaryMat</code></a>, <code>randU</code></td><td style="text-align: left">Generate a random orthogonal or unitary matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.randPosDefMat"><code>randPosDefMat</code></a>, <code>randP</code></td><td style="text-align: left">Generate one or an array of random positive definite matrices</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.regularize!"><code>regularize!</code></a></td><td style="text-align: left">Regularize an array of positive definite matrices</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.gram"><code>gram</code></a></td><td style="text-align: left">Gram matrix of a matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.trade"><code>trade</code></a></td><td style="text-align: left">trace and determinant of a matrix as a 2-tuple</td></tr></table><p>⋅</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.randChi²" href="#PosDefManifold.randChi²"><code>PosDefManifold.randChi²</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">randChi²(df::Int)</code></pre><p><strong>alias</strong>: <code>randχ²</code></p><p>Generate a random variable distributed as a <em>chi-squared</em> with <code>df</code>  degrees of freedom.</p><p>It uses the <em>Wilson–Hilferty transformation</em> for <code>df</code>&gt;=20 -  see <a href="https://en.wikipedia.org/wiki/Chi-squared_distribution">chi-squared distribution</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using Plots, PosDefManifold
chi=[randχ²(2) for i=1:10000]
histogram(chi) # needs Plots package. Check your plots back-end.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/f27e675edc312b7b8b19ec8ba26c749419279589/src/signalProcessing.jl#L14-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.randEigvals" href="#PosDefManifold.randEigvals"><code>PosDefManifold.randEigvals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">    randEigvals(n::Int;
    &lt;
    df::Int=2,
    eigvalsSNR::Real=10e3 &gt;)</code></pre><p><strong>alias</strong>: <code>randλ</code></p><p>Generate an <span>$n$</span>-vector of random real positive eigenvalues.  The eigenvalues are generated as in function <code>randΛ</code>(<a href="#PosDefManifold.randEigvalsMat"><code>randEigvalsMat</code></a>),  the syntax of which is used.</p><p><strong>See also</strong>: <code>randU</code> (<a href="#PosDefManifold.randUnitaryMat"><code>randUnitaryMat</code></a>), <code>randP</code> (<a href="#PosDefManifold.randPosDefMat"><code>randPosDefMat</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-none">using Plots, PosDefManifold
λ=sort(randλ(10), rev=true)
σ=sort(randλ(10, eigvalsSNR=10), rev=true)
plot(λ) # needs Plots package. Check your plots back-end.
plot!(σ) # needs Plots package. Check your plots back-end.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/f27e675edc312b7b8b19ec8ba26c749419279589/src/signalProcessing.jl#L35-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.randEigvalsMat" href="#PosDefManifold.randEigvalsMat"><code>PosDefManifold.randEigvalsMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">    (1) randEigvalsMat(n::Int;
    &lt;
    df::Int=2,
    eigvalsSNR::Real=10e3 &gt;)

    (2) randEigvalsMat(n::Int, k::Int;
    &lt; same keyword arguments as in (1) &gt;)</code></pre><p><strong>alias</strong>: <code>randΛ</code></p><p>(1) Generate an <span>$n⋅n$</span> diagonal matrix of random real positive eigenvalues.  (2) An array 1d (of <a href="../MainModule/#𝔻Vector-type-1">𝔻Vector type</a>) of <span>$k$</span> matrices of the kind in (1)</p><p>The eigenvalues are generated according to model</p><p><span>$λ_i=χ_{df}^2+η,\hspace{6pt}\textrm{for}\hspace{2pt}i=1:n,$</span></p><p>where</p><ul><li><span>$χ_{df}^2$</span> (signal term) is randomly distributed as a <a href="https://bit.ly/1IXkulE">chi-square</a> with <code>df</code> degrees of freedom,</li><li><span>$η$</span> is a <a href="https://bit.ly/2TN8472">white noise</a> term, function of <em>&lt;keyword argument&gt;</em> <code>eigvalsSNR</code>, such that</li></ul><p><span>$\textrm{eigenvalues SNR}=\mathbb{E}\big(\sum_{i=1}^{n}λ_i\big)\big/nη.$</span></p><p>The expected sum <span>$\mathbb{E}\big(\sum_{i=1}^{n}λ_i\big)$</span> here above is the  expected variance of the signal term, i.e., <span>$n(df)$</span>, since the expectation  of a random chi-squared variable is equal to its degrees of freedom.</p><p>If <code>eigvalsSNR=Inf</code> is passed as argument, then <span>$η$</span> is set to zero, <em>i.e.</em>,  no white noise is added. In any case <code>eigvalsSNR</code> must be positive.</p><p>Note that with the default value of <em>&lt;keyword argument&gt;</em> <code>df</code> (<code>df=2</code>)  the generating model assumes that the eigenvalues  have exponentially decaying variance, which is often observed on real data.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The <em>&lt;keyword argument&gt;</em> <code>eigvalsSNR</code> expresses the expected eigenvalues SNR (<a href="https://bit.ly/1VvpvnQ">signal-to-noise ratio</a>), not the real one, and is not expressed in decibels, but as the expected SNR variance ratio.</p></div></div><p>This function is used by function <code>randP</code> (<a href="#PosDefManifold.randPosDefMat"><code>randPosDefMat</code></a>) to generate  random positive definite matrices with added white noise in order  to emulate eigenvalues observed in real data and to  improve the conditioning of the generated matrices with respect to inversion.</p><p><strong>See also</strong>: <code>randλ</code> (<a href="#PosDefManifold.randEigvals"><code>randEigvals</code></a>), <code>randU</code> (<a href="#PosDefManifold.randUnitaryMat"><code>randUnitaryMat</code></a>),  <code>randP</code> (<a href="#PosDefManifold.randPosDefMat"><code>randPosDefMat</code></a>), <code>randχ²</code> (<a href="#PosDefManifold.randChi²"><code>randChi²</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
# (1)
n=3;
U=randU(n);
Λ=randΛ(n, eigvalsSNR=100)
P=U*Λ*U&#39; # generate an SPD matrix
using LinearAlgebra
Q=ℍ(U*Λ*U&#39;) # generate an SPD matrix and flag it as &#39;Hermitian&#39;

# (2) generate an array of 10 matrices of simulated eigenvalues
Dvec=randΛ(n, 10)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/f27e675edc312b7b8b19ec8ba26c749419279589/src/signalProcessing.jl#L66-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.randUnitaryMat" href="#PosDefManifold.randUnitaryMat"><code>PosDefManifold.randUnitaryMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1) randUnitaryMat(n::Int)
(2) randUnitaryMat(::Type{Complex{T}}, n::Int)</code></pre><p><strong>aliases</strong>: <code>randOrthMat</code>, <code>randU</code></p><p>Generate a random <span>$n⋅n$</span></p><ul><li>(1) <a href="https://bit.ly/2vrr0wU">orthogonal</a> matrix (real)</li><li>(2) <a href="https://bit.ly/2JCHbmC">unitary</a> matrix (complex)</li></ul><p>The matrices are generated running the modified (stabilized)  <a href="https://bit.ly/2YE6zvy">Gram-Schmidt orthogonalization</a>  procedure (<a href="../linearAlgebra/#PosDefManifold.mgs"><code>mgs</code></a>) on an <span>$n⋅n$</span> matrix filled with random Gaussian elements.</p><p><strong>See also</strong>: <code>randΛ</code> (<a href="#PosDefManifold.randEigvals"><code>randEigvals</code></a>), <code>randP</code> (<a href="#PosDefManifold.randPosDefMat"><code>randPosDefMat</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
n=3;
X=randU(n)*sqrt(randΛ(n))*randU(n)&#39;  # (1) generate a random square real matrix

U=randU(ComplexF64, n);
V=randU(ComplexF64, n);
Y=U*sqrt(randΛ(n))*V&#39; # (2) generate a random square complex matrix</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/f27e675edc312b7b8b19ec8ba26c749419279589/src/signalProcessing.jl#L144-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.randPosDefMat" href="#PosDefManifold.randPosDefMat"><code>PosDefManifold.randPosDefMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">    (1) randPosDefMat(n::Int;
    &lt;
    df::Int=2,
    eigvalsSNR::Real=10e3 &gt;)

    (2) randPosDefMat(::Type{Complex{T}}, n:: Int;
    &lt; same keyword arguments as in (1) &gt;)

    (3) randPosDefMat(n::Int, k::Int;
    &lt;
    df::Int=2,
    eigvalsSNR::Real=10e3,
    SNR::Real=100,
    commuting=false &gt;)

    (4) randPosDefMat(::Type{Complex{T}}, n::Int, k::Int;
    &lt; same keyword arguments as in (3) &gt;)</code></pre><p><strong>alias</strong>: <code>randP</code></p><p>Generate</p><ul><li>(1) one random <code>Hermitian</code> positive definite matrix (real) of size <span>$n⋅n$</span></li><li>(2) one random <code>Hermitian</code> positive definite matrix (complex) of size <span>$n⋅n$</span></li><li>(3) an array 1d (of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a>) of <span>$k$</span> matrices of the kind in (1)</li><li>(4) an array 1d (of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a>) of <span>$k$</span> matrices of the kind in (2).</li></ul><p>Methods (3) and (4) are <strong>multi-threaded</strong>. See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>For (1) and (2) the matrix is generated according to model</p><p><span>$UΛU^H+ηI$</span>,</p><p>where <span>$U$</span> is a random orthogonal (1) or unitary (2) matrix generated by  function <code>randU</code>(<a href="#PosDefManifold.randUnitaryMat"><code>randUnitaryMat</code></a>) and <span>$Λ$</span>, <span>$η$</span> are a positive definite  diagonal matrix and a non-negative scalar depending on <em>&lt;optional keywords arguments&gt;</em>  <code>df</code> and <code>eigvalsSNR</code> randomly generated calling function  <code>randΛ</code>(<a href="#PosDefManifold.randEigvalsMat"><code>randEigvalsMat</code></a>).</p><p>For (3) and (4), if the <em>&lt;optional keyword argument&gt;</em> <code>commuting=true</code> is passed,  the <span>$k$</span> matrices are generated according to model</p><p><span>$UΛ_iU^H+ηI,\hspace{8pt}$</span>, for <span>$i$</span>=1:<span>$k$</span></p><p>otherwise they are generated accrding to model</p><p><span>$(UΛ_iU^H+ηI)+φ(V_iΔ_iV_i^H+ηI),\hspace{8pt}$</span>, for <span>$i$</span>=1:<span>$k$</span>  Eq.[1]</p><p>where</p><ul><li><span>$U$</span> and the <span>$V_i$</span> are random (3) orthogonal/(4) unitary matrices,</li><li><span>$Λ_i$</span> and <span>$Δ_i$</span> are positive definite diagonal matrices</li><li><span>$η$</span> is a non-negative scalar.</li></ul><p>All variables here above are randomly generated as in (1) and (2)</p><ul><li><span>$φ$</span> is adjusted so as to obtain a desired output <code>SNR</code> (<a href="https://bit.ly/1VvpvnQ">signal-to-noise ratio</a>), which is also an</li></ul><p><em>&lt;optional keywords arguments&gt;</em>, such as</p><p><span>$SNR=\frac{\displaystyle\sum_{i=1}^{k}\textrm{tr}(UΛ_iU^H+ηI)}{\displaystyle\sum_{i=1}^{k}\textrm{tr}φ(V_iΔ_iV_i^H+ηI)}$</span>.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The keyword arguments <code>SNR</code> is not expressed in decibels, but as the expected SNR variance ratio. It must be a positive number.</p></div></div><p>A slightly different version of this model for generating positive definite  matrices has been proposed in (Congedo et <em>al.</em>, 2017b)[🎓];  in the model of Eq. [1]</p><ul><li><span>$UΛ_iU^H$</span> is the signal term, where the signal is supposed sharing the same coordinates for all matrices,</li><li><span>$φ(V_iΔ_iV_i^H)$</span> is a structured noise term, which is different for all matrices</li><li><span>$ηI$</span> is a <a href="https://bit.ly/2TN8472">white noise</a> term, with same variance for all matrices.</li></ul><p><strong>See also</strong>: the aforementioned paper and <code>randΛ</code> (<a href="#PosDefManifold.randEigvalsMat"><code>randEigvalsMat</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
R=randP(10, df=10, eigvalsSNR=1000) # 1 SDP Matrix of size 10x10 #(1)
H=randP(ComplexF64, 5, eigvalsSNR=10) # 1 Hermitian Matrix of size 5x5 # (2)
ℛ=randP(10, 1000, eigvalsSNR=100) # 1000 SPD Matrices of size 10x10 # (3)
using Plots
heatmap(Matrix(ℛ[1]), yflip=true, c=:bluesreds)
ℋ=randP(ComplexF64, 20, 1000) # 1000 Hermitian Matrices of size 20x20 # (4)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/f27e675edc312b7b8b19ec8ba26c749419279589/src/signalProcessing.jl#L179-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.regularize!" href="#PosDefManifold.regularize!"><code>PosDefManifold.regularize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1) regularize!(P::ℍ; &lt;SNR=10e3&gt;)
(2) regularize!(𝐏::ℍVector; &lt;SNR=10e3&gt;)</code></pre><p>Add <a href="https://bit.ly/2TN8472">white noise</a> to either</p><ul><li>(1) a positive definite matrix <span>$P$</span> of size <span>$n⋅n$</span>, or</li><li>(2) a 1d array <span>$𝐏$</span> of <span>$k$</span> positive definite matrices of size <span>$n⋅n$</span>, of <a href="../MainModule/#ℍVector-type-1">ℍVector type</a>.</li></ul><p>The added noise improves the matrix conditioning with respect to inversion.  This is used to avoid numerical errors when decomposing these matrices  or when evaluating some functions of their eigevalues such as the log.</p><p>A constant value is added to all diagonal elements of (1) <span>$P$</span>  or (2) af all matrices in <span>$𝐏$</span>,  that is, on output:</p><p><span>$\textrm{(1)}\hspace{2pt}P\leftarrow P+ηI$</span></p><p><span>$\textrm{(2)}\hspace{2pt}𝐏_i\leftarrow 𝐏_i+ηI, \hspace{2pt}\textrm{for}\hspace{2pt} i=1:k.$</span></p><p>The amount of added noise <span>$η$</span> is determined by the <code>SNR</code>  <em>&lt;keyword argument&gt;</em>, which by default is 10000. This is  such that</p><p><span>$\textrm{(1)}\hspace{2pt}SNR=\frac{\displaystyle\textrm{tr}(P)}{\displaystyle\textrm{tr}(ηI)}.$</span></p><p><span>$\textrm{(2)}\hspace{2pt}SNR=\frac{\displaystyle\sum_{i=1}^{k}\textrm{tr}(𝐏_i)}{\displaystyle k\hspace{1pt}\textrm{tr}(ηI)}.$</span></p><p><span>$P$</span> in (1) must be flagged as Hermitian. See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>The keyword argument <code>SNR</code> expresses a SNR (<a href="https://bit.ly/1VvpvnQ">signal-to-noise ratio</a>), and is not expressed in decibels,  but as the SNR variance ratio. It must be a positive number. Differently from function <code>randΛ</code><a href="#PosDefManifold.randEigvalsMat"><code>randEigvalsMat</code></a>, <code>randλ</code><a href="#PosDefManifold.randEigvals"><code>randEigvals</code></a> and <code>randP</code><a href="#PosDefManifold.randPosDefMat"><code>randPosDefMat</code></a>, the SNR here is not the expected SNR, but the actual SNR.</p></div></div><p><strong>See also</strong>: <code>randP</code> (<a href="#PosDefManifold.randPosDefMat"><code>randPosDefMat</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-none"># (1)
using LinearAlgebra, Plots, PosDefManifold
n=3
U=randU(n)
# in Q we will write two matrices,
# the unregularized and regularized matrix side by side
Q=Matrix{Float64}(undef, n, n*2)
P=ℍ(U*Diagonal(randn(n).^2)*U&#39;) # generate a real 3x3 positive matrix
for i=1:n, j=1:n Q[i, j]=P[i, j] end
regularize!(P, SNR=5)
for i=1:n, j=1:n Q[i, j+n]=P[i, j] end # the regularized matrix is on the right
heatmap(Matrix(Q), yflip=true, c=:bluesreds)

# (2)
𝐏=[ℍ(U*Diagonal(randn(3).^2)*U&#39;) for i=1:5] # 5 real 3x3 positive matrices
regularize!(𝐏, SNR=1000)</code></pre><p><strong>Run a test</strong></p><pre><code class="language-none">using LinearAlgebra
𝐏=randP(10, 100, SNR=1000); # 100 real Hermitian matrices
signalVar=sum(tr(P) for P in 𝐏);
regularize!(𝐏, SNR=1000);
signalPlusNoiseVar=sum(tr(P) for P in 𝐏);
output_snr=signalVar/(signalPlusNoiseVar-signalVar)
# output_snr should be approx. equal to 1000</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/f27e675edc312b7b8b19ec8ba26c749419279589/src/signalProcessing.jl#L317-L384">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.gram" href="#PosDefManifold.gram"><code>PosDefManifold.gram</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gram(X::Matrix{T}) where T&lt;:RealOrComplex</code></pre><p>Given a generic data matrix <span>$X$</span>, comprised of real or complex elements,  return the normalized <a href="https://bit.ly/2I0FQn2">Gram matrix</a>, that is,  the covariance matrix of <span>$X$</span>  corrected by sample size, but without subtracting the mean.</p><p>The result is flagged as <code>Hermitian</code>.  See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>If <span>$X$</span> is wide or square (r&lt;=c) return <span>$XX^H/c$</span>. If <span>$X$</span> is tall (r&gt;c)            return <span>$X^HX/r$</span>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
X=randn(5, 150);
G=gram(X) # =&gt; G=X*X&#39;/150
X=randn(100, 2);
F=gram(X); # =&gt; G=X&#39;*X/100</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/f27e675edc312b7b8b19ec8ba26c749419279589/src/signalProcessing.jl#L401-L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.trade" href="#PosDefManifold.trade"><code>PosDefManifold.trade</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>trade(P::ℍ{T}) where T&lt;:RealOrComplex</p><p>Given a positive definite matrix <code>P</code>, return as a 2-tuple the  <em>trace</em> and the <em>determinant</em> of <code>P</code>.  This is used to plot positive matrices in two dimensions  (<em>TraDe plots</em>: log(trace/n) vs. log(determinant), see exemple here below).</p><p><code>P</code> must be flagged by julia as <code>Hermitian</code>.   See <a href="../MainModule/#typecasting-matrices-1">typecasting matrices</a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifold
P=randP(3)
t, d=trade(P)  # equivalent to (t, d)=trade(P)

# TraDe plot
using Plots
k=100
n=10
𝐏=randP(n, k, SNR=1000); # 100 real Hermitian matrices
x=Vector{Float64}(undef, k)
y=Vector{Float64}(undef, k)
for i=1:k
    x[i], y[i] = trade(𝐏[i])
end
x=log.(x./n)
y=log.(y)
plot(x, y, seriestype=:scatter)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/f27e675edc312b7b8b19ec8ba26c749419279589/src/signalProcessing.jl#L429-L458">source</a></section><footer><hr/><a class="previous" href="../riemannianGeometry/"><span class="direction">Previous</span><span class="title">riemannianGeometry.jl</span></a><a class="next" href="../statistics/"><span class="direction">Next</span><span class="title">statistics.jl</span></a></footer></article></body></html>
