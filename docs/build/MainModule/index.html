<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MainModule (PosDefManifold.jl) ¬∑ PosDefManifold</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="PosDefManifold logo"/></a><h1>PosDefManifold</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>MainModule (PosDefManifold.jl)</a><ul class="internal"></ul></li><li><a class="toctext" href="../">PosDefManifold Documentation</a></li><li><a class="toctext" href="../introToRiemannianGeometry/">Intro to Riemannian Geometry</a></li><li><a class="toctext" href="../linearAlgebra/">linearAlgebra.jl</a></li><li><a class="toctext" href="../riemannianGeometry/">riemannianGeometry.jl</a></li><li><a class="toctext" href="../signalProcessing/">signalProcessing.jl</a></li><li><a class="toctext" href="../test/">test.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>MainModule (PosDefManifold.jl)</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifold.jl/blob/master/docs/src/MainModule.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>MainModule (PosDefManifold.jl)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="MainModule-(PosDefManifold.jl)-1" href="#MainModule-(PosDefManifold.jl)-1">MainModule (PosDefManifold.jl)</a></h1><p>This is the main unit containing the <strong>PosDefManifold</strong> <em>module</em>.</p><p>It uses the following standard Julia packages:</p><table><tr><th style="text-align: center">using</th></tr><tr><td style="text-align: center"><a href="https://bit.ly/2W5Wq8W">Linear Algebra</a></td></tr><tr><td style="text-align: center"><a href="https://bit.ly/2Oem3li">Statistics</a></td></tr></table><p>Examples in some units of <strong>PosDefManifold</strong> also uses the <code>Plots</code> package.</p><p>The main module does not contains functions, but it declares all <strong>constant</strong>, <strong>types</strong> and <strong>aliases</strong> of Julia functions and types used in all units.</p><table><tr><th style="text-align: center">Contents</th></tr><tr><td style="text-align: center"><a href="#constants-1">constants</a></td></tr><tr><td style="text-align: center"><a href="#aliases-1">aliases</a></td></tr><tr><td style="text-align: center"><a href="#types-1">types</a></td></tr><tr><td style="text-align: center"><a href="#tips-and-tricks-1">tips &amp; tricks</a></td></tr></table><h3><a class="nav-anchor" id="constants-1" href="#constants-1">constants</a></h3><table><tr><th style="text-align: center">constant</th><th style="text-align: right">value</th><th style="text-align: right">numeric value</th></tr><tr><td style="text-align: center"><code>sqrt2</code></td><td style="text-align: right">‚àö2</td><td style="text-align: right">1.4142135623730951</td></tr><tr><td style="text-align: center"><code>invsqrt2</code></td><td style="text-align: right">1/‚àö2</td><td style="text-align: right">0.7071067811865475</td></tr><tr><td style="text-align: center"><code>minpos</code></td><td style="text-align: right">1e-15</td><td style="text-align: right">0.000000000000001</td></tr><tr><td style="text-align: center"><code>maxpos</code></td><td style="text-align: right">1e15</td><td style="text-align: right">100000000000000</td></tr></table><h3><a class="nav-anchor" id="aliases-1" href="#aliases-1">aliases</a></h3><table><tr><th style="text-align: center">alias</th><th style="text-align: right">Julia function</th><th style="text-align: right">in Package</th><th style="text-align: right">tab-completition</th><th style="text-align: right">REPL support</th></tr><tr><td style="text-align: center"><code>ùö∫</code></td><td style="text-align: right"><a href="https://bit.ly/2FcsAJg"><code>sum</code></a></td><td style="text-align: right">Base</td><td style="text-align: right">\bfSigma</td><td style="text-align: right">‚õî</td></tr><tr><td style="text-align: center"><code>ùõç</code></td><td style="text-align: right"><a href="https://bit.ly/2TOakA0"><code>mean</code></a></td><td style="text-align: right">Statistics</td><td style="text-align: right">\bfmu</td><td style="text-align: right">‚õî</td></tr><tr><td style="text-align: center"><code>‚ã±</code></td><td style="text-align: right"><a href="https://bit.ly/2Jovxf8"><code>Diagonal</code></a></td><td style="text-align: right">LinearAlgebra</td><td style="text-align: right">\ddots</td><td style="text-align: right">‚úì</td></tr><tr><td style="text-align: center"><code>‚Ñç</code></td><td style="text-align: right"><a href="https://bit.ly/2JOiROX"><code>Hermitian</code></a></td><td style="text-align: right">LinearAlgebra</td><td style="text-align: right">\bbH</td><td style="text-align: right">‚úì</td></tr></table><p>All packages above are built-in julia packages.</p><h3><a class="nav-anchor" id="types-1" href="#types-1">types</a></h3><h4><a class="nav-anchor" id="Metric::Enumerated-type-1" href="#Metric::Enumerated-type-1">Metric::Enumerated type</a></h4><pre><code class="language-none">@enum Metric begin
  Euclidean    =1
  invEuclidean =2
  ChoEuclidean =3
  logEuclidean =4
  LogCholesky  =5
  Fisher       =6 # default metric
  logdet0      =7
  Jeffrey      =8
  VonNeumann   =9
  Wasserstein  =10
end</code></pre><p>Riemannian manipulations are defined for a given <em>metric</em> (see <a href="../introToRiemannianGeometry/#metrics-1">metrics</a>).  An instance for this type is requested as an argument in many functions  contained in the <a href="../riemannianGeometry/#riemannianGeometry.jl-1">riemannianGeometry.jl</a> unit in order to specify  the metric.</p><pre><code class="language-none"> ## Example
 # generate a 15x15 symmetric positive definite matrix
 P=randP(15)              
 # distance from P to the identity matrix according to the logdet0 metric
 d=distance(logdet0, P)  </code></pre><p>If you want to work consistently with a specific metric,  you may want to declare in your script a global variable such as</p><pre><code class="language-none">global metric=logdet0  or  global metric=Metric(Int(logdet0)),</code></pre><p>and then pass <code>metric</code> as argument in all your computations,  <em>e.g.</em>, referring to the above example,</p><pre><code class="language-none">d=distance(metric, P).</code></pre><p>To know what is the current metric, get it as a string as:</p><pre><code class="language-none">s=string(metric)</code></pre><h4><a class="nav-anchor" id="RealOrComplex-type-1" href="#RealOrComplex-type-1">RealOrComplex type</a></h4><p><code>RealOrComplex=Union{Real, Complex}</code> is the Union of Real and Complex Types.</p><h4><a class="nav-anchor" id="‚ÑçVector-type-1" href="#‚ÑçVector-type-1">‚ÑçVector type</a></h4><p><code>‚ÑçVector=Vector{‚Ñç}</code> is a vector of Hermitian matrices.  Julia sees is at: <code>Array{Hermitian,1}</code>.See <a href="#aliases-1">aliases</a> for the ‚Ñç symbol and  <a href="#typecasting-matrices-1">typecasting matrices</a> for the use of Hermitian matrices  in <strong>PosDefManifold</strong>.</p><p><strong>‚ÑçVector‚ÇÇ type</strong>   <code>‚ÑçVector‚ÇÇ=Vector{‚ÑçVector}</code> is a vector of <a href="#‚ÑçVector-type-1">‚ÑçVector type</a> objects, i.e.,   a vector of vectors of Hermitian matrices.   Julia sees it as: <code>Array{Array{Hermitian,1},1}</code>. Note that <code>‚ÑçVector‚ÇÇ</code>   is not a matrix of Hermitian matrices since the several <code>‚ÑçVector</code> objects   it holds do not need to have the same length.</p><h3><a class="nav-anchor" id="tips-and-tricks-1" href="#tips-and-tricks-1">tips &amp; tricks</a></h3><h4><a class="nav-anchor" id="typecasting-matrices-1" href="#typecasting-matrices-1">typecasting matrices</a></h4><p>Several functions in <strong>PosDefManifold</strong> implement multiple dispatch and can handle    several kinds of matrices as input, however the core functions for manipulating    objects on the Riemannian manifold of positive definite matrices act by definition  on positive definite matrices only.  Those matrices must therefore be either  <em>symmetric positive definite (real)</em> or <em>Hermitian (complex)</em>.  Such matrices are uniformly identified in <strong>PosDefManifold</strong> as being of the <code>Hermitian</code> type, using the standard <a href="https://bit.ly/2JOiROX">LinearAlgebra</a> package.  The alias <code>‚Ñç</code> is used consistently in the code (see <a href="#aliases-1">aliases</a>).  If the input is not flagged, the functions restricting the input to <em>positive definite matrices</em> will give an error.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; using LinearAlgebra

julia&gt; f(S::Hermitian)=S*S&#39;
f (generic function with 1 method)

julia&gt; A=randn(3, 3)
3√ó3 Array{Float64,2}:
 -0.67407  -0.344258    0.203714
 -1.06551  -0.0233796   0.975465
 -1.04727  -1.19807    -0.0219121

julia&gt; H=A*A&#39; # although SPD, H is not automatically flagged as Hermitian
3√ó3 Array{Float64,2}:
 0.614384  0.924991  1.11391
 0.924991  2.08738   1.12251
 1.11391   1.12251   2.53263

julia&gt; f(H)
ERROR: MethodError: no method matching f(::Array{Float64,2})
Closest candidates are:
  f(::Hermitian) at none:1</code></pre><p>If you construct a positive definite matrix and it is not flagged,  you can do so simply by <strong>typecasting</strong> it, that is, passing as argument to the  functions <code>Hermitian(P)</code> instead of just <code>P</code>. The <code>‚Ñç</code> alias can be  used for short, <em>i.e.</em>, <code>‚Ñç(P)</code>. Continuing the example above:</p><pre><code class="language-none">julia&gt; f(‚Ñç(H))  # this way it works, equivalent to f(Hermitian(H))
3√ó3 Array{Float64,2}:
 2.47388  3.74948  4.54381
 3.74948  6.4728   6.21635
 4.54381  6.21635  8.91504</code></pre><p>Similarly, if you want to construct an [‚ÑçVector type] from, say, two Hermitian  matrices <code>P</code> and <code>Q</code>, don&#39;t write <code>A=[P, Q]</code>, but rather <code>A=‚ÑçVector([P, Q])</code>.</p><p>Other functions act on generic matrices (of type <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.Matrix">Matrix</a>).  To those functions you can pass any matrix.  However, keep in mind that the functions writing on the argument matrix such as  <a href="../linearAlgebra/#PosDefManifold.normalizeCol!"><code>normalizeCol!</code></a> will give an error if you pass an <code>Hermitian</code> matrix,  since Julia does not allow writing on non-diagonal elements of those matrices.  In this case typecast it in another object using the <code>Matrix</code> type;  suppose <code>H</code> is <code>Hermitian</code>, you would use for example:</p><pre><code class="language-none">julia&gt; X=Matrix(H)
julia&gt; normalizeCol!(X, 1)
julia&gt; norm(X[:, 1])
1.0</code></pre><p>Another example when typecasting is useful: functions like the <a href="../signalProcessing/#PosDefManifold.gram"><code>gram</code></a> function takes a <code>Matrix</code> type as argument (since <code>X</code> is expected to be a data matrix),  like in</p><pre><code class="language-none">H=gram(X).</code></pre><p>The following would not work though:</p><pre><code class="language-none"> H=gram(X&#39;)</code></pre><p>since <code>X&#39;</code> is an <code>Adjoint</code> type. The problem is fixed by typecasting the  adjoint matrix, such as</p><p>H=gram(Matrix(X&#39;)).</p><p>Another example: here is how to get an Hermitian matrix out of the  diagonal part of an Hermitian matrix H:</p><pre><code class="language-none">Hermitian(Matrix(Diagonal(H))).</code></pre><h4><a class="nav-anchor" id="BLAS-routines-1" href="#BLAS-routines-1">BLAS routines</a></h4><p>Some functions in <strong>PosDefManifold</strong> call BLAS routines for optimal performnce. This is reported in the help section of the concerned functions. When this is the case, you can set the number of threads the BLAS library should use by:</p><p>using LinearAlgebra    BLAS.set<em>num</em>threads(n)</p><p>where <code>n</code> is the number of threads.</p><footer><hr/><a class="next" href="../"><span class="direction">Next</span><span class="title">PosDefManifold Documentation</span></a></footer></article></body></html>
